# Dishonorable mention

Anonymous

## Judges' comments:

The author was too embarrassed that he/she could write such trash, so I
promised to protect their identity.  I will say that the author of this
program has a well known connection with the C programming language.

This program is a unique variation on the age old "Hello, world"
program.  What reads like a read may be written like a write!

Copyright (c) 1984, Landon Curt Noll.
All Rights Reserved.  Permission for personal, educational or non-profit use is
granted provided this this copyright and notice are included in its entirety
and remains unaltered.  All other uses must receive prior permission in writing
from both Landon Curt Noll and Larry Bassel.
# Third place

Mike Laman

## Judges' comments:

Some new compilers dislike lines 6 and 10 of the source, so we changed
them from:

	;++f)a[		b<<5|c]		=d++,b+		=e;for(		f=0;f<O
	<<5|c]^		=a[b<<5		|c]^=a[		(k-(b+1		))<<5|c]

to:

	;++f)a[		b<<5|c]		=d++,b+=	e;for(		f=0;f<O
	<<5|c]^=	a[b<<5		|c]^=a[		(k-(b+1		))<<5|c]

I hope you have the C beautifier! The program accepts ONE positive
argument.  Seeing is believing, so try things like:

	laman 4
	laman 9
	laman 16

This code should run you in circles.

Copyright (c) 1984, Landon Curt Noll.
All Rights Reserved.  Permission for personal, educational or non-profit use is
granted provided this this copyright and notice are included in its entirety
and remains unaltered.  All other uses must receive prior permission in writing
from both Landon Curt Noll and Larry Bassel.
# The Grand Prize 

Sjoerd Mullender

Robbert van Renesse

## Judges' comments:

Without question, this C program is the most obfuscated C program that
has ever been received!  Like all great contest entries, they result
in a change of rules for the following year.  To prevent a flood of
similar programs, we requested that programs be non machine specific.

This program was selected for the 1987 t-shirt collection.

> NOTE: If your machine is not a Vax-11 or pdp-11, this program will
> not execute correctly.  In later years, machine dependent
> code was discouraged.

The C startup routine (via crt0.o) transfers control to a location
named main.  In this case, main just happens to be in the data area.
The array of shorts, which has been further obfuscated by use of
different data types, just happens to form a meaningful set of PDP-11
and Vax instructions.  The first word is a PDP-11 branch instruction
that branches to the rest of the PDP code.  On the Vax main is called with
the calls instruction which uses the first word of the subroutine as a
mask of registers to be saved.  So on the Vax the first word can be anything.
The real Vax code starts with the second word.  This small program
makes direct calls to the write() Unix system call to produce a
message on the screen.  Can you guess what is printed?  We knew you
couldn't!  :-)

Copyright (c) 1984, Landon Curt Noll.
All Rights Reserved.  Permission for personal, educational or non-profit use is
granted provided this this copyright and notice are included in its entirety
and remains unaltered.  All other uses must receive prior permission in writing
from both Landon Curt Noll and Larry Bassel.
# Second place award 

Dave Decot

## Compile with:

	cc decot.c -o decot -lm

## Judges' comments:

Some new compilers disliked line 15 of the source, so we changed it from:

	for(signal=0;*k * x * __FILE__ *i;) do {

to:

	for(signal=0;*k *x * __FILE__ *i;) do {

This program prints out a string of garbage.

The judges also offer this one comment: understand comments!

Copyright (c) 1984, Landon Curt Noll.
All Rights Reserved.  Permission for personal, educational or non-profit use is
granted provided this this copyright and notice are included in its entirety
and remains unaltered.  All other uses must receive prior permission in writing
from both Landon Curt Noll and Larry Bassel.
# The strangest appearing program 

Ed Lycklama

## Judges' comments:

Run the program without any arguments.  Type in some very long lines
and notice how it redisplays it.

The program itself looks like tty noise.  Notice that even 'define' in #define can be defined.

Copyright (c) 1985, Landon Curt Noll & Larry Bassel.
All Rights Reserved.  Permission for personal, educational or non-profit use is
granted provided this this copyright and notice are included in its entirety
and remains unaltered.  All other uses must receive prior permission in writing
from both Landon Curt Noll and Larry Bassel.
# The most obscure program

Lennart Augustsson
<chalmers!augustss> 

## Judges' comments:

An interesting use of a recursive call to main.  Compile and execute
without args.  What is the initial value of b, and does it alter the
action of the program?

If you let it, the program will continue to print a numerical sequence
(can you guess in what base it is printed?) until you run out of
memory or until they sell your computer, which ever comes first.

Copyright (c) 1985, Landon Curt Noll & Larry Bassel.
All Rights Reserved.  Permission for personal, educational or non-profit use is
granted provided this this copyright and notice are included in its entirety
and remains unaltered.  All other uses must receive prior permission in writing
from both Landon Curt Noll and Larry Bassel.
# Grand prize for most well-rounded in confusion

Carl Shapiro

## Judges' comments:

As submitted, this program was 3 lines (2 of defines and 1 of code).
To make news & mail happy we split the last line into 7. Join them
back without the newlines to get the original version.

This program was selected for the 1987 t-shirt collection.

We found this program is be simply a**maze**ing!  Run this program without
arguments and notice the output.

Copyright (c) 1985, Landon Curt Noll & Larry Bassel.
All Rights Reserved.  Permission for personal, educational or non-profit use is
granted provided this this copyright and notice are included in its entirety
and remains unaltered.  All other uses must receive prior permission in writing
from both Landon Curt Noll and Larry Bassel.
# The worst abuse of the C preprocessor

Col. G. L. Sicherman

## Judges' comments:

This program abuses the C preprocessor so much that some /lib/cpp's fail to
strip out all of the comments on the first pass!  If you were able to
understand Decot's entry in 1984, you will have a head start on this
one.

Be sure to run this program through lint!  If your lint works
correctly, it should warn you that the argument 'Manual' isn't used.
Like the program says, what's that mean?

Run the program without arguments and enter the letters 'a' thru 'm'
on a line.  Now enter the letters 'n' thru 'z'.  But to borrow a quote
from Richard Stallman: If you think you understand what this code
does, then you don't, so read it again!  Explain why:

	sicherman < sicherman.c | sicherman | diff - sicherman.c

results in diff reporting a difference on some machines.

Copyright (c) 1985, Landon Curt Noll & Larry Bassel.
All Rights Reserved.  Permission for personal, educational or non-profit use is
granted provided this this copyright and notice are included in its entirety
and remains unaltered.  All other uses must receive prior permission in writing
from both Landon Curt Noll and Larry Bassel.
# Best one liner 

Jack Applin [with help from Robert Heckendorn]

## Judges' comments:

One liner programs are short but twisted.  This "Hello, World" version
certainly takes its time saying hello.

Copyright (c) 1985, Landon Curt Noll & Larry Bassel.
All Rights Reserved.  Permission for personal, educational or non-profit use is
granted provided this this copyright and notice are included in its entirety
and remains unaltered.  All other uses must receive prior permission in writing
from both Landon Curt Noll and Larry Bassel.
# Most useful obfuscation 

Walter Bright

## Judges' comments:

Compile this program and give filenames as arguments.  For example try:

	bright bright.c
	bright bright

Mr. Bright exploits the c pre-processor, similar variables and
excessive shifting to obfuscate an otherwise useful binary display
program.  This gives you a small example of what it is like to
maintain the Bourne shell! :-}

Copyright (c) 1986, Landon Curt Noll & Larry Bassel.
All Rights Reserved.  Permission for personal, educational or non-profit use is
granted provided this this copyright and notice are included in its entirety
and remains unaltered.  All other uses must receive prior permission in writing
from both Landon Curt Noll and Larry Bassel.
# The grand prize in most well-rounded in confusion

Larry Wall  
System Development Corporation  
Santa Monica  
California  
US of A  

## Judges' comments:

The original version did not have a ';' character in the first line.
This caused a number of System V C pre-preprocessors to gripe about a
syntax error.

This program is a masterpiece of obfuscation and humor.  Larry Wall
(the hacker who gave us rn and patch) asks you to compile and consider
the warning message generated by the C compiler.  Then execute the
program and type charters into its standard input.  You will see why
the compiler documents the program.

Copyright (c) 1986, Landon Curt Noll & Larry Bassel.
All Rights Reserved.  Permission for personal, educational or non-profit use is
granted provided this this copyright and notice are included in its entirety
and remains unaltered.  All other uses must receive prior permission in writing
from both Landon Curt Noll and Larry Bassel.
# Most illegible code

Michael H. Pawka  
Naval Ocean Systems Center  
San Diego, Ca  
92152  

## Judges' comments:

The judges found this entry to be one of hardest to read without the
aid of `/lib/cpp` and a good editor.  When run, the program asks if it
is obfuscated, of all things!

Copyright (c) 1986, Landon Curt Noll & Larry Bassel.
All Rights Reserved.  Permission for personal, educational or non-profit use is
granted provided this this copyright and notice are included in its entirety
and remains unaltered.  All other uses must receive prior permission in writing
from both Landon Curt Noll and Larry Bassel.
# Best one liner 

Jan Stein

Judges' comments:

> NOTE: to avoid problems with news and mail, the single line was split
> into 3 lines.  Join all lines into a single line to recreate
> the original file.

Compile and link to a filename called 'a.out'.  Try the program with the
following argument:

	a.out ^N^N

(^N is ASCII control-N).  One some machines, ^M^L is needed to get it to
output cleanly.  Your system may require another set of characters.
In time, you will figure out what it does. :-)

Copyright (c) 1986, Landon Curt Noll & Larry Bassel.
All Rights Reserved.  Permission for personal, educational or non-profit use is
granted provided this this copyright and notice are included in its entirety
and remains unaltered.  All other uses must receive prior permission in writing
from both Landon Curt Noll and Larry Bassel.
# Worst abuse of the C preprocessor

Jim Hague  
University of Kent at Canterbury  
Canterbury, Kent  
UK  

## Judges' comments:

Compile this program and feed ascii text into standard input.  This
program is known to pass lint on some systems and abort lint on
others.

This program was selected for the 1987 t-shirt collection.

Think morse code when you ponder this program.  Note how use of
similar variables can be obfuscating!  The author notes that this
program implements the international morse standard.  Now for extra
credit, what morse message does the program spell out?

Copyright (c) 1986, Landon Curt Noll & Larry Bassel.
All Rights Reserved.  Permission for personal, educational or non-profit use is
granted provided this this copyright and notice are included in its entirety
and remains unaltered.  All other uses must receive prior permission in writing
from both Landon Curt Noll and Larry Bassel.
# Best simple task performed in a complex way

Bruce Holloway  
Digital Research, Inc.  
Monterey, CA  
USA  

## Judges' comments:

Believe it or not, this is the old standard "Hello, world" program
performed in a very complex way.  The judges and the author defy you
do determine how it does it.  It is a good thing that K&R didn't use
this version as the first C program!

Copyright (c) 1986, Landon Curt Noll & Larry Bassel.
All Rights Reserved.  Permission for personal, educational or non-profit use is
granted provided this this copyright and notice are included in its entirety
and remains unaltered.  All other uses must receive prior permission in writing
from both Landon Curt Noll and Larry Bassel.
# Best complex task done in a complex way

Lennart Augustsson  
Dept. of Comp. Sci.  
Chalmers University of Technology,  
412 96 Gothenburg  
Sweden  

## Judges' comments:

This program computes a specific mathematical value.  Simply compile
and give it an infinite amount of stack space and cpu time.  Otherwise
just be satisfied with the approximation displayed just before the core
dump.

This program will pass lint on your system assuming your lint is brave
enough to try and parse it correctly.

Copyright (c) 1986, Landon Curt Noll & Larry Bassel.
All Rights Reserved.  Permission for personal, educational or non-profit use is
granted provided this this copyright and notice are included in its entirety
and remains unaltered.  All other uses must receive prior permission in writing
from both Landon Curt Noll and Larry Bassel.
# Best layout

Eric Marshall  
System Development Corporation, a Burroughs Company  
P.O. Box 517  
Paoli, PA.  
19301  

# Judges' comments:

This program prints the name of the picture.  The layout is somewhat
pretty through it is not the usual sort of output one would expect
from printing a program!

This program was selected for the 1987 t-shirt collection.

This program is known to give some C compilers a problems.

Copyright (c) 1986, Landon Curt Noll & Larry Bassel.
All Rights Reserved.  Permission for personal, educational or non-profit use is
granted provided this this copyright and notice are included in its entirety
and remains unaltered.  All other uses must receive prior permission in writing
from both Landon Curt Noll and Larry Bassel.
# Most adaptable program

Jack Applin  
Hewlett-Packard  
Ft. Collins  
Colorado  
USA  

## Judges' comments:

Compile and/or execute as directed by the documentation.

The judges were so amused by this little program that we created an
award just for it.  This program is portable to the C and Fortran 77
compilers as well as executable by the bourne shell!

Copyright (c) 1986, Landon Curt Noll & Larry Bassel.
All Rights Reserved.  Permission for personal, educational or non-profit use is
granted provided this this copyright and notice are included in its entirety
and remains unaltered.  All other uses must receive prior permission in writing
from both Landon Curt Noll and Larry Bassel.
# Most Useful Obfuscation

Larry Wall  
Unisys - System Development Group Santa Monica  
9132 Kester Ave  
Panorama City, CA  91402  USA  

## Judges' comments:

### Try:
	lwall | bc | lwall
	input:	x*x
	input:	c^2

### Also try:
	lwall | bc   and   lwall | cat

What we found amazing was how the flow of control was transferred
between subroutines.  Careful inspection will show that the array of
pointers to functions named 'vi' refers to functions which seem to not
be directly called.  Even so, these pointers to functions are being
used as an argument to signal.  Can you determine why this is being
done and how it is being exploited?

Some compilers complained about this file, so we changed: '=++I' to '= ++I'.

Copyright (c) 1987, Landon Curt Noll & Larry Bassel.
All Rights Reserved.  Permission for personal, educational or non-profit use is
granted provided this this copyright and notice are included in its entirety
and remains unaltered.  All other uses must receive prior permission in writing
from both Landon Curt Noll and Larry Bassel.
# Best One Liner

David Korn  
AT&T Bell Labs  
MH 3C-526B, AT&T Bell Labs  
Murray Hill, NJ  
07974  
USA  

## Judges' comments:

The Judges believe that this is the best one line entry ever received.
Compile on a UN*X system, or at least using a C implementation that
fakes it.  Very few people are able to determine what this program
does by visual inspection.  I suggest that you stop reading this
section right now and see if you are one of the few people who can.

Several points are important to understand in this program:

1) What is the symbol 'unix' and what is its value in the program?
   Clearly 'unix' is not a function, and since 'unix' is not declared
   to be a data type (such as int, char, struct foo, enum, ...)
   what must 'unix' be?

2) What is the value of the symbol "have"?  (hint: the value is
   NOT 4 characters, or 'h', or a string)  Consider the fact that:

        char *x;

  defines a pointer to a character (i.e. an address), and that
  the '=' assigns things is compatible types.  Since:

        x = "have";

  is legal C, what type of value is "have"?

3) Note that the following expressions yield the same value:

        x[3]	*(x+3)	  *(3+x)

   since addition is communitive.  What can be said about the value:

        3[x]

David Korn's /bin/ksh provides us with a greatly improved version of
the /bin/sh.  The source for v7's /bin/sh greatly inspired this contest.

Copyright (c) 1987, Landon Curt Noll & Larry Bassel.
All Rights Reserved.  Permission for personal, educational or non-profit use is
granted provided this this copyright and notice are included in its entirety
and remains unaltered.  All other uses must receive prior permission in writing
from both Landon Curt Noll and Larry Bassel.
# Best Obfuscator of Programs

Paul Heckbert  
Pixar  

## Judges' comments:


### Try:
	ph 40 < ph.c > foo.c; cc foo.c -o ph
	ph 20 < a_C_prog.c > bar.c; cc bar.c

The judges used this program to fold up very long lines which the
BSD fold(1) was unable to process.  This program has been added
to the contest tool chest.

On System V systems, compile with: `-Dindex=strchr`
To compile on a 16 bit machine, change 300000's to 30000.

Copyright (c) 1987, Landon Curt Noll & Larry Bassel.
All Rights Reserved.  Permission for personal, educational or non-profit use is
granted provided this this copyright and notice are included in its entirety
and remains unaltered.  All other uses must receive prior permission in writing
from both Landon Curt Noll and Larry Bassel.
# Best Layout

Brian Westley (aka Merlyn Leroy on usenet)  
Starfire Consulting  
1121 Hamline Ave. N. #17  
St. Paul, MN  
55108  
USA  

## Judges' comments:

Putchar must exist in the C library and not just as a macro.
If it fails to compile, add the line:  `#include <stdio.h>`  at the
top of the program.

Line by line symmetry performed better than any C beautifier.  Think
of if it as a C ink blot.  :-)

Copyright (c) 1987, Landon Curt Noll & Larry Bassel.
All Rights Reserved.  Permission for personal, educational or non-profit use is
granted provided this this copyright and notice are included in its entirety
and remains unaltered.  All other uses must receive prior permission in writing
from both Landon Curt Noll and Larry Bassel.
# Best Abuse of the Rules

Mark Biggar  
UNiSYS - System Development Group, Santa Monica  
2525 Colorado AV MD 91-01  
Santa Monica, CA  
90406  

## Judges' comments:

### To build:

	cc -DC="R>0" -DI="if(T)O" -DO="c=write(1,&c,1);" -DP="main(){X}"\
	-DR="read(0,&c,1)" -DT="c!=015" -DW="while(C)I" -DX="char c;W" markb.c

Passes BSD and UTS lint.  At least one version of lint is thrown into
an infinite loop by this entry.

### Try:

	... | markb | od -c	(remember to compile as indicated above)


By changing the compile line you can make this program do anything you
want.  This is a very efficient way to transfer source, though it
increases the size of Makefiles.

With only slight variations, this program can be set to many uses.
Consider how easy it would be to release Un*x source in this form;
so what if the make files grow a little!  :-) 

One vendor's lint got hung in an infinite loop over this entry!

> FYI:  We will let Mark get away with this truly sick entry this time, but 
> for the future on we have placed a limit on the size of a compile line.

Also see our comment in Larry Wall's entry regarding Mark's contribution.

Copyright (c) 1987, Landon Curt Noll & Larry Bassel.
All Rights Reserved.  Permission for personal, educational or non-profit use is
granted provided this this copyright and notice are included in its entirety
and remains unaltered.  All other uses must receive prior permission in writing
from both Landon Curt Noll and Larry Bassel.
# Grand Prize

Roemer B. Lievaart  
VU Informatica  
Churchilllaan 173-IV  
Amsterdam, The Netherlands  


## Judges' remarks:

We believe that you too will be amazed at just how much power Mr. Lievaart
packed into 1024 bytes!

This Plays the game of reversi (Othello)!  Compile and run.  It then
asks for a playing level. Enter 0-10 (easy-hard).  It then asks for
your move. A move is a number within 11-88, or a 99 to pass.  Illegal
moves (except for an illegal pass) are rejected.  Then the computer
does its move (or a 0 to pass), until the board is full.

It plays rather well, for such a small program!  Lievaart had to leave out the
board printing routine, so you'll have to take a real game board to
play it. ...  Also due to space-limitations (the rules for 1987 had a
limit of 1024 byes), Lievaart took out the passing-handler, which
makes its ending-game rather poor.  But further it knows all the
rules, uses alpha-beta pruning, and it plays f.i. on mobility(!).
Most important: it can play a pretty good game of Reversi!

The Author was kind enough to supply the fully functional version of the
program.  The file lievaart2.c contains what the program would have
been without the size restriction.  This version has the full end game 
logic and displays the board after each move!

Copyright (c) 1987, Landon Curt Noll & Larry Bassel.
All Rights Reserved.  Permission for personal, educational or non-profit use is
granted provided this this copyright and notice are included in its entirety
and remains unaltered.  All other uses must receive prior permission in writing
from both Landon Curt Noll and Larry Bassel.
# Worst Style

Spencer Hines  
OnLine Computer Systems  
4200 Farragut Street  
Hyattsville, MD  
20781  
USA  

## Judges' comments:

### Try:

	hines hines.c

This program was designed to maximize the bother function for
structured programmers.  This program takes goto statements to their
logical conclusion.  The layout and choice of names are classic.

We consider this to be a beautiful counter-example for Frank Rubin's
letter to ACM form titled: *"GOTO Considered Harmful" Considered Harmful*.
See the Communications of the ACM, March 1987, Page 195-196.

Copyright (c) 1987, Landon Curt Noll & Larry Bassel.
All Rights Reserved.  Permission for personal, educational or non-profit use is
granted provided this this copyright and notice are included in its entirety
and remains unaltered.  All other uses must receive prior permission in writing
from both Landon Curt Noll and Larry Bassel.
# Best visuals

Mark Isaak  
Imagen Corporation  
2650 San Tomas Expy.  
Santa Clara, CA   
95052-8101  
USA  

## Judges' comments: 

### To compile:

        cc -DI=B -DO=- -Dy isaak.c -o isaak

Execute without arguments.

The original entry starts with the line:

        main(){};

This works on some 4.3BSD systems.  Why?  Note that #include <stdio.h>
is given on the last line.  Why is this needed?  Note the unusual calls
to sprintf.

> NOTE:  The program relies heavily on ASCII.  Don't even think of
running it on an EBCDIC machine.  If you name the file anything 
other than "isaak.c", you must change the #include on line 7.

> NOTE: The use of null comments to separate macros to construct different 
tokens from a single macro (e.g., "O/**/O" creates either "++" or "--" 
by defining "O" to be "+" or "-") may cause some strict ANSI
C preprocessors to object.

> NOTE: Most System V machines will not be able to execute this program
correctly due to the fact that BSD style systems have an sprintf()
that returns a char *.

Due to the above problems, we have replaced the output of this program
in the file: isaak.encode.  To read this file do:

        uudecode < isaak.encode
        cat isaak.output

FYI: We are likely to be more strict about portability in the future.

Copyright (c) 1988, Landon Curt Noll & Larry Bassel.
All Rights Reserved.  Permission for personal, educational or non-profit use is
granted provided this this copyright and notice are included in its entirety
and remains unaltered.  All other uses must receive prior permission in writing
from both Landon Curt Noll and Larry Bassel.
# Best abuse of the rules

Diomidis Spinellis (currently at Imperial College, London, England)  
1 Myrsinis Str.  
GR-145 62 Kifissia  
GREECE  

## Judges' comments:

### To compile:

        /lib/cpp spinellis.c > spin.c

and type the following text followed by an EOF ('^D'):

        main()
        {
            printf("Hello world\n");
        }

> FYI: We enjoyed this entry this year, however in the future programs 
must be able to be compiled from within a makefile without the
need of human intervention.

## Author's comments:

This program can be configured to do almost everything.
The configuration is done during compile time by typing
in, C code, that one would like the program to perform.
A trivial example is given in the `how to compile' section
but the possibilities are clearly limited only by your
imagination and programming skills.

Copyright (c) 1988, Landon Curt Noll & Larry Bassel.
All Rights Reserved.  Permission for personal, educational or non-profit use is
granted provided this this copyright and notice are included in its entirety
and remains unaltered.  All other uses must receive prior permission in writing
from both Landon Curt Noll and Larry Bassel.
# Best small program

Maarten Litmaath  
Free University (VU) Amsterdam  
Department of computer science  
Uilenstede 72  
1183 AK Amstelveen  
The Netherlands  

## Judges' comments:

### Try:

        litmaath eschew obfuscation

Note the unusual structure:

        while (<condition>)
            ;

Did you notice that the body is empty?

The best one can do to understand how the program works is to give it
two small strings as arguments, and follow the program closely.  One
could make the body of the 'while' loop an 'fprintf' with interesting
variables like:

    fprintf(stderr,
	     "argv=%lo *argv=%lo **argv=%c argv[1]=%lo *argv[1]=%c argc=%d\n",
	     (long) argv, (long) *argv, *argv && **argv ? **argv : '@',
	     (long) argv[1], argv[1] && *argv[1] ? *argv[1] : '@', argc);

Furthermore, it's interesting to note that only two variables are
used to achieve everything.

Copyright (c) 1988, Landon Curt Noll & Larry Bassel.
All Rights Reserved.  Permission for personal, educational or non-profit use is
granted provided this this copyright and notice are included in its entirety
and remains unaltered.  All other uses must receive prior permission in writing
from both Landon Curt Noll and Larry Bassel.
# Best abuse of system calls

Paul Dale  
University of Queensland  
Computer Science Dept  
Dept of Computer Science  
Uni of Qld, 4067  
Australia  

## Judges' comments:

### Try:

        dale hello world
        dale these files are in this directory: *

This entry has a very twisted flow of control via recursion, iteration 
and multi-processing.  Try to understand what is being done with the
system calls.

NOTE: This program assumes the ascii character set is being used.

Copyright (c) 1988, Landon Curt Noll & Larry Bassel.
All Rights Reserved.  Permission for personal, educational or non-profit use is
granted provided this this copyright and notice are included in its entirety
and remains unaltered.  All other uses must receive prior permission in writing
from both Landon Curt Noll and Larry Bassel.
# Best layout

Merlyn LeRoy (Brian Westley)  
Rosemount, Inc.  
1121 Hamline Ave. N. #17  
St. Paul, MN    
55108  
U.S.A.  

## Judges' comments:

Compile and execute without arguments.

Note: Your compiler must parse

		#define _ -a
		-_

as "--a" and not "-(-a)" or some other tokenized form.  Some strictly
conforming ANSI C Preprocessors may object to this: for such
compilers, you can elide the nonstandard token-pasting requirement
by changing the #define line to:

		#define _ F-->00||F-OO--;

You might enjoy looking at the output of:

	cc -E westley.c

Copyright (c) 1988, Landon Curt Noll & Larry Bassel.
All Rights Reserved.  Permission for personal, educational or non-profit use is
granted provided this this copyright and notice are included in its entirety
and remains unaltered.  All other uses must receive prior permission in writing
from both Landon Curt Noll and Larry Bassel.
# Best abuse of C constructs

Arch D. Robison  
University of Illinois at Urbana-Champaign  
1304 W. Springfield Ave.  
Urbana IL   
61801  
USA  

## Judges' comments:

### Try:

        robison 80 10
        robison 40 16

The first and second parameters are optional.  You might also try:

        robison 80 2   <--- can you find the bug?
        robison 80 -246

## Author's comments:

This program shows that C has many unnecessary constructs, in fact
only "while","--", and ">=" are required.  (The two assignments at
the beginning could be avoided if "atoi" was rewritten with this
new paradigm.)  Note that the lack of both the controversial "goto"
and assignment statements makes the meaning crystal clear.  The current 
ANSI committee should look into this practical simplification of C.

The following might make an interesting benchmark:

        robison 100    

[Amdahl 5890-300E with System V cc: 8.40 seconds]

We suggest that you C preprocess and perhaps C-beautify this program.
All is not what it may appear to be in this program.  When does a whi1e
not take a while to execute?

Copyright (c) 1988, Landon Curt Noll & Larry Bassel.
All Rights Reserved.  Permission for personal, educational or non-profit use is
granted provided this this copyright and notice are included in its entirety
and remains unaltered.  All other uses must receive prior permission in writing
from both Landon Curt Noll and Larry Bassel.
# Least likely to compile successfully

Ian Phillipps  
Cambridge Consultants Ltd  
Science Park  
Milton Road  
Cambridge CB4 4DW  
England  

## Judges' comments:

Compile and run without parameters.

The program is smaller than even the 'compressed' form of its output,
and thus represents a new departure in text compression standards.

The judges thought that this program looked like what you would get
by pounding on the keys of an old typewriter at random.

Copyright (c) 1988, Landon Curt Noll & Larry Bassel.
All Rights Reserved.  Permission for personal, educational or non-profit use is
granted provided this this copyright and notice are included in its entirety
and remains unaltered.  All other uses must receive prior permission in writing
from both Landon Curt Noll and Larry Bassel.
# Most useful Obfuscated C program

Gopi Reddy  
Amperif Corporation  
9232 Eton Avenue  
Chatsworth, CA  
91311  
U.S.A.  

## Judges' comments:

Compile and give the following line as input:

        char *(*(fun[16])();

This is a somewhat restricted version of a useful program that has been
posted to Usenet.  What is unusual is what it is able to do so much
in such little space.

Copyright (c) 1988, Landon Curt Noll & Larry Bassel.
All Rights Reserved.  Permission for personal, educational or non-profit use is
granted provided this this copyright and notice are included in its entirety
and remains unaltered.  All other uses must receive prior permission in writing
from both Landon Curt Noll and Larry Bassel.
# Best of show

Jack Applin  
Hewlett-Packard  
3404 E. Harmony Rd  
Ft. Collins, CO   
80525   
USA  

## Judges' comments:

Compile and execute with no argument, if you can!

This entry is by far the most unusual abuse of the C preprocessor that
we have received thus far.  Nearly all of the real work is done in the
preprocessor!

When we compiled applin.c on an Amdahl 5890-300E, we found that it
spent over 75 minutes in the System V C preprocessor!  Besides showing
that the standard System V cpp is slow, it showed that it contained a
memory usage problem.  The applin.c only uses 29 different preprocessor
symbols (besides <stdio.h>) and yet the preprocessor ran out of space!

The GNU C preprocessor took less than 45 seconds to perform the 2nd pass 
on the Amdahl 5890-300E.  But due to the ANSI-ness of GNU cpp (v.  1-21), 
it was not able to cleanly substitute a symbol that began with a '#'.
Clearly the GNU C preprocessor is faster.

A smaller version of applin.c can be found in zsmall.c.  Your machine
may have an easier time with this program.  See the Makefile for details.

Copyright (c) 1988, Landon Curt Noll & Larry Bassel.
All Rights Reserved.  Permission for personal, educational or non-profit use is
granted provided this this copyright and notice are included in its entirety
and remains unaltered.  All other uses must receive prior permission in writing
from both Landon Curt Noll and Larry Bassel.
# Best of show

Jari Arkko, Ora Lassila, Esko Nuutila  
Laboratory of Information Processing Science  
Helsinki University of Technology  
Otakaari 1  
02150 Espoo  
Finland  

## Judges' comments:

This is the most useful program entered this year. It is a
rather large subset of lisp.  It has no error recovery, and
performs rather poorly in a number of cases.  Even so, placing
all this functionality in such a small, densely packed program,
is impressive enough to win the Best of show award.

## Selected author's comments:

This program implements a Lisp interpreter in 1465 bytes of source.
Some sophisticated features supported, eg. functionals and recursion.  
The special-forms/functions/variables implemented are:
	
		+	-	*	<	()	
		car	cdr	cons	defun	equal
		function if	lambda	quote	t
	
Below are sample lisp expressions you might choose to try as input.
The program implements a conventional lisp listener, i.e. you type in
lisp expressions (followed by CR), the program evaluates them and
prints out the return values. End execution by typing an end-of-file
character.
	
	(+ 2.5 3.1)
	(defun fib (n)
	   (if (< n 2)
	       1
	       (+ (fib (- n 2)) (fib (- n 1)))))
	(fib 10)
	(defun ! (x) (if (equal x 0) 1 (* x (! (- x 1)))))
	(! 7)
	(defun fn1 (fn) (+ (fn 1 2) (fn 3 4)))
	(defun fn2 (a b) (+ a b))
	(fn1 (function +))
	(fn1 (function fn2))
	(fn1 (function (lambda (z1 z2) (+ z1 z2))))
	(quote a)
	(cons (quote (a b)) (quote (c d e)))
	(cons (quote (f)) ())
	(car (quote (a b c)))
	(cdr (cdr (quote (g h i))))
	
Please do not leave any whitespace before the first parenthesis when
you type your input, or any other unnecessary whitespace. Please try to
avoid any undefined variables or functions, wrong number of arguments
etc. All these errors are likely to dump core (i.e. there are no error
checks in the program).
	
Traditional Lisp implementations use cons cells as the main data
structure. Lists are organized of pointer chains of these cells.
In this program, an alternate representation was chosen: char*'s.
All list operations, including the ones in the interpreter, are
made using string representations of the lists. These operations
must count parentheses and skip whitespace. This leads to extremely
poor performance!

Copyright (c) 1989, Landon Curt Noll & Larry Bassel.
All Rights Reserved.  Permission for personal, educational or non-profit use is
granted provided this this copyright and notice are included in its entirety
and remains unaltered.  All other uses must receive prior permission in writing
from both Landon Curt Noll and Larry Bassel.
# Most complex algorithm

Paul E. Black  
CIRRUS LOGIC, Inc.  
1463 Centre Pointe Dr.  
Milpitas, CA   
95035   
USA  

## Judges' comments:

The original source contained a long line which caused many
mailers to barf.  The original file may be re-constructed by
removeing the trailing "\" on line 12 and joining lines 12 and
13 together without a space.

WHAT FOLLOWS IS A DETAILED PROGRAM EXPLINATION AND SPOILER.
IF YOU WANT A REAL CHALLENGE, DON'T READ ANY FURTHER AND TRY
TO UNDERSTAND THE PROGRAM VIA THE SOURCE.


## Selected author's comments:

This programs computes and prints Fibonacci numbers by
simulating a Turing machine with the proper program.
Understanding the C program, i.e., a Turing machine simulator,
is only the first and simplest step.  The Turing machine
program must be understood, too!  (it is trivial, perhaps even
natural to write incredibly obscure Turing programs.)

If the program is invoked with an operand, the operand is used
as the Turing program.  It includes a "trace" facility,
subroutine r (commented out for obscurity), to help write and
debug Turing programs.  Just the thing for some fun in a Theory
of Computation class.

The Turing machine tape is represented as a doubly linked list
of pointers.  The forward and backward links are XOR'd together
and stored in one pointer.  If we always keep one of the links
on hand, we can recover the other link at any time.  The
variable q is the scan head (and a pointer at some tape cell),
and p is a "previous" link.  The state of the tape is stored in
the low order bit of the pointer.  Since we always allocate an
even number of bytes, the low order bit carries no information
(see portability below.) Memory representing a tape cell is
allocated when the cell is first scanned.  Thus the simulation
begins with a tape effectively the size of virtual memory set
to all zeros.  Since a header can be added to any Turing
program to write initial data and position the scan head, this
is little loss of generality.

The simulated Turing machine has a single tape with either an 1
or a 0 in each cell.  The Turing machine language format is a
string of three bytes.  The first byte is the current state.
The second byte is the next state.  (The last bit of states is
ignored, e.g., B and C are the same state, in an attempt to be
able to have interesting words in the program.)  The third byte
is composed of bits.  Bit 1 (2&byte) is the symbol scanned,
i.e. an instruction is selected for state and for a match with
the symbol under the scan head.  Bit 2 (4&byte) is the new
symbol to be written to the cell.  Bit 3 (8&byte) is the
direction to move the scan head: 0 for left and 1 for right.
If bit 4 (16&byte) is true, the next character is sent to
stdout.  (I added this feature so programs could print
results.)

The Turing machine has next state 'j' when it begins.  The
cycle is 1) exit if the state is 'x', 2) find the next
instruction (given the state and the character under the scan
head).  [The program string is searched forward for the next
matching instruction.  If the end of the string is reached, the
search begins again at the first of the string.  Thus states
can be used as local labels in different places.]  3) change to
the next state, 4) print a character if indicated, 5) write the
tape symbol, and 6) move the scan head.  The cycle then repeats
with step 1.  A call to the trace routine is just before step
2, but is commented out.

The following ROT13'ed text is a quick outline of the actual
Turing program:

	Urer vf n dhvpx bhgyvar bs gur Ghevat cebtenz: gur
	cerivbhf naq pheerag Svobanppv ahzoref ner xrcg va onfr
	1 sbez jvgu gur pheerag ba gur evtug.  Gur svefg guerr
	fgrcf frg hc gur svefg gjb ahzoref, 1 naq 1.  Gura
	[ortvaavat jvgu "@ ("] n znexre bs VVV vf perngrq naq
	gur pheerag ahzore vf pbcvrq gb gur evtug bs gur
	znexre.  Gura [ortvaavat jvgu "BI "] gur ahzore vf
	pbairegrq gb ovanel ol ercrngrq qvivqvat ol 2 yrnivat V
	sbe erznvaqre 1, naq VV sbe erznvaqre 0.  Arkg
	[ortvaavat jvgu "JI "] gur ovanel ercerfragngvba vf
	cevagrq naq vgf flzobyf naq gur znexre ner renfrq.
	Svanyyl [ortvaavat jvgu "RRa"] gur gjb ahzoref ner
	nqqrq naq gur pheerag ahzore pbcvrq gb gur yrsg gb
	orpbzr gur cerivbhf.  Gura gur plpyr ercrngf.

The program requires that the lowest bit of a pointer to be 0.

I could have squeezed the program under 1024 bytes without the
trace subroutine, but I felt it was important for understanding
the program.  Besides it is fun to watch the tape zooming back
and forth as the program runs.  A much better debugger or trace
could easily be added.

Copyright (c) 1989, Landon Curt Noll & Larry Bassel.
All Rights Reserved.  Permission for personal, educational or non-profit use is
granted provided this this copyright and notice are included in its entirety
and remains unaltered.  All other uses must receive prior permission in writing
from both Landon Curt Noll and Larry Bassel.
# Best game

John Tromp  
Centre for Mathematics and Computer Science (CWI)  
Oetgensstraat 7  
1701CK Heerhugowaard  
Netherlands  

# Judges' comments:

This is a character terminal version of the TETRIS program. 
It runs on a VT100 compatible terminal or emulator.  It is 
best used at 4800 baud or more.
	
Usage:

		tromp [drops_per_sec  [cmd_string]]
		tromp.s5 [1  [cmd_string]]
	
By default, "drops_per_sec", the number of times an object
will drop in a second, is 2.  The default "cmd_string" is
"jkl pq".  The first 6 characters of "cmd_string" relate
to the following 6 game commands:

		j - left
		k - rotate
		l - right
	  <space> - drop
		p - pause
		q - quit
	
Specifying "cmd_string" allows one to re-define the commands.
The pause command pauses the game, clears the screen and
prints the current score.  To un-pause, type the pause
character again, which by default is "p".

This original program requires a BSD-style interval timer and
and new BSD signal interface.  If you are using System V.3
or earlier, for example, you will need to make "tromp.s5" 
instead of "tromp".  You can change the default make rule 
by changing "tromp" to "tromp.s5" in the "WINNERS=..." line
of the Makefile.

The "tromp.s5" version is not as functional as "tromp".  
The "drops_per_sec" is ignored and defaults to 1.  The level 
is always reported as 0.

As was stated last year, we are likely to be more strict about
portability in the future.  [ We mean it this time :-) ]

# Selected author's comments:

This program plays the familiar game of `TETRIS' with the
following features:

* outputs vt100-like escape-sequences for cursor 
      positioning and normal/reverse video in curses 
      like fashion (minimal output for screen updates)

* continuously increasing speed (except in pause)

* start speed selectable by giving n as first argument, 
      where n is the number of drops per second (default=2).

* controls also selectable by giving as the second argument 
      a string of 6 characters.  By default they are "jkl pq".

    * screen is blanked during the pause and the score is shown

    * maintains a high-score table

Giving a full path name for the table will result in a
system-wide hiscore allowing a competition between users.

The author provided us with the following notes and new version of
the program:

>	Here is a somewhat improved version of my tetris entry.  All the 
> 	changes are in the popen() at the end.  Formerly a move was done 
> 	to the HI score file which is not permitted for other users. Now 
> 	other users can change the HI score file.  The extra option -m is 
> 	passed to sort, so that it knows that its input files are already 
> 	sorted.  The -o output option of sort is used instead of a 
>   	temporary file.

>	You may also want to consider giving just the raw option to stty
>	at the start and -raw at the end. This further reduces the size of
>	the program, but has the possible disadvantage that the program
>	can only by stopped by 'q' or by the `kill -9' command.

    long h[4];t(){h[3]-=h[3]/3000;setitimer(0,h,0);}c,d,l,v[]={(int)t,0,2},w,s,I,K
    =0,i=276,j,k,q[276],Q[276],*n=q,*m,x=17,f[]={7,-13,-12,1,8,-11,-12,-1,9,-1,1,
    12,3,-13,-12,-1,12,-1,11,1,15,-1,13,1,18,-1,1,2,0,-12,-1,11,1,-12,1,13,10,-12,
    1,12,11,-12,-1,1,2,-12,-1,12,13,-12,12,13,14,-11,-1,1,4,-13,-12,12,16,-11,-12,
    12,17,-13,1,-1,5,-12,12,11,6,-12,12,24};u(){for(i=11;++i<264;)if((k=q[i])-Q[i]
    ){Q[i]=k;if(i-++I||i%12<1)printf("\033[%d;%dH",(I=i)/12,i%12*2+28);printf(
    "\033[%dm  "+(K-k?0:5),k);K=k;}Q[263]=c=getchar();}G(b){for(i=4;i--;)if(q[i?b+
    n[i]:b])return 0;return 1;}g(b){for(i=4;i--;q[i?x+n[i]:x]=b);}main(C,V,a)char*
    *V,*a;{h[3]=1000000/(l=C>1?atoi(V[1]):2);for(a=C>2?V[2]:"jkl pq";i;i--)*n++=i<
    25||i%12<2?7:0;srand(getpid());system("stty cbreak -echo stop u");sigvec(14,v,
    0);t();puts("\033[H\033[J");for(n=f+rand()%7*4;;g(7),u(),g(0)){if(c<0){if(G(x+
    12))x+=12;else{g(7);++w;for(j=0;j<252;j=12*(j/12+1))for(;q[++j];)if(j%12==10){
    for(;j%12;q[j--]=0);u();for(;--j;q[j+12]=q[j]);u();}n=f+rand()%7*4;G(x=17)||(c
    =a[5]);}}if(c==*a)G(--x)||++x;if(c==a[1])n=f+4**(m=n),G(x)||(n=m);if(c==a[2])G
    (++x)||--x;if(c==a[3])for(;G(x+12);++w)x+=12;if(c==a[4]||c==a[5]){s=sigblock(
    8192);printf("\033[H\033[J\033[0m%d\n",w);if(c==a[5])break;for(j=264;j--;Q[j]=
    0);while(getchar()-a[4]);puts("\033[H\033[J\033[7m");sigsetmask(s);}}d=popen(
    "stty -cbreak echo stop \023;sort -mnr -o HI - HI;cat HI","w");fprintf(d,
    "%4d from level %1d by %s\n",w,l,getlogin());pclose(d);}

Copyright (c) 1989, Landon Curt Noll & Larry Bassel.
All Rights Reserved.  Permission for personal, educational or non-profit use is
granted provided this this copyright and notice are included in its entirety
and remains unaltered.  All other uses must receive prior permission in writing
from both Landon Curt Noll and Larry Bassel.
# Most algorithms in one program

Merlyn LeRoy (Brian Westley)  
Starfire Consulting  
1026 Blair Ave.  
St. Paul, MN    
55104    
USA  

## Judges' comments:

There is a secret way to get ONE of the versions to print out
"Hello, world!\n".  Can you find how to do it?

### Try:

		westley < westley.c > ver0.c
		westley 1 < westley.c > ver1.c
		westley 1 2 < westley.c > ver2.c
		westley 1 2 3 < westley.c > ver3.c
	
Try compiling and running the 4 resulting programs.

## Selected author's comments:

This is a filter.  If it is run with no arguments, it copies
stdin to stdout.  With one argument, it ROT13's stdin to
stdout.  With two arguments, it reverses stdin to stdout.  With
three arguments, it does both.  It requires the ASCII character
set, with all characters being in 0..255, and EOF must be -1.
Also requires two's complement (I think).

The source code will run if ROT13'ed and/or reversed, using a
different algorithm for each version (hereafter referred to as
ver0 (original), ver1 (ROT13), ver2 (reversed), and ver3 
(ROT13 and reversed)).

When compiling these versions, one needs to define 'trgpune'
in the compile line.  Example:

		cc -Dtrgpune=putchar ver3.c -o ver3

"trgpune" is the ROT13 of getchar(), so getchar() and putchar()
are exchanged in the ROT13 counterpart.  It is easy to see that
this is unavoidable.  I must have a #define for a library
function; otherwise I would have an unidentifed extern for the
ROT13 version.  If I then define this function, it won't link
in the library version for the ORIGINAL code, since my
definition will supercede the library function.  Hence, the
compiler option gives me putchar(), and allows me to use
getchar().  I pass a dummy argument to getchar() to eliminate
"variable number of args" from lint (unless it checks against
the library).  Otherwise, all versions lint reasonably (main
returns random value & constant in conditional context [when I
check for ROT13 version] is all it complains about).

ver0 and ver1 use a range check and a calculation to do ROT13,
while ver2 and ver3 use table lookup.  All versions contain
main() and it's ROT13 fn, znva().  ver0/ver1 [ver2/ver3] are
(of course) syntactically identical, since the syntax is in the
non-alphabetic characters.  However, since one program starts
at main() while it's ROT13 counterpart starts at znva(), znva()
calls main (znva() is also used for output).

All versions use recursion to work.  If the program is NOT
reversing it's output, it prints out the (possibly ROT13'd)
character before recursing, otherwise it prints it out
afterward (or doesn't recurse at all when EOF is reached).
Since most of this code is identical, it is put into znva() and
called with a first parameter of 0 as a flag (as "main()", it's
first argument (argc) must be at least one).

I can't use any flow control.  If I used if(), I would have a
function vs() to define in the ROT13 version.  But a function
called vs() turns into a function called if() in the original,
so it can't be done.  Therefore, I do:

		expr1 && expr2 && (expr3=etc);

which is the same as:

		 if (expr1 && expr2) expr3=etc;

A/UX on the Macintosh doesn't get this right; it evaluates ALL
expressions if they aren't in an assignment or conditional
statement.  This might warrant a warning, since other compilers
may do this.  I found MANY compilers botched:

		expr1 && (expr2,expr3);

expr2 was OFTEN evaluated even if expr1 was false.  I removed
such statements to make it more portable.

The variable names are worth noting:

'irk' and  'vex' are ROT13 pairs and are synonyms.  
'Near' and 'Arne' are ROT13 pairs and are anagrams.  
'NOON' and 'ABBA' are ROT13 pairs and are palindromes.  
'tang' and 'gnat' are both ROT13 and palindrome pairs!  

Normally (!), a reversible C program is done thus:

		/**/ forward code /*/ edoc drawkcab /**/

If your compiler nests comments, it will get this wrong.
However, I have made some bits of the code palindromic,
(or different, but reversible) so it is more like:

		/**/forward/*//**/ palindromic /**//*/drawkcab/**/

The code can therefore be interlaced.  There are eight
such palindromic bits.  You can find them within the
/*//**/   /**//*/ pairs.

The body of the code of ver0 and ver1 is a large lumpy 'K' (for
Kernighan); the code of ver2 and ver3 is a flat-topped and
lumpier 'R' (for Ritchie).  Judicious use of spaces and tabs
helped here.  It barely fits on an 80x24 screen.  Squint.  Note
that the code must start with a blank line, or the reversed version
will lack a terminating newline.

Copyright (c) 1989, Landon Curt Noll & Larry Bassel.
All Rights Reserved.  Permission for personal, educational or non-profit use is
granted provided this this copyright and notice are included in its entirety
and remains unaltered.  All other uses must receive prior permission in writing
from both Landon Curt Noll and Larry Bassel.
# Best layout

Lievaart, Roemer B.  
VU-Informatica, Amsterdam  
Marcusstraat 29/2,   
NL 1091 TJ Amsterdam  
Netherlands  

# Judges' comments:

Do you know what this program does?  If you do, look again,
there is more here than meets the PI.

# Selected author's comments:

Passes lint, but not with the strictest options, for it
contains some "null-statements", as well two identifiers
which are, if compilers only take 6 characters, the same.  It
also uses write(2), so not totally system independent.

You are very much invited to pass this program through a
C-beautifier. (First strip newlines and tabs, if your cb can't
do that.)

Copyright (c) 1989, Landon Curt Noll & Larry Bassel.
All Rights Reserved.  Permission for personal, educational or non-profit use is
granted provided this this copyright and notice are included in its entirety
and remains unaltered.  All other uses must receive prior permission in writing
from both Landon Curt Noll and Larry Bassel.
# Strangest abuse of the rules

Jari Arkko  
Laboratory of Information Processing Science  
Helsinki University of Technology  
Otakaari 1  
02150 Espoo  
Finland  

## Judges' comments:

On many systems the compiler will not allow you to send the
object file to /dev/tty.  The author suggested:

		cc -c -o /dev/tty jar.1.c

On systems that have symbolic links, we suggest:

		ln -s /dev/tty jar.1.o
		cc -c jar.1.c
	
if your system has symbolic links.  The shell script run
by the makefile simply cats the .o file to the terminal
which can be used as a last resort.

Abuse of the rules winners usually result in a change of the
rules.  Starting in 1990, compiling entries must result an
regular file which can be executed.

## Selected author's comments:

This program is (supposedly) the smallest C program able to
print "Hello world.". The compilation itself produces the
desired printout and the program need not be actually run.

Copyright (c) 1989, Landon Curt Noll & Larry Bassel.
All Rights Reserved.  Permission for personal, educational or non-profit use is
granted provided this this copyright and notice are included in its entirety
and remains unaltered.  All other uses must receive prior permission in writing
from both Landon Curt Noll and Larry Bassel.
# Best minimal use of C

Arch D. Robison  
University of Illinois  
1304 W. Springfield Ave.  
Urbana, IL   
61801  
USA  

## Judges' comments:

Sites with punch card facilities will be happy to note that
the source deck can be re-collated with an ASCII sort.

Note that this program uses only a small subset of the
constructs that the C language supports.

## Selected author's comments:

This program is a handy picoAPL interpreter written in C--.  It
outputs the evaluation of an APL expression from standard
input.  Functions are limited to dyadic +,-,x, and unary -;
numerals must be binary.  Parentheses may be used for
grouping.  For example:

		101x111-100

prints:

		1111

That is 5x(7-4) is 15.  (APL groups from right to left.)
Extending it to the full APL language should be trivial.

The C-- language improves the C language by removing superfluous
and confusing features: arithmetic, logical operations, shifts,
relationals, address-of, and flow control.  In fact, the only 
expressions retained are function calls, indirection, array 
assignments, the ',' operator, and sizeof.  Despite these
restrictions, the C-- program does arithmetic on arbitrarily 
large binary numbers.

To obtain a C-- reference, simply rip out the irrelevant pages 
from your K&R C manual.  To obtain a C-- compiler, simply rip
out the irrelevant bytes from your cc compiler.

Copyright (c) 1989, Landon Curt Noll & Larry Bassel.
All Rights Reserved.  Permission for personal, educational or non-profit use is
granted provided this this copyright and notice are included in its entirety
and remains unaltered.  All other uses must receive prior permission in writing
from both Landon Curt Noll and Larry Bassel.
# Best one liner

David Van Brackle  
Department of Computer Science  
University of Central Florida  
Orlando, Florida   
32816  
USA   

## Judges' comments:

This program computes all proper subsets of the set of
arguments passed to it.  Each subset is printed with one 
element on each line, followed by a line of ten dashes.

### Try:

		vanb the rug gary lent	
		vanb unix is better than os/2

## Selected notes from the author:

The program has the following charming and possibly 
non-portable features:

* It has no local or global variables, 
      only the command-line parameters.

* It calls main recursively.

* It alters the command-line parameters.

* It uses the fact that if the high bit is set in a character
      variable, the value is negative.

Copyright (c) 1989, Landon Curt Noll & Larry Bassel.
All Rights Reserved.  Permission for personal, educational or non-profit use is
granted provided this this copyright and notice are included in its entirety
and remains unaltered.  All other uses must receive prior permission in writing
from both Landon Curt Noll and Larry Bassel.
# Best self-modifying program

Jay Vosburgh  
Sequent Computer Systems, Inc  
15450 SW Koll Parkway  
Beaverton, OR  
97006  
USA  

## Judges' comments:

Run this with a single digit argument (or wait a long time).

There are 2 versions of this program, the one that was entered,
and one that was changed by the judges to be more portable. The
makefile runs the latter version by default.

The blank line at the beginning of the source is mandatory.
Do you know why?

The shell script run by the makefile joins lines that may be
cut up by mailers.  The file "fubar.orig.c", for example, needs
the 6th and 7th lines joined together (with a space between
them) to recreate the original entry.  If you fix the file, you
will need to change the last 8 linnes of "fubar.orig.sh" to read:

		cp fubar.orig.c ouroboros.c
		chmod +x ouroboros.c
		csh ouroboros.c $1
		rm -f ouroboros.c x1 x

The more portable version, "fubar.c", can be fixed by joining the
7th and 8th lines in the same way.  As well, if you fix "fubar.c"
you will need to also change the last 8 lines to "fubar.sh" to read:

		cp fubar.c ouroboros.c
		chmod +x ouroboros.c
		csh ouroboros.c $1
		rm -f ouroboros.c x1 x

## Selected author's comments:

In a nutshell, this is probably the slowest and most
obnoxious factorial program ever written.  Unfortunately, 
the name of the C source must be "ouroboros.c"; the name is 
hard-coded into the program.  

The source is a legal shell script and a legal C program.  
The shell script compiles itself, and then executes the
resulting binary, giving the source as input.  The program 
works by successively modifying #define lines each pass through.

Both "indent" and "cb" will damage the program, "indent" 
much more so.

Copyright (c) 1989, Landon Curt Noll & Larry Bassel.
All Rights Reserved.  Permission for personal, educational or non-profit use is
granted provided this this copyright and notice are included in its entirety
and remains unaltered.  All other uses must receive prior permission in writing
from both Landon Curt Noll and Larry Bassel.
# Most humorous output

Oskar von der Luehe  
Institut fuer Astronomie  
ETH - Zentrum  
8092 Zuerich  
Switzerland  

## Judges' comments:

Run this program using your favorite text file as input.  Files
such as mailboxes, man pages and usenet articles are especially
recommended.  You will get different output each time you run it.

Run the program this way:

		ovdluhe < textfile

The program stops when it reaches the end of the template buffer 
by chance or is killed.

## Selected author's comments:

This program implements an "Eddington ape" - it generates
random text from a supplied template.  The template text file
is read through stdin.  The larger the template, the better the
result.  A maximum of 2**12 chars are used. From the template,
the program calculates the statistics of chars that immediately
follow a given string (correlator string) of a certain length
(currently 4 - can be varied by changing the definition for P
accordingly).  A character is randomly chosen, weighted by its
probability to occur after the correlator string.  That
character is printed to stdout and placed at the end of the
correlator string, whose first character is discarded.
Meaningful words are therefore usually preserved, the effect on
sentences can be dramatically random.

You might want to vary the definition of P between 2 and 10 and
observe the result.

Copyright (c) 1989, Landon Curt Noll & Larry Bassel.
All Rights Reserved.  Permission for personal, educational or non-profit use is
granted provided this this copyright and notice are included in its entirety
and remains unaltered.  All other uses must receive prior permission in writing
from both Landon Curt Noll and Larry Bassel.
# Best Small Program

Doron Osovlanski  
CADTECH - CAD/CAM Systems Ltd  
24 Ben-Yosef st.  
Givat-Shmuel   51905  
Israel  

Baruch Nissenbaum  
Tel-Aviv University  
The Faculty of Engineering  
Tel-Aviv  
Israel  


## Judges' comments:

Compile.  Try:

	echo 4 | baruch
	echo 7 | baruch

This program reads an integer between 4 and 99 from the stdin.

>    NOTE: The original program did not have a newline at the end of
the file.  We added a final newline to the file to make
unpacking easy.


## Selected notes from the author:

The goal of this work was to write a program that solves the
classic n-queen problem, with a board size of up to 99x99, while
keeping the program as short as possible.

The program finds all possibilities to place N chess queens on
a NxN chess board so that no queen is in range of any other queen
(not in the same column row or diagonal).  For each solution the
chess board and the place of the queens is printed to stdout.


This program is about as simple and as readable as possible.
To make things even more simple we used a very limited subset of C:

	     No pre-processor statements
	     Only one, harmless, 'for' statement
	     No ifs
	     No breaks
	     No cases
	     No functions
	     No gotos
	     No structures

In short, it contains no C language that might confuse the
innocent reader.  :-)


This program demonstrates the claim that in C, any program
can be written using a single 'for' statement, as long as it is
long enough..

The authors further note:

For PC users:
In order to compile the program under Turbo-C or MSC, 'int '
should be inserted at the beginning of the program.
For better looking results it is recommended to replace the " #Q"
string with " \261\2".

Copyright (c) 1990, Landon Curt Noll & Larry Bassel.
All Rights Reserved.  Permission for personal, educational or non-profit use is
granted provided this this copyright and notice are included in its entirety
and remains unaltered.  All other uses must receive prior permission in writing
from both Landon Curt Noll and Larry Bassel.
# Most Unusual Data Structure

Peter J Ruczynski.  
Pyramid Technology Ltd.  
Pyramid House,  
Solatron Road  
Farnborough.  
Hants GU14 7PL  
England, U.K.  


## Judges' comments:

This program prints out a string.  Can you figure out how
it is done?

By use of pointers to functions returning a struct of pointers 
to functions!

Note that some compilers will be unable to compile the
expression 'X=g()...' in main due to lack of temporary
value space.  One might want to try replacing main with:

    	main(){X=s().v().o().o().l().S().d().l().i().o().w().N();}
    
if this is a problem.


Spoiler: (rot13 to read)

    Guvf cebtenz cevagf bhg gur fgevat:

    gur dhvpx oebja sbk whzcrq bire gur ynml qbt

    ol hfr bs cbvagref gb shapgvbaf ergheavat n fgehpg bs cbvagref 
    gb shapgvbaf!


Selected notes from the author: (rot13 to read)

    Vg vf fvzcyr gb znxr gur cebtenz cevag bgure fgevatf.  Rnpu
    nycunorgvpny punenpgre sebz n gb m vf cevagrq bhg nf vgf
    bccbfvgr:

    	n->m o->l p->k rgp

    Gb rapbqr n arj fgevat vachg gur fgevat nf vg vf zrnag gb pbzr bhg:

    	K=f().i().b().b().y().F().q().y().v().b().j().A();

    Abgr: F() ercerfragf n fcnpr naq A() n arjyvar.  Guvf jvyy abj
    cebqhpr...

    	uryyb jbeyq

By the way, there is actually a piece of code which is not used
in the original program! I leave it as an intellectual exercise
to the reader to find out what it is.


Copyright (c) 1990, Landon Curt Noll & Larry Bassel.
All Rights Reserved.  Permission for personal, educational or non-profit use is
granted provided this this copyright and notice are included in its entirety
and remains unaltered.  All other uses must receive prior permission in writing
from both Landon Curt Noll and Larry Bassel.
# ANSI Committee's Worst Abuse of C

Larry Jones  
SDRC  
2000 Eastman Dr  
Milford, OH 45150    
USA  


## Judges' comments:

The addition of trigraphs has made it easier to make programs 
hard to read.  It was a dark and stormy night for C when the
ANSI C committee added trigraphs to the standard.  Too bad
that they didn't just simply require a more reasonable ISO
character set.

The common.mk (non-ANSI) makefile uses sed to form scjones.alt.c.
The scjones.alt.c is similar to the original scjones.c source,
but with all the trigraphs converted.  You might want to try:

		make -f common.mk scjones.alt.c

even if you only have an ANSI compiler, just to see how
the trigrapsh are converted.

> WARNING: In the future, we will be passing ANSI programs through a
	 trigraph filter before reading.  Trigraph-ifacation will
	 not be a major consideration in future contests.  People 
	 should exploit more interesting features of ANSI C.


## Selected notes from the author:

Since this year's contest is dedicated to ANSI C, here is a
strictly conforming entry.  In accordance with the ANSI
definition of a strictly conforming program it does not produce
output dependent on any unspecified, undefined, or implementation
defined behavior, and it does not exceed any of the minimum
implementation limits.  It adheres to all of the syntactic and
semantic constraints of the standard, #includes the relevant
headers for the functions it uses, and uses the EXIT_SUCCESS and
EXIT_FAILURE macros to return a correct success/fail status to
the invoking program.  It also uses trigraphs for characters
which are not in the Invariant Code Set of ISO 646:1983, so it
will be portable to machines with deficient (from C's standpoint)
character sets.  In short, it should be very widely portable.  As
an extra added attraction, all of the lines are under 72
characters long, which would allow for sequence numbers to be
punched in columns 73-80 :-).

[[ The Author sent us this note after he was informed that he won ]]

Although I am quite grateful for the "ANSI Committee's Worst Abuse
of C" title (were you aware that I am a member of the committee or
is the double meaning unintentional?), I was really hoping for
something more along the lines of "Closest Resemblance to Line Noise."  :-)

[[ ... it was unintentional ]]

Copyright (c) 1990, Landon Curt Noll & Larry Bassel.
All Rights Reserved.  Permission for personal, educational or non-profit use is
granted provided this this copyright and notice are included in its entirety
and remains unaltered.  All other uses must receive prior permission in writing
from both Landon Curt Noll and Larry Bassel.
# Best Abuse of the C Preprocessor

David Goodenough  
anonymous organization  
541 Commonwealth Ave,  
Newton, MA 02159  
USA  

## Judges' comments:

Compile and run.

### Try:

	echo "to C or not to C" | dg

Some C preprocessors get confused about single quotes in certain cases.
In particular, the following source line:

   Cb12(ase(bco(acp(bi(acp(bcp(acp(bpl(aqu(bqu(A))))))))))))))))))))))))))))))

may need to be changed to:

   Cb12(ase(bco(acp(bi(acp(bcp(acp(bpl('A'))))))))))))))))))))))))))))

if your C preprocessor botches single quotes in cpp expansions.

Systems that have index() and don't strchr() (e.g., BSD) should
compile with without -Dindex=strchr.

## Selected notes from the author:

If my preprocessor could hack it, I could write this as one single
line rather than 4, but when I do that I get a complaint "defines
nested too deeply".

Spoiler: (rot13 to read)

Guvf vf nabgure ebg13 wbo (oryvrir vg be abg) - gur #qrsvarf ner n
abiry jnl bs nqqvat gbxraf: '#qrsvar o12(k) 12 k' zrnaf gung ng
fbzr cbvag va gur fbhepr n 12 vf sbyybjrq ol gur pbzcerffrq arfgrq
qrsvarf. Gur o12 trgf gur cerivbhf pbzcerffvba nf na nethzrag, naq
cercraqf gur 12, guhf znxvat nabgure fgrc va gur erperngvba bs gur
fbhepr. Gur nkk() qrsvarf qb gur fnzr, ohg nqq gbxraf nsgre.

Nf sbe gur ebg13 nytbevguz, vg eryvrf ba vaqrk() gb svaq vs gur
punenpgre vf va gur frg N-Mn-m. y[] vf na neenl gung trgf svyyrq
jvgu:

"abcdefghijklmmmmnopqrstuvwxyzzzzABCDEFGHIJKLMMMMNOPQRSTUVWXYZZZZ"

Vs vaqrk() fnlf gur pune vf va gur nycunorg, gura kbe gur bssfrg
jvgu 16 gb genafyngr, naq bhgchg, bgurejvfr cnff vg hapunatrq.

Copyright (c) 1990, Landon Curt Noll & Larry Bassel.
All Rights Reserved.  Permission for personal, educational or non-profit use is
granted provided this this copyright and notice are included in its entirety
and remains unaltered.  All other uses must receive prior permission in writing
from both Landon Curt Noll and Larry Bassel.
# Best Game

Chris Mills  
Wyse Technology  
3471 N. 1st St.  
San Jose CA 95134  
USA  


## Judges' comments:

### To compile:

       cc -DM=500 -DN=52 -DX="srand((int)time(0L))" -DV=void -o cmills cmills.c

	-DM=<max bet allowed>
	-DN=<52 * number of decks used>
	-DX=<how to seed the rand() generator>
	-DV=<void ot int>

### To run:

        cmills [starting_cash]


## Selected notes from the author:

This is a blackjack program.  It does splits, doubling down,
insurance, etc.  

As best I can figure, it should be ANSI-compliant, as well as
portable to BSD & sysV (as well as the irritating compiler I
was using which assumes x=*p++ means x*=p++!).  It is
reasonably robust in its error handling---it won't let you
split, double, etc. unless you actually have the cash, etc.  To
terminate the program, hit EOF or type 0 or a negative number
for you wager.

The way it deals with splits is particularly cool (IMHO).  You
can split many times, and it will show all hands as they are
played.

Copyright (c) 1990, Landon Curt Noll & Larry Bassel.
All Rights Reserved.  Permission for personal, educational or non-profit use is
granted provided this this copyright and notice are included in its entirety
and remains unaltered.  All other uses must receive prior permission in writing
from both Landon Curt Noll and Larry Bassel.
# Best of Show

Adrian Mariano  
University of Washington  
2729 72nd Ave SE  
Mercer Island, WA 98040  
USA  


## Judges' comments:

The program's source implements four functions, all from the
same source file!

Usage:

	theorem expression x1 x2 h y1

	where:
		expression - function f(x,y)  (see below)
		x1 - start of interval
		x2 - end of interval
		h - step size
		y1 - initial value  (y(x1) == y1)

When you compile theorem.c as is and run with 5 args, it numerically
solves the equation y'=f(x,y), with a step size of h, over the interval 
x=[x1,x2], with the initial condition of y(x1)=y1.

The 'expression' f(x,y), is any function of 'x' and 'y' with the
operators:
    
		+	-	*	/	^

The symbol '^' is the power operator.  Note that it only supports
integer powers.  Also note that all expressions are evaluated strictly 
left to right.  (i.e., parenthesis aren't supported).

Try running the program with the following args:

	theorem y 0 1 0.1 1
	theorem 1/x 1 2 0.1 0
	theorem 'x^2/y+x' 0 1 0.1 6
    
But wait, there is more!  You also get, free of charge, a 
reversing filter!  Try:

	theorem -r 0 0 0 0 < theorem.c > sorter.c
    
Still not impressed?  The author throws in for free, a 
sort program! Try:

	cc sorter.c -o sorter
	ls | sorter
    
This program is safe for home use as well.  The author has
included a safety feature in case you misplace the original
program source:

	sorter -r 0 0 0 0 < sorter.c > theorem_bkp.c
    
And finally, as a special offer to users of this entry,
the author provides a Fibonacci sequence generator!  Try:

	sorter 0 0 0 0 < theorem.c > fibonacci.c
	cc fibonacci.c -o fibonacci
	fibonacci 1 1
	fibonacci 2 1

Program available 9 track and cartridge cassette.  Gensu knife
not included!  :-)

When this program was first shown at the 1990 Summer Usenix 
conference, it received a standing ovation; a first for
a contest entry.

It should be noted that the 4 trailing args '0 0 0 0', are
required on systems that dump core when NULL is dereferenced.


## Selected notes from the author:

Differential equations are solved via the Runge-Kutta method, 
which guarantees local error proportional to h^5, and total
error across a finite interval is at most a constant times h^4.

Sorting is accomplished with a standard shell sort.

Note that the sorting and reversing is limited to files with 
fewer than 500 lines, each less than 99 characters long.  

Copyright (c) 1990, Landon Curt Noll & Larry Bassel.
All Rights Reserved.  Permission for personal, educational or non-profit use is
granted provided this this copyright and notice are included in its entirety
and remains unaltered.  All other uses must receive prior permission in writing
from both Landon Curt Noll and Larry Bassel.
# Strangest Abuse of the Rules:

Stig Hemmer  
Norwegian Institute of Technology  
N-7034 Trondheim-NTH  
Norway   

## Judges' comments:

We changed the alias that the author's suggested alias from a
C-shell alias to a Korn shell alias because many C-shells
did not allow Stig Hemmer's form of aliasing.  (The error 
may have also been due to some uucp site corrupting his 
entry) Below is the author's 'how to compile' sections as 
mailed to us:

    ---how to ANSI compile---
    Xecho alias c cc -E -o o.c shst.c -"\''Dc=main(){printf("\"N%sested E
    Ccomments allowed.\\n\",'/*/*/0*/**/'1?\"\":\"o n\"");}'\'';cc -o c o.c'
    Xsource shst.c"|csh
    ---how to common compile---
    Xecho alias c cc -E -o o.c shst.c -"\''Dc=main(){printf("\"N%sested E
    Ccomments allowed.\\n\",'/*/*/0*/**/'1?\"\":\"o n\"");}'\'';cc -o c o.c'
    Xsource shst.c"|csh

Note that shst.c is renamed to stig.c in the distribution.

Producing an equivalent C-shell alias or /bin/sh function
is left as an exercise to the reader.

> WARNING: This program's 'how to compile' is too specific to a particular
	 shell.  The obfuscation of this program to more related to
	 shell obfuscation than C obfuscation.  This type of entry will 
	 not be permitted in future contests.

## Selected notes from the author:

If you like shell programming you may also admire my
creative quoting. (I use echo to create an alias
which when run calls cc with the -D option to create a
C macro with double quotes in it. ARRRRRGGGHHH!)

The program is totally portable, but the compile
commands are very shell specific so don't be TOO mad
at me if they don't work for you.

If you want to put these commands in a Makefile you
must add 4 - four - backslashes at the end on first
line. (At least that's what works here.)

If everything works correctly it create an executable
named c which checks whether your compiler supports
nested comments. I've stolen the "/*/*/0*/**/1" from
somewhere so don't give me any points for it. Of
course neither ANSI nor K&R support nested comments
when properly implemented, but what the heck. 

Copyright (c) 1990, Landon Curt Noll & Larry Bassel.
All Rights Reserved.  Permission for personal, educational or non-profit use is
granted provided this this copyright and notice are included in its entirety
and remains unaltered.  All other uses must receive prior permission in writing
from both Landon Curt Noll and Larry Bassel.
# Best Layout

Brian Westley (Merlyn LeRoy on usenet)  
DigiBoard, Inc.  
1026 Blair Ave.  
St. Paul, MN  55104    
USA  

## Judges' comments:

    usage: westley <number>

If you would rather "Daisy" someone other than Westley, rename 
the program as needed.  :-)

Read each block of code as if it were a piece of correspondence.
For example, the first block of code would read:

	charlie,
		doubletime me, OXFACE!
		not interested, get out
		mainly die, charly, *die*
			signed charlotte

The original source had control-L's after each code block.  To 
make it easier on news readers, we converted each control-L to 
a blank line.

Some ANSI compilers will not accept '1s' as a short integer - for
these compilers replace the '1s' with '1'.


## Selected notes from the author:

This is a "Picking the Daisy" simulation.  Now, instead of mangling a 
daisy, simply run this program with the number of petals desired as 
the argument.

This is a good counter-example to peoples' complaints that C doesn't
have an "English-like" syntax.

Lint complains about everything - null effect, xxx may be used before
set, statement not reached, return(e) and return.  Lint dumps core
on some systems.  My personal favorite lint complaint is
    
    	"warning: eroticism unused in function main".
    
Also obviously, (char)lotte and (char*)lie are incompatible types...

Copyright (c) 1990, Landon Curt Noll & Larry Bassel.
All Rights Reserved.  Permission for personal, educational or non-profit use is
granted provided this this copyright and notice are included in its entirety
and remains unaltered.  All other uses must receive prior permission in writing
from both Landon Curt Noll and Larry Bassel.
# Best Entropy-reducer

James A. Woods  
Research Institute for Advanced Computer Science  
MS 230-5  
NASA Ames Research Center  
Moffett Field, CA 94131  
USA  

Karl F. Fox  
Morning Star Technologies, Inc.  
1760 Zollinger Road  
Columbus, OH 43221  
USA  

Paul Eggert  
Twin Sun Inc.  
360 N. Sepulveda Blvd. #2055  
El Segundo, CA 90245  
USA  


## Judges' comments:

The program, in its base form, implements two useful utilities:

	atob - ascii to binary conversion
	zcat - decompression filter

To test the official C entry, one might try:

	echo "Quartz glyph jocks vend, fix, BMW." | compress | btoa | jaw

which should apply the identity transformation to a minimal
holoalphabetic sentence.

Included with this entry is a shell script (with comments edited down
to reduce it to 1530 bytes) which implements the complete
shark utility.  The script, shark.sh, contains a 'jaw.c' embedded
within it!

The sender must have 'compress' and 'btoa'.  To send, try:

    sh shark.sh jaw.* > receive

The resulting file, 'receive', unpacks the input files
even if the receiver lacks 'uncompress' and 'atob':

	mkdir test
	cd test
	sh ../receive
	cmp ../jaw.c jaw.c
	cmp ../jaw.hint jaw.hint

## Selected notes from the authors:

###		     ABSTRACT
		   Minimal, Universal File Bundling
     (or, Functional Obfuscation in a Self-Decoding Unix Shell Archive)

			   James A. Woods
	       Universities Space Research Association
		      NASA Ames Research Center


		   "Use an algorithm, go to jail."
		[anon., circa 1988, pre-Morris worm era]


Myriad formats have been proposed for  network-mailable
data.  A major difficulty undermining the popularity of most
file/message bundlers  is  that  the  sender  assumes  prior
installation  of  the  computational  dual  of such bundling
software by the receiver.  Command shell archives  alleviate
this problem somewhat, but still require standardization for
the  function  of  data  compression  and  mail-transparency
encoding.  On Unix, these coding format quandaries are overcome
by planting a novel Trojan Horse in the archive  header
to perform negotiationless decoding.

Specifically, we outline the development of an extraordinarily
compact  portable  (un)bundler  to  (dis)assemble
data-compressed,  binary-to-ASCII-converted,   length-split,
and  checksummed  directory  structures  using standard Unix
tools.  Miniature versions of counterparts to  a  Lempel-Ziv
coder ('compress' or 'squeeze') and an efficient bit packetizer
('btoa') are compiled on-the-fly  at  mail  destination
sites  where  they may not already exist.  These are written
in purposefully obfuscated-C to  accompany  similarly-shrunk
shell command glue.  This resulting shell archiver is dubbed
'shark'.

'Shark' procedure overhead consumes as  few  as  three
dozen  shell  lines  (or ~1100 bytes), commensurate with the
size of many Internet mail headers; it  amortizes  favorably
with  message  size.   'Shark' is portable across Unix variants,
while the underlying technique is inherently  generalizable to other encoding schemes.

In   the   function-theoretic    sense    of    minimal
Chaitin/Kolmogorov complexity, and within a modified Shannon
model of communication, the 'shark' effort aims to construct
a  "shortest  program"  for  source  decoding in the Turing-universal Unix environment.

     ----------------------------------------------

       Oh, the shark has pretty teeth, dear--
       And he shows them pearly white
       Just a jackknife has Macheath, dear--
       And he keeps it out of sight.

			[Bertolt Brecht, Threepenny Opera]

     ----------------------------------------------

We have ported this program to a wide variety of systems.  Among
these are:

	SunOS 4.1 / Sun Sparcstation 1 (using both 'cc' and 'gcc 1.37.1')
	SunOS 4.0.3 / Sun 3
	BSD 4.3 / VAX 8650
	SEIUX / Sumitomo Electric Ustation/S
	Sony NEWS-OS 3.3 / Sony NEWS (fairly vanilla 4.3BSD)
	System V.? / Hitachi 2050
	System V.? / NEC EWS 4800
	UNIOS-B / Omron Luna
	Dynix / Sequent Balance ('cc' for Natl. Semi. base + 'gcc 1.36')
	Unicos / Cray 2

We (the authors) feel this program is obfuscated for the
following reasons:

     (0) This is one of the few programs you'll see WHOSE VERY UTILITY
	 DEPENDS ON ITS OBFUSCATION!

     (1) The contest entry may be used to send its wonderful self to
	 anyone in the Unix world!  Virus writers need not apply...

     (2) The basic idea is twisted enough to be patentable, but is,
	 out of the kindness of our hearts (as well as to maintain
	 eligibility for the large IOCCC prize fund), dedicated to
	 the public domain.  Claude Shannon, meet Alan Turing.

     (3) Meta-obfuscation is via obfuscated description (see ABSTRACT).

     (4) "Literary" allusion.  Production code contains a reference to
	 self-reference, preserved at amazing cost for sheer perversity.

     (5) Many, many micro obfuscations below, honed over three years
	 time, in shell as well as C.  Ask about the 'tar' pit escape,
	 the argv[0] flip, Paul's &4294967295 portability hack, the
	 "void where prohibited by flaw" fix, the scanf() spacesaver,
	 shift shenanigans, signal madness, exit()ing stage left, and
	 source-to-source transformations galore.

For extra credit:

Construct 'sharkmail', to auto-split sharkives into mailable
segments and mail them.  Here's a simple one, which could be
extended to enable auto-reassembly with one shell cmd at the
far end.

     ------------------------ cut here for sharkmail -----------------------
     #!/bin/sh
     m=$1; shift
     shark $* | split -800 - /tmp/shark$$
     n=`ls /tmp/shark$$* | wc -l | sed 's/  *//'`
     p=0
     for f in `ls /tmp/shark$$*`
     do
	 p=`expr $p + 1`
	 mail -s "bundle ($p of $n) from '`whoami`'" $m < $f
     done
     rm /tmp/shark$$*
     ------------------------ end of sharkmail -----------------------------


Shark history:

May 1987: Karl Fox introduces 1023-byte zcat.c to USENET.
	 It's too late for the 4th IOCCC.

May 21, 1987: James A. Woods extends idea to construct self
	 decompressing shar Trojan horse, utilizing 'cc', 'shar',
	 'zcat', & 'atob'; size: 2303 bytes.

May 23, 1987: 'jaw' trims 250 bytes without much thought.

June 2, 1987: 52 lines of shell, 1991 bytes, now made with 'tar',
	 short-circuit C-compile at far end, dual-use main.c,
	 portability mods. (jaw)

Mar-May 1988: abortive run at 5th IOCCC.
	 jaw.c - 1529 bytes.  compile line: 152 bytes.
	 generated funny code with execvp() to invoke shell.

Aug 29, 1988: production version, now at 1830 bytes.

Jan 1990: Paul Eggert does tour-de-force shark re-engineering.

May 24, 1990: collaboration yields 999-byte jaw.c core (see above)
	 and 1530-byte production shell code (w/comments).
	 Eggert comes through with lion's share of improvements.
	 7th IOCCC code now faster than the atob/zcat it replaces.

May 1990: 'jaw' develops experimental replacement using
	 Dan Bernstein's high-compression 'squeeze'.


To which we add:

June 1990: 'shark' wins the IOCCC, finally!  :-)

Copyright (c) 1990, Landon Curt Noll & Larry Bassel.
All Rights Reserved.  Permission for personal, educational or non-profit use is
granted provided this this copyright and notice are included in its entirety
and remains unaltered.  All other uses must receive prior permission in writing
from both Landon Curt Noll and Larry Bassel.
# Best Language Tool

Diomidis Spinellis  
Imperial College, University of London  
Myrsinis 1  
GR-145 62 Kifissia  
Greece  


## Judges' comments:

Compile and run.  Give the following lines as input:
    
	OLD LANDER.BAS
	RUN

Be sure not to run out of fuel!


## Selected notes from the author:

This is the DDS-BASIC Interpreter (Version 1.00). 

Immediate commands:

	RUN	LIST	NEW	OLD filename  
	BYE	SAVE filename

Program commands:

	variable names a to z		variables initialized to 0 on RUN
	FOR var = exp TO exp		NEXT variable
	GOSUB exp			RETURN
	GOTO exp			IF exp THEN exp
	INPUT variable			PRINT string
	PRINT exp			var = exp
	REM any text			END

Expressions (ranked by precedence):

	Bracketed expressions
	number (leading 0 for octal, 0x for hex, else decimal), variable
	Unary -
	* / 
	+ - 
	= <> 
	> < 
	<= >=
	(* and + are also used for boolean AND and boolean OR)
	Boolean expressions evaluate to 0 for false and 1 for true

Editing:

* Line editor using line re-entry.
* A line number with nothing following it, deletes the line.

Input format:

* Free format positioning of tokens on the line.
* No space is allowed before the line number.
* Exactly one space is needed between the OLD or SAVE command and 
	  the filename.
* ALL INPUT MUST BE UPPERCASE.

Limits:

|             |                                              |
|-------------|----------------------------------------------|
|Line numbers | 1-10000                                      |
|Line length  | 999 characters                               |
|FOR nesting  | 26                                           |
|GOSUB        | 999 levels                                   |
|Program      | Dynamically allocated                        |
|Expressions  | -32768 - 32767 for 16 bit machines,          |
|             | -2147483648 - 2147483647 for 32 bit machines |

Error checking / error reports:

No error checking is performed.
The message 'core dumped' signifies a syntax or semantic error.

Hosting Environment:

	ANSI C, traditional K&R C or OSF ANDF
	ASCII or EBCIDIC character set
	48K bytes memory

The Speed of DDS-BASIC Interpreter (Version 1.00). relative to
Microsoft Advanced BASIC 3.31 is Approximately 60%.

The code size could be further reduced by doing ugly things like
not declaring the return type of functions, not freeing memory,
 #defining define, and joining lines.  In its present 1536 character
form the program is reasonably portable (it may fail to run in a
tagged object architecture) and nicely formatted (it fits in an
80*25 screen).

Copyright (c) 1990, Landon Curt Noll & Larry Bassel.
All Rights Reserved.  Permission for personal, educational or non-profit use is
granted provided this this copyright and notice are included in its entirety
and remains unaltered.  All other uses must receive prior permission in writing
from both Landon Curt Noll and Larry Bassel.
# Best Utility

Byron Rakitzis	       
Princeton University   
5707 Old Lodge Dr.     
Houston, TX 77066      
USA		       

Sean Dorward  
Princeton University  
10274 Burleigh Cottage Lane  
Ellicott City, MD 21043  
USA  

## Judges' comments:

This program implements a subject a well known Un*x utility whose 
original source was considered to be extremely obfuscated by many
people, excluding its author.  In fact, this utility one a major
inspiration for the formation of this contest.

The author supplied us with a slightly smaller unformatted version
of the program which we include below:

    #define D ,close(
    char*c,q[512],m[256],*v[99],**u,*i[3];int f[2],p;main(){for(m[m[60]=m[62]=
    32]=m[*m=124[m]=9]=6;e(-8),gets(1+(c=q))||exit(0);r(0,0))for(;*++c;);}
    r(t,o){*i=i[2]=0;for(u=v+98;m[*--c]^9;m[*c]&32?i[*c&2]=
    *u,u-v^98&&++u:3)if(!m[*c]){for(*++c=0;!m[*--c];);*--u=
    ++c;}u-v^98?strcmp(*u,"cd")?*c?pipe(f),o=f[1]:1,(p=fork())?e(p),o?
    r(o,0)D o)D*f):4,wait(0):(o?dup2(*f,0)D*f)D o):*i?1 D
    0),e(open(*i,0)):5,t?dup2(t,1)D t):i[2]?9 D
    1),e(creat(i[2],438)):2,e(execvp(*u,u))):e(chdir(u[1])*2):6;}
    e(x){x<0?write(2,"?\n$ "-x/4,2),x+1||exit(1):5;}
    
Selected notes from the author: (rot13 to read)

    Guvf cebtenz vf n ehqvzragnel furyy. Vg qbrf v/b erqverpgvba, cvcrf
    naq pq. Vg syntf reebef ba snvyrq puqve'f, bcra'f, perng'f
    rkrpic'f, sbex'f naq n srj flagnk reebef.

    Guvf cebtenz vf boshfpngrq va n srj abgnoyr jnlf: ncneg sebz gur
    ynlbhg (na hasbeznggrq (ohg pehapurq) irefvba vf vapyhqrq sbe
    crbcyr jub jnag gb chg guvf guebhtu po) vg znxrf pyrire hfr bs n
    jevgr fgngrzrag, fb gung gur fnzr fgngrzrag pna or hfrq gb cevag
    reebef naq gur cebzcg. Ol pnyyvat gur reebe shapgvba jvgu gur inyhr
    -8, gur cbvagre bssfrg va gur rkcerffvba "?\a$ "-k/4 tbrf sebz 0 gb
    2.  Cerfgb!  N cebzcg. Sbe reebef jvgu ahzoref fznyyre guna -4
    (v.r., HAVK flfgrz pnyyf) n dhrfgvba znex vf cevagrq.

    Gur reebe inyhr bs puqve vf qbhoyrq fb gung jr qba'g rkvg sebz gur
    cnerag furyy ba n puqve reebe (fvapr r() rkvgf ba -1 reebef bayl).
    Nyy bgure flfgrz pnyy snvyherf rkvg fvapr gurl ner sebz fhofuryyf.

    Erphefvba vf farnxvyl rzcyblrq gb nibvq n frpbaq pnyy gb sbex(),
    naq gur yvar vf cnefrq va n snveyl ovmneer snfuvba:  onpxjneqf. Gur
    urneg bs gur cebtenz, gung vf, gur cneg juvpu cresbezf nyy sbexf,
    rkrpf, bcraf, rgp. vf BAR P FGNGRZRAG.

    Gur zrgn-inyhrf neenl vf vavgvnyvmrq va n ovmneer snfuvba, naq gur
    fhofrdhrag purpxf sbe gur '<' naq '>' ner cresbezrq va n fvatyr
    fgngrzrag hfvat n znfx, fvapr lbh xabj gung '>'&2 vf 0, jurernf
    '<'&2 vf 2. Bgure fhpu zvpeb-boshfpngvbaf nobhaq.

    Svanyyl, vg vf abgnoyr gung gur pbqr jnf unpxrq sbe zvavznyvgl. Vs
    lbh ybbx ng gur pbzcerffrq irefvba, lbh jvyy or uneq-cerffrq gb
    ryvzvangr zber guna n srj punenpgref (jr pna'g frr ubj gb znxr vg
    nal fznyyre!).  550 punenpgref vf cerggl yrna sbe n furyy gung qbrf
    guvf zhpu.

    OHTF

    Gur flagnk bs gur furyy unf abg orra shyyl rkcyberq, ohg vs lbh gel
    gb erqverpg va gur fnzr qverpgvba zber guna bapr, bayl bar
    erqverpgvba vf cresbezrq. Guvf vf n "srngher" bs gur jnl gur yvar
    vf cnefrq; n cbvagre gb gur fgnpx bs nethzragf vf nffvtarq naq na
    nethzrag vf fgbyra rirel gvzr n ">" be "<" vf rapbhagrerq.  Gur
    furyy syntf na reebe vs ab nethzragf ner ba gur fgnpx. Guhf, sbe
    rknzcyr:
		png > sbb > one
    pngf gb sbb, fvapr vg jnf chfurq ynfg, ohg
		png > > sbb one
    pngf gb one, fvapr one jnf chfurq haqre sbb. (erzrzore jr'er
    cnefvat evtug-yrsg)

    Qrcraqvat ba lbhe synibe bs HA*K, pq jvgubhg na nethzrag jvyy
    rvgure cebqhpr na reebe be whfg qb abguvat.

    Gurer vf whfg bar reebe zrffntr, gur dhrfgvba znex, ohg url, gung'f
    nyy rq qbrf gbb.

Copyright (c) 1990, Landon Curt Noll & Larry Bassel.
All Rights Reserved.  Permission for personal, educational or non-profit use is
granted provided this this copyright and notice are included in its entirety
and remains unaltered.  All other uses must receive prior permission in writing
from both Landon Curt Noll and Larry Bassel.
# Most beauteous visuals

Vincent Weaver
Ithaca, NY
USA
vince@deater.net
<http://www.deater.net/weave/>

## Judges' comments

This beauteous entry makes use of visual {}'s and whitespace to instruct
the OpenGL development libraries to create beauteous visuals.  Even
hitting the space bar while the program runs produces a "spacey" effect! :-)

Challenge: Try modifying the texture to something of your own design.

## Improved Version

This following improved version of the submission will run on SGI Irix and
also has the recursive CPP macro (which snuck in accidentally) removed.

### To build

Before building, make sure that you have the OpenGL development libraries
installed.

        cc -Wall -O2 -o vince vince.c -L/usr/X11R6/lib -lGL -lGLU -lX11

If you are on a 64 bit platform you might need to substitute `-L/usr/X11R6/lib64`.

### To run

        vince

Under MacOSX run from within an xterm while the X11 server is running.

## Author's comments

### ABUSE OF RULES

  * The executable needs to read in its own source code in order to run. As
long as the source is in the same directory as the executable it should be
able to find it...

  * The program requires the OpenGL library.

  * The program abuses severely the whitespace and { } ; exceptions in the
filesize limits.

### Requirements

  * OpenGL. It works (slowly) with Mesa.

  * 16bpp graphics capability (but might work at other depths)

  * The original source needs to be in the same directory as the executable,
and the source's name should be the same as the executable but with .c on the
end.

### Background

I was annoyed after the last IOCCC because I slaved away on a clever text
based game only to find all of the game winners used X11. X11 isn't standard
C!

So to one up them, I decided to use OpenGL. It's standard, and most Unix-like
systems these days have either accelerated graphics or else software
rendering.

### Obfuscation

It was a challenge getting the source code below the 2k limit. OpenGL has way
too many GRATUITOUSLY_LONG_CONSTANTS and glLongStudlyFunctionNames();

Therefore, much of the obfuscation comes secondary to just reducing the code
size to fit under the limit while still having some semblance of a demo.

There are some interesting abuses scattered about.

### Usage

Try hitting the spacebar when the program is running.

### For Fun

Try modifying the texture to your own custom design...

### Thanks

Many thanks to John Clemens for testing this on various machines for me.

### Errors you can get

        0 = no error
        1 = X problem
        2 = Can't open glx
        3 = Can't open 16bpp visual
        4 = can't open source file
# Most circuitous walk

Daniel Vik
926 Genter Street
La Jolla Ca 92037
USA
daniel@vik.cc

## Judges' comments

An amazing use of the X libraries with twisty code passages,
all different.  One risks running in code path circles as main is
called again and again.  be sure to pay attention to commas!  :-)

### To build

        cc -O3 -ansi vik.c -L/usr/X11R6/lib -lX11 -lm -o vik

### To run

        vik
        vik maze.map

## Author's comments

This entry is a Wolfenstein style graphics engine where a user can navigate in
a 3D world. The maze has walls with bitmap textures. The application contains
a default world with textures, but the power of the engine is exposed through
user configured maps. User defined worlds support up to 26 different wall
textures that can even be animated. One example of a user defined world is
submitted with the entry.

### Features

This program is a complete 3D engine with

  * Easy configurable maze maps
  * Up to 26 differnt bitmap textures in a maze
  * Support for animated bitmap textures
  * Uses default bitmaps in case the configured bitmaps can't be found
  * A default map in case no one is specified
  * Configurable window size
  * Navigation using cursor keys (rotate left and right, move forward and
backward)

### Build and Run

Compile the source code and link x libraries if nessecary. The program takes
three options which have to be typed in a specific order as described below.

        Usage: prog [-w <width>] [mapfile]
        width   - Specifies the width of the window
        mapfile - Filename containing a map

Here are a few examples:

> | Command line:            | Description:           |
> | ------------------------ | ---------------------- |
> | $ ./prog                 | Starts the engine using a built in labyrinth and texture bitmaps |
> | $ ./prog maze.map        | Starts the engine and loads the labyrinth defined in the file maze.map |
> | $ ./prog -w 400 maze.map | Starts the engine using maze.map in a window that is 400 pixels wide |

Note that the mapfile has to be the last argument and the -w option if present
has to be the first. The map definition files and the bitmap files should be
located in the current directory.

Use the cursor keys to navigate through the labyrinth.

### Creating mazes

A maze consist of a map file and texture bitmap files. The map file is an
ascii text file where lower case letters represent walls. The letter tells the
engine what bitmap texture file to use. The '*' character lets the engine know
where to position the user. The example below shows how a map file can look:

       aaaaaaaaaaaaa
       a           a
       a      *    a
       a    bbbb   cccccccc
       c                  c
       cccccccccccccccccccc

The engine loads the map, and creates walls. When a character 'a'-'z' is found,
the engine will load the corresponding texture bitmap. The bitmap file must be
named `*.bmp` where `*` is substituted with the letter of the wall in the map.

So to load the map above, the files `a.bmp`, `b.bmp`, and `c.bmp` should be
located in the same directory as the engine executable (or rather in the
current directory).

### Obfuscation

The program is obfuscated in several ways, bad use of variables, use of the ?
operator, recursive calls to main, bad use of for variables and the comma
operator. To make the final obfuscated touch I ran indent which really made
the program unreadable (I guess that is not really the intent with indent ;)

### Compiler warnings

There are no compiler warnings when compiling with -ansi but there are quite
many warnings from lclint. Mainly because the program is very optimized for
code size.

### Limitations

The program only compiles and runs on X based systems.

The program does not run that smooth under cygwin. It seems to be a priority
issue with cygwin and it can easily be solved by increasing the priority of
the application a little bit.
# Best use of the www

Anthony Howe
Snert
42 av. Isola Bella
06400 Cannes,
France
achowe@snert.com

## Judges' comments

This little mynx will give any Fiery Fox a run for its money. A nice complement
to last years winning hibachi. The judges double dare any eager
Obfuscationalists to submit the missing pieces to get a functioning LAMP stack.

### To build

        cc -O2 -o mynx mynx.c

If this does not work for you, use the enclosed configure script.

### Try

        mynx http://www.ioccc.org/

## Author's comments

I was rather impressed by last year's mini web server. So much so that
it inspired me to try my hand at writing the client side complement.

A typical build would be command would be:

        $ gcc -omynx mynx.c

While some others like to be a little different:

        $ gcc -omynx mynx.c -lnsl -lsocket

I even managed to figure out a basic configure script, given last year's
example, which is kinda of useful when you consider how many OSes put
all the network functions in a variety of places. So a simpler build
command sequence would be:

        $ ./configure
        $ make

After which, the rest of the documentation can be read by saying:

        $ mynx manual.html

Manifest:

        mynx.c
        makefile                pre-built generic Un*x
        README.TXT
        manual.html
        makefile.in             makefile template
        entities.txt            ISO 8859-1 entites
        configure.in            configure script description
        configure               pre-built configure script
# Best 3D puzzle

        Anonymous

## Judges' comments

Taking the 4x4 board with 15 tiles to a whole new level, this entry
takes this puzzle to a whole new dimension!  While you puzzle out
this puzzle, we invite you to take a good LONG look how and WHY
main is recursively called and how the run-time stack is used.

## To build

        cc -o anon anon.c

Or, if the above does not work

        cc -DNO_STTY -o anon anon.c

## To run

        anon 4 4
        anon 3 3 3

## Author's comments

### ABOUT THE GAME ITSELF

Remember Sam Loyd's Fifteen Puzzle? It consists of a 4x4 board with 15 tiles
numbered 1 to 15, and an empty spot. The goal of the game is to slide the
tiles around without lifting them off the board, so that they become sorted.

Well, that was then. This program is the 21st century version of the Fifteen
Puzzle: not only does it allow arbitrary board sizes, it also supports _3D_
boards! The tiles are numbered from 1 to N, where N is one less the number of
spaces on the board, and the goal is to rearrange them so that they appear
sorted in the order they appear on the screen.

The program takes 2 or 3 arguments, specifying the dimensions of the board.
For example, to play the original version of the Fifteen Puzzle:

        anon 4 4

To play in a 3D board, do something like this:

        anon 3 3 3

**[WARNING: do NOT run the program with more than 3 command-line arguments.
This will trigger a bug that will cause it to crash or do something strange.
:-)]**

Also, resist the temptation to create very large puzzles. The program does not
attempt to resize your terminal for you, and will produce confusing output. It
may also crash on you if you insist on running it with excessively large board
dimensions. :-) (10x10x10 is considered a safe upper limit.)

The empty space on the board is represented by a space filled with '#'
characters instead of digits. To slide the tiles around, use the following
keys:

        i | Slide the tile above the current empty space downwards.
        j | Slide the tile to the left of the current empty space to the right.
        k | Slide the tile below the current empty space upwards.
        l | Slide the tile to the right of the current empty space to the left.
        o | Slide the tile behind the current empty space forwards.
        n | Slide the tile in front of the current empty space backwards.

To quit the game:

        q | Quit the game.

Note that, for example, sliding the tile above the current empty spot
downwards will fill up the empty spot, and create a new empty spot above where
the current empty spot was. Hence, you could think of the movement keys in
terms of how they effectively "move" the empty spot:

        i | Move empty spot up
        j | Move empty spot left
        k | Move empty spot down
        l | Move empty spot right
        n | Move empty spot forwards
        o | Move empty spot backwards

**NOTE:** as a measure of alleviating counter-productivity due to addiction to
this game, particularly for those hardcore gamers who insist on solving a 
10x10x10 puzzle during work hours, and also to give an upper bound to user
frustration when the program generates an impossible puzzle (which it does
roughly half the time, just to hook you), the program will, after a very large
number of moves (which is system-specific) terminate itself by forcefully
destroying its own runtime stack. This will result in a core dump and/or an
abnormal termination message; but this is a feature, not a bug! :-)

### COMPILE NOTES

This program complies with ANSI/C99. It uses ANSI terminal control sequences,
and so requires a terminal that understands ANSI sequences, such as vt100 or
xterm.

Some compilers may emit lots of warnings about how things ought to be
parenthesized (e.g. `gcc -Wall`). This is deliberate, since if everything were
parenthesized "properly" the program would fail to work. It (ab)uses C
operator precedence to accomplish some cool hacks. :-) However, there are no
compiler errors. I have tested this with `gcc -pedantic -std=c99`.

The program also uses `stty cbreak`. If this breaks on your system, compile it
with -DNO_STTY. The game interface will be a bit annoying (you will need to
hit enter after every key), but it works.

The game requires lots of space on the runtime stack space due to deep
recursion, among other things. :-)

See spoilers below for more notes about portability.

### ABOUT THE CODE

Clearly, the author is very, very confused. Although he has broken up the file
into sections labelled with helpful headings, and although he has left ample
whitespace between all those #define's to make them easier to read, :-) and
although he has helpfully formatted the code with beautiful indentation,
something is clearly very, very wrong.

In fact, the closer you look at this code, the more you realize something is
horribly wrong with it. For example, why is it that the first statement in
main() is a return? What do all those nested do-loops do? (pun intended) Why
is the first statement inside the first do-loop a mere integer literal? Why
are there such strange statements, like that empty string on line 64, or that
isolated || on line 67?

But wait... why aren't any statements terminated by semicolons? Why is there
only ONE semicolon in the entire program?! Why is the author opening nested
blocks by such strange things as || and (, and closing them by || and ))? The
for-loop isn't a for-loop! The do-loop isn't a do-loop! Or... are they? Well,
the for-loop is defined in terms of a while-loop. But wait, the while loop is
defined in terms of the do-loop. And the do-loop is defined in terms of ...
Huh???

And that switch statement toward the end of the program... wait a minute, that's
not a switch statement! Why is a case defined in terms of a switch statement?!
And that initial return isn't a return! Well, it is... but not what you might
think!

Let's see if it all makes sense after we run it through CPP...

Uh oh. The result looks like the diseased imagination of a mind more confused
than the one who wrote the original code. Unfortunately, unless you're a Lisp
expert, it is probably easier to understand the program in its original form.
(And even then.) But that's just so, so wrong...

The entire program consists of a single expression, returned from main().
There are no if-statements, no for-loops or any looping or control constructs
besides the 'return', in spite of the misleading appearance of the original
source. :) Yes I know, this has been attempted before, using ?: and the bad
old comma operator. BUT this program does NOT use the ?: operator, and there
are only TWO comma operators in the entire program--and they are only there
because srand() and exit() return void.

The entire program consists of a single boolean expression returned from
main(). Looping is achieved by recursion, of course, and branching is achieved
by exploiting short-circuit evaluation of boolean expressions. `:-)`

But this is not all.

It is comprehensible that the program can achieve branching and looping using
only boolean expressions and recursion. But HOW does the program STORE DATA???
There are no variables of any kind in the program except for the two arguments
to `main()`. There are certainly no arrays declared anywhere. The program does
not call any memory allocation routines, nor any function that indirectly
returns allocated memory. Yet it happily looks up array references without
crashing. How??

One might be tempted to think that this program would be highly non-portable
because of such insane hacks. However, it has been tested and proven to work
on the following architectures:

  * i386/linux
  * sparc/solaris
  * parisc64/linux
  * arm/linux
  * s390/linux
  * mips/linux
  * m68k/linux
  * ia64/linux
  * sparc64/linux

It probably will also compile and work on many (all?) other *nix platforms as
well. How does it achieve this incredible feat?

### SPOILER

.

.

.

.

.

.

.

.

.

.

.

(Read the following only if you give up figuring it out `:-)`)

.

.

.

.

.

.

.

.

.

#### The Evil Hack

The program (ab)uses an implicit assumption underlying practically all
architectures, and that is that parameters to C functions are implicit local
variables allocated on the runtime stack. This runtime stack is a contiguous
section of memory, and therefore, after N recursive calls of main() to itself,
there is enough room on the stack to store whatever the program desires, so
long as it does not exceed the maximum stack size.

(Theoretically, the runtime stack doesn't **have** to be contiguous but all
current architectures that are worth consideration make this assumption. I
submit that this implies this program is 100% portable, even though
theoretically it shouldn't even work in the first place.) `:-)`

There are two types of architectures the program must handle: those that
allocate the stack top-down, and those that allocate the stack bottom-up. The
program correctly detects this at run-time, and adjusts itself accordingly.
:-) (It is a simple matter of testing if the address of argc in a recursive
call is greater or less than in the parent call.)

To avoid having to handle issues of int sizes, memory alignment, what exactly
is on the stack between successive locations of argc, etc., the program
(ab)uses the fact that argc must necessarily be allocated on an aligned
address, and therefore, the range of memory between two argc's is aligned, and
therefore safe to use as an array of longs.[*] The program also compares the
pointers as (long*) pointers, so that it will not have to deal with mapping
bytes to larger types. The initial memory allocation is done by recursively
calling main() until there is enough space on the stack (the exact number of
recursive calls is, of course, architecture-dependent).

[*] long was chosen instead of int, in order to skirt around pointer-size
issues on architectures like ia64. It really can be made anything large enough
to hold both ints and pointers. `:-)`

After the stack is deemed to have grown deep enough to be a sufficiently long
array (pun intended), the program begins its real code. It uses argc to keep
track of what it's supposed to be doing (since main() is the only function),
and argv to point to the base of this array (which is computed differently
based on how the architecture allocates the stack). Since this fills up the
only two variables in the program, everything else is stored in the MASS [**]
array.

[**] for "Memory Allocated by Stack Smashing" `:-)`

Note that from this point on, all bets are off as to what the contents of the
runtime stack are below the current recursive call to main(). We are
overwriting frame pointers, return addresses, etc., with data. Hence, the
program must never return from this call, otherwise it will crash horribly.
That's why I had to call exit() even though it meant I can no longer claim the
program doesn't need the comma operator. :-) (I was going to skirt around the
issue by indirectly calling exit(), such as via bsearch() or raise(), but I
was getting too close to the size limit.)

#### Some notes about the macros

In spite of the frightening appearance, it is probably easiest to understand
the code in its original form. (Don't even try running 'indent' on it: on my
system it chokes and complains about nesting errors.)

Most of the #define's are just to keep the code size down, due to the abusive
amounts of type casting employed. The others define a bizarre "programming
language" (in the crudest, most twisted sense of the word) that the author
used to write this mess.

R(i) and W(i,j) are macros to read/write the i'th position of the MASS.

A(i) retrieves the i'th command-line argument. This is slightly tricky,
because by the time the MASS is setup, we no longer have access to the
original values of argc and argv. So what is done is that the initial memory
allocation code will save argc and argv into positions 8 and 9 in the MASS
after the allocation. It does this by using argv, which at that time contains
a pointer to the top-level argc, to compute the location of the top-level
argv. This is done before the rest of the MASS is used, since otherwise they
may be overwritten.

do(x,y) has nothing to do with do-loops. `:-)` It defines a "state" in main(),
essentially, what to do when main() is called with argc containing a
particular value. (This is why the user must never run the program with more
than 3 arguments. :-) The state number is x, and y is the code. The program's
boolean expression consists of a number of states &&'d together. Within each
state, it is assumed that statements are separated by ||. All statements are
assumed to evaluate to false. This makes it easy to write conditional
statements: "if (a) { b } ..." can simply be written "a && b || ...". All
states created by do(x,y) are assumed to evaluate to false. There is only 1
state which can return true or false: state 5, a "manually-implemented" state
which determines whether the system uses top-down or bottom-up stack
allocation. It's the only state that needs to return a value from the boolean
expression, since once the MASS is initialized any return value can simply be
stored in a well-known location in the MASS.

if(p,q,r,s) is, in fact, an if-statement. `:-)` It is equivalent to:

        if (p) { q; r } else {s}

Why are q and r split up? Because it's cleaner (in whatever twisted sense of
the word that can be applied to an IOCCC entry) to implement using boolean
expressions. Keep in mind that all statements are assumed to evaluate to
false. The proof that this macro in fact implements an if-then-else construct
is left as an exercise for the reader.

while(x,y,z) is actually a while-loop after all. `:-)` It implements the loop
using, of course, recursive calls to main(). However, this macro doesn't
actually run a while loop; it implements the loop in the state numbered x. It
is used for defining a while loop, which can then be called from another state
using f(x). (The reason we can't directly implement a while-loop inside
another state ought to be clear: we can't recursively call main() to enter
into the middle of a state.)

However, it _is_ possible to implement a for-loop directly inside a state! The
for(s,i,x,y,z,Z) macro does exactly this. Well, actually, technically speaking
this macro can only be used as the last thing in a state, because it secretly
closes the current state and opens a new one behind the programmer's back.
:-) Its intended usage is this: s is the state number for the loop body, and i
is the index variable (well, the index into the MASS of the index variable); x
and y-1 define the starting and ending values of i, and z is the loop body. Z
is the post-loop code in the current state. For example:

        for(s,i, 0, 10,
        some_code       ,
        other_code)

is equivalent to:

        for (i=0; i&lt;10; i++) {
                some_code;
        }
        other_code;

Note the "wrong" indentation in the former: the author prefers to write it
that way, since the analogy to the usual for-loop is clearer. This is why it's
easier to understand the pre-CPP code, since after CPP, the macro reshuffles
some_code after other_code so that it can close the current state and define
the one containing the loop body. (Have I told you that the author of this
program is horribly, horribly, confused? :-) This confusion also shows up in
the superficial appearance of the program, which heavily suffers from wrong
indentation.)

In spite of all appearances, switch() really is just a shorthand macro for
reducing code size. The evil choice of macro name is just to instill more
confusion into the would-be decipherer of this entry. :-) After all, case()
really _is_ the equivalent of a case statement, implemented using &&, and
conveniently encapsulating code common to the cases in the only switch-
statement in the program, which is the code that decides what to do with a
keypress. What could be more fun than to define such a case in terms of a
switch? :-)

Finally, for those who give up deciphering this horribly confused code, here
are the mappings of various locations of the MASS to their usage in the
program, and what the various state numbers are meant to do:

#### MASS usage map

        0  | Function return value
        1  | Function argument 1 
        2  | Function argument 2 
        3  | Function argument 3 
        4  | Scratch register 1 
        5  | Scratch register 2 
        6  | Scratch register 3 
        7  | Scratch register 4 
        8  | Value of original argv :-) 
        9  | Value of original argc :-) 
        11 | Zero register (always set to 0) 
        12 | Width of board 
        13 | Length of board 
        14 | Height of board 
        15 | Current position of hole 
        16 | Random seed for rand_r() 
        18 | Scratch register used by state 18 :-) 
        31 | field width for printing tiles 
        32 | Start of board data 

(**CAVEAT:** not all of these mappings ended up in the final version of the
program, mainly due to size limitations which entailed the trimming off of a
lot of neat features in the game. It is left as an exercise for the reader to
figure out which of these are actually used.)

Note that argv and argc necessarily needs to stay away from lower indices of
the MASS, because otherwise they may overwrite their original values when the
memory allocation code saves them. Index 8 is deemed "safe enough". (It seems
to be on all tested architectures.)

#### State number assignments

        1  | showhelp 
        2  | showhelp 
        3  | is 2D: start init 
        4  | is 3D: start init 
        5  | find allocation type 
        6  | MASS init, bottom-up 
        7  | MASS init, top-down 
        8  | main program 
        9  | generate() outer loop 
        13 | render() 
        14 | render() loop 
        15 | exit(0) 
        16 | pick a tile that hasn't occurred yet 
        17 | inner loop of 16.  
        18 | main loop 
        19 | checkwin() loop 

Note that some of the manually-implemented states (those not implemented by
do()) respond to multiple state numbers. Also note that states 1-4
conveniently correspond to what the program should do when 1-4 arguments are
given at the command-line. :-)

The original intention was to include a parity-checking routine in the game so
that it will always generate a solvable game. However, size limits
necessitated the removal of this code. And besides, the game is more addictive
when it's sometimes unsolvable. Especially when it taunts the user with a
smiley. :-)


# Best game

Oscar Toledo G.
Familia Toledo
Av. Santa Cruz del Monte 9-304
Ciudad Satelite Edo de Mexico
CP 53110
Mexico
uno@biyubi.com

## Judges' comments

Challenge yourself with your ability to look 5, 6 or more moves ahead.
Challenge your knowledge of C operator precedence.  The following the
move analysis via recursion while it executes moves.  All while playing
by the rules of C and Chess within a single function!

## Improved version

Better mate searching

### To build

        cc toledo.c -o toledo

### To run

For two human players

        toledo

To play against the program

        toledo a

## Author's comments

### What does this program

This is a chess program, it can work in two modes: two-players, and one player
(always white) against the machine. To get the first mode, run the program
without arguments:

        prog

The other mode is accesible running the program with one argument (5-ply
analysis):

        prog a

Two arguments for 6-ply analysis:

        prog a b

And each succesive argument will analyze one ply more. There is no ply limit,
but beyond 7 ply is very slow, try it at your own risk and computing time.

### Entering movements

When is your turn, you can enter your move, by example, as "d2d4" (without the
quotes) and press the Enter key, the computer will check move legality and
will warn you of illegal moves. All legal chess moves are permitted.

One special case is when you are doing promotion, you must enter the move with
an extra letter indicating the desired piece.

By example "f7f8n" (supossing you have a pawn on f7), will promote it to a
knight, substitute 'n' for the desired piece (N/Q/R/B).

Note that the program requires the piece letter, it will not select
automatically a queen, so don't be surprised if it doesn't accept your move.

### Game status

The computer will check for checkmate and stalemate, also after each machine
move, it will show the score of the position, an higher number is better for
the computer, i.e. worst for you.

### Quirks

None.

### Program operation

This is a good example of a chess program reduced to the essential. In order
to get it into the contest limits, I used short but slow and unintelligible
algorithms.

The interface accounts for only a fraction of the code, the core does
multiples functions, it is called recursively to analyze and evaluate each
ply, does alpha-beta cutting, move generation, machine playing, check
detection, illegal move verification and does moves after they are verified.

Also sets an standard on ultra-mini-chess programs, the player and the
computer can do all legal chess moves, other features are:

  * Illegal move verification.
  * Checkmate detection.
  * Stalemate detection.
  * Computer is tough (check 7-ply), even in 5 ply can give a surprise to
amateur players.

### Obsfucation tricks

  * Only one C function, really modular.
  * Extensive use of the trinary and comma operators, save a hard drive today.
  * Extensive use of C operator precedence, all good C programmers remember
it... I cannot.
  * Exchanged operands every place is possible, someday someone will
understand it,
  * Mixed and multifunction expressions on statements, in good old-BASIC
style.
  * Macros used to hide C syntax, check unballanced parenthesis and calls with
empty arguments!
  * Only includes strictly necessary standard headers, the linker takes care,
and compiles faster... but I'm still not seeing the difference.
  * Uses only one string, very easy to I18N ;)
# Abuse of the rules

Peter Klausler
Cray Inc.
2802 W 40th St
Minneapolis MN 55410
USA
pmk@cray.com

## Judges' comments

To reduce the size of the source, include other people's data.
That is what Peter suggests when he describes how to generate
a critical header file.

In other words: make use of other words!  :-)

Rules might have to be changed!

### To build

      #!/bin/sh
      dict=""
      for f in mydict /usr/share/dict/words /usr/dict/words /usr/lib/dict/words
      do if [ -r $f ]; then dict="$dict $f"; fi; done

      if [ ".$dict" = . ]; then echo no dictionary found; exit 1; fi

      cat $dict | \ 
         tr -cd 'A-Za-z\n' | \ 
         tr A-Z a-z | \ 
         egrep -v '^[^ais]$' | \ 
         sort | \ 
         uniq | \ 
         sed 's/^/"/;s/$/",/' >dict.h

      cc -o klausler klausler.c

### To run

           klausler peter klausler | head

## Author's comments

A useful tool to help one appear extra smart and witty when IRCing, or even
just highly annoying.

Finds best anagrams for word or phrase given as program arguments. Use only
lower-case letters in these arguments. Output is sorted firstly in ascending
order of word count (fewer words are better) and secondly in descending order
of word length. Pipe the output into more(1)/less(1)/head(1) and you're likely
to find the most amusing possibilities in the first few screenfuls of output.
For example, "ana fawlty towers | more" quickly prints "waterfowl sty". The
fewer obscure short words in your system's dictionary, the better the quality
of the output; indeed, all one-letter words apart from "a", "i", and "s" (for
plurals) are ignored when the dictionary is constructed by build.sh.

Some history and explanation: When I noticed the call for entries in this
year's IOCCC, I submitted two of them. I worked on the first one very hard to
obfuscate it beautifully, using a goofy algorithm, wonderful two's-complement
arithmetic tricks, and cute formatting. It was a glorious work so lovely as to
make even strong men weep in admiration... but it didn't win anything. On the
other hand, this crappy little other program, which was only mildly obfuscated
from its original hacked form, took home an award!

I'm embarrassed to admit that I don't even know which specific rule this entry
has abused. It's just yet another anagram generator and it was written very
late one night. And now I honestly do not know how it works, so please don't
ask. Upon reviewing the program after its unexpected honor, I guess that it's
remarkable only for its complete lack of macros, sneaky naming, main()
recursion, or other tricks. Enjoy!
# Best 2D puzzle

        Gil Dogon
        1 HaBeer Alley
        Jerusalem
        Israel
        gil_jade@netvision.net.il

## Judges' comments

This entry takes editorial in how it deals with its output.  After using
vi to look at the source, use vi to look at its output.   We especially
recommend it on a 78 column xterm while leaning on Control-F.

Do you really understand expressions, then understand this:

      s=s^(b=s&s-1^s)

... and understand why it is found in the source code.

### To build

      cc giljade.c -o giljade

### To run

      giljade > out

Open an xterm with 78 lines

      vi out

Press ^F repeatedly

## Author's comments

### So what do we have here ?

Just run the executable with no command line args and look at the output. In
order to properly enjoy it you will need two good old programs: xterm and vi.
Do the following: open an xterm with precisely 78 lines, and use the tiny font
size for best results. Then vi (vim will also do) the output. Type ^F's and
enjoy the show ...

The program solves (very very fast) a sliding block puzzle. There are many
variants of such puzzles which are usually made from wood or plastic pieces.
The start position can be recognized by looking at the program itself. The
goal is to move the big piece (2 by 2) to the center top, which takes 179
steps in the shortest move sequence.

Notice: the step count used by the program is longer than the traditional step
count for such puzzles, as normally if the same piece is moved twice in a row
it is counted as only one step, but here it is counted as two.

The printout of the solution however is in a rather unorthodox form, as can be
easily discerned. As you have probably suspected each of the steps in the
solution printout is a C program which compiles to result in - surprise
surprise! - the original (well almost).

Actually, This program is smarter than merely printing ITSELF in 180 different
layouts. It is self-improving, in that the programs it prints have three
advantages over the original:

1. Their layout is more precise (Notice the annoying \ at the 10'th line of
the original program which is actually a 'layout bug'

2. Their binary output does not rely on the source file being in the same
directory, and will not dump core like the original if it doesn't.  :)

3. They have much more comments (Not very helpful ones though).

In addition as we all know bugs can creep on us in the most unexpected of
places, and checking that indeed the output is composed of 180 legal C
programs by hand can be quite tedious, hence the program also include a self-
test mode. Just run it with the output file as command line argument. It will
then try to compile each of the programs (printing the line number where the
program starts) It will stop where any compilation fails and the culprit
program would be in the file 'c.c'. The exit code of the self-test will be
non-zero in that case. In case this entry wins, I do hope nobody by the name
of 'c' also wins this year otherwise that part of the program would have to be
changed!

Notice that the self-test does not try to run the result of the compilations
but this can easily be done. try it and diff the output of any of the 180
results with the original output. Of course all 180 programs also include the
self-test mode.

### Why I think this program is obfuscated.

  * Because its says so, and twice is better than once!
  * All the usual suspects i.e. ?: && || , used to compress code length in the
noble tradition of this contest, meaningless one character variable names,
etc...
  * The board representation is efficiently compressed hence obfuscated, and
the algorithm that is used to generate possible moves is extremely efficient.

In fact it can compute several moves in parallel on one processor! Moreover
Only the most efficient bitwise logical operations, shift,and subtraction by
one is used. No inefficient conditional tests and jumps are needed in that
part of the program.

  * The single expression I'm most proud of, and would have submitted to the
category of 'best obfuscated short expression' if there was one is:

        s=s^(b=s&s-1^s)

Can you figure out what it does (very efficiently) and how it fits in the
scheme of things?

  * IMHO the program is easier to understand before running cpp on it. It is
also shorter that way to be sure.
  * It even takes care to obfuscate the comments in the output programs.
  * Having the output programs a bit different than the original is more
interesting.
  * I have written an earlier version of the program about half a year ago and
when returning to it now I had to sweat quite a lot to understand the f***ing
mess I've made.

### Known Bugs/problems/warnings/portability issues

Some CPPs issue a warning about empty macro parameters.

-pedantic informs me that 'ISO C' does not allow extra ; outside of a
function, and I to this I say ISO what ???

-Wall of course will suggest adding a lot of parenthesis, function prototypes,
and remove some unnecessary expressions, and to this I say: if I listen to you
where is my freedom to obfuscate in style?

As mentioned earlier if you try to run the original program without its source
nearby it will dump core.

The program relies heavily on the ASCII coding system (have I seen this
comment before ?). It also implicitly assumes that sizeof(int) = sizeof(FILE
*). On systems when that is not the case expect a core dump...

### Challenges

What use are the ;; for ?

Why do I use 126& in the program? (except for the rather obvious fact that it
serves as comment obfuscater).

Why not write s^= instead of s=s^ In the expression I'm most proud of ?

What is 40-(h&62) doing ?

Use the program to solve for a different starting position. It is not that
difficult. Notice however that if there are more than two empty spaces the
outputs would not compile as the layout would not be sufficient to contain the
program.

Use the program to solve for board size different than 4*5. Thats a bit more
tricky.

### Hint for the challenges

Just try to change the program, and use the self test to see what happens ...
# Most sonorous output

Jetro Lauha
Talonpojantie 5A9,
00790 Helsinki
<http://jet.ro>

## Judges' Comments

We have seen entries with SDL graphics in the past, now it's time for SDL
sound. This entry can even be run on a computer without a sound card with an
appropriate setting of an environment variable - for that you'll have to dig
into the SDL documentation.

Can you figure out how the notes are encoded and program a different melody?

### To build

Download and install the portable [Simple DirectMedia Layer library](http://www.libsdl.org/)

       cc -o jetro `sdl-config --cflags --libs` jetro.c

### To run

       ./jetro

## Selected Author's Comments

To compile the entry you need SDL library, which is used only for audio
output. To run the entry make sure you have audio output available. The entry
plays 22KHz 16 bit mono music with a small softsynth. When the music plays,
you can stop the application by pressing enter, as the code will just wait
with one call to getchar() before it quits.
# Best emulator

Stephen Sykes
Maxisat
Laivalahdenportti 2
00810, Helsinki
Finland
sds@maxisat.fi

## Judges' comments

For those who fondly remember their first PET, this entry will start you
down memory lane ... starting with $C000 of course!

We encourage you to try and grok the obfuscated expression on line 56,
after C pre-processor gets finished with it!

You will need to download the ROM contents to use the emulator in PET
mode.

        wget http://www.zimmers.net/anonftp/pub/cbm/firmware/computers/pet/basic-2-c000.901465-01.bin
        wget http://www.zimmers.net/anonftp/pub/cbm/firmware/computers/pet/basic-2-d000.901465-02.bin
        wget http://www.zimmers.net/anonftp/pub/cbm/firmware/computers/pet/edit-2-n.901447-24.bin
        wget http://www.zimmers.net/anonftp/pub/cbm/firmware/computers/pet/kernal-2.901465-03.bin

        dd bs=2k count=1 if=/dev/zero of=nullfill.bin

        cat basic-2-c000.901465-01.bin basic-2-d000.901465-02.bin edit-2-n.901447-24.bin nullfill.bin kernal-2.901465-03.bin >pet.rom

### To build

        cc -o sykes sykes.c -lcurses

### To run

        sykes binary_file

### Author's comments

This program is not only a complete 6502 processor emulator, but also an
emulation of the Commodore PET 2001.

This is the second version of the same entry, but this one takes care to
not include any possibly copyrighted items in the info files, to be sure
to not infringe the rules.

### Test

Compile the program, then test the 6502 emulation like this:

        ./prog 6502test

A basic test is done for each instruction and addressing mode, all tests
should pass. At the end of the tests, it loops forever - break out with
control-C.

### PET EMULATION

Cast your mind back to 1977... a little company called Commodore
introduced the "PET", the Personal Electronic Transactor.

The machine was a hit, and history was made.

Now you can re-live those wonderful times with this PET emulator!

To emulate the PET, you must download the pet rom. Use the script
provided (fetchrom), it will fetch the parts from right place, and will
compile it into the file pet.rom.

Or if you don't have wget, navigate to here:

   <http://www.zimmers.net/anonftp/pub/cbm/firmware/computers/pet/>
   
and fetch the files basic-2-c000.901465-01.bin,
basic-2-d000.901465-02.bin, edit-2-n.901447-24.bin,
kernal-2.901465-03.bin. Concatenate them in that order into one pet.rom
file, adding a 2048 byte filler in between the edit-2 and kernal-2
files. The resulting file should be 16384 bytes.

Make sure you have a terminal window of 40x25 chars or bigger, and then
run the emulator like this:

        ./prog pet.rom

You should see the startup message. Try typing in some BASIC - for
instance:

        PRINT "HELLO, WORLD"

There is an optional numeric parameter, which controls the speed. For a
slower cursor blink, try

        ./prog pet.rom 6

and for faster

        ./prog pet.rom 2

the default is 4.

The control keys are as follows:

        ^A HOME
        ^L CLR
        ^R RVS
        ^E OFF
        ^Y INST
        ^X STOP (break)
        ^F cursor forward
        ^B cursor back
        ^N cursor down

Supplied also is a short demo program written in BASIC. Try typing

        LOAD "DEMO"
        RUN

Many other old programs will run in this emulator too. Files with a .PRG
extension should work. (Look, for instance, here:
<http://www.zimmers.net/anonftp/pub/cbm/pet/ALLFILES.html>, 
or try this one: <http://www.zimmers.net/anonftp/pub/cbm/pet/games/english/dungeon.prg>) 
The filenames must be upper case in order to be loaded by the emulator.

You can save programs too - try

        10 PRINT "HELLO!"
        SAVE "HELLO"
        NEW

        LOAD "HELLO"
        RUN

You also might try typing this to see an ancient easter egg:

        WAIT 6502,12

### 6502 EMULATION

The program is basically a 6502 emulator, and it does NOT need the
commodore rom to work.

Supplied as a demonstration is a compiled-for-6502 version a chess
program (heh, I found a use for a previous losing entry :). Try:

        ./prog chess

It works as you would expect (it plays very badly). There's no castling
or en-passant, and to win you must actually take the opponent's king.

You can write your own programs too, any 6502 assembler should work.

The emulator loads the supplied file at $C000, and starts execution from
that address also (the reset vector is ignored).

The screen memory begins at $8000, and is 40 columns * 25 rows.
Keypresses appear when they occur in memory location $A2, and are OR'd
with $80 - this is a way of indicating a fresh character. The program
can frequently check this byte, and when it sees a new character, it can
AND it with $7F to indicate that it has been read.

The 6502 emulator receives an interrupt 60 times a second or so, you may
want to disable interrupts (with SEI) if you do not need this.

In 6502 emulation mode the special PET character codes are not used and
the screen understands normal ASCII.

Lastly, the before emulation starts, the low byte from a time() call is
placed at address 0 - this can be used as a random seed.

### Technical description

Most of the program comprises the 6502 emulator. Curses is used for the
screen and keyboard handling.

Much of the obfuscation comes from the need to squeeze in the 6502
emulation as well as faking enough of the PET hardware for it to work.

If the supplied file is exactly 16384 bytes, the emulator assumes it is
a PET rom, and goes into PET emulation mode. Otherwise some PET specific
features are skipped during normal 6502 emulation.

The main processing all happens in a heroic expression containing no
less than 64 ternery operators (after cpp) starting on line 56. This
decodes the 6502 instructions according to a table and executes them.

The addressing mode is decoded in a similar expression starting on line
53.

### Bugs

The machine emulated is an older 40 column PET, so 80 column programs
will not show correctly.

There is no emulation of PET graphics characters.

The parameter controls the speed of the 60Hz "jiffy clock", and not the
processor speed. This means many games may run too fast to be usable -
it really depends on the speed of your machine.

Although the PET emulator can do LOAD and SAVE, it cannot VERIFY or OPEN
and CLOSE files.

The PET hardware emulation is not at all complete - features such as the
hardware timers are completely missing. Some programs will not run
correctly.

The 6502 emulation does not include the seldom used decimal mode, or any
of the "undocumented" instructions.

### IMPORTANT NOTE

I think it is great fun to run the PET emulation and mess around with
Microsoft BASIC. However, this obviously needs the rom file to work. My
program is original and completely free of any copyright, but, of
course, the pet rom is not my work. So I ask the user to download it
from the internet.  This is to avoid directly infringing any copyright.

### Finally

What does this do?

        ./prog pet.rom -1
        
Have fun!
# Most discourteous interpreter

Arne "Timwi" Heizmann
Germany
timwi@gmx.net

## Judges' notes

### To build

        cc timwi.c -o timwi

### To run

        timwi < bf_program

Unlike most BF interpreters that we have been receiving for the last few
years, this one, in our opinion, is the most obfuscated albeit the most
discourteous to the language it interprets. A simple 3-character fix will make
it slightly less so.

Quite a few BF programs found on the Net expect byte-based memory, quite a few
exceed the capacity of this interpreter, but there are many that work. Some
small quines work, some don't.

Why?

## Selected notes from the author

This is an interpreter for the programming language BrainFuck (BF).

Input must be provided in the following format: First a sequence of integers
separated by whitespace (this will be the input to the BF program), then a
colon (:), then the BF program itself.

Example:

        (echo "20 : ,-->+.>+.<<[>[>>+>+<<<-]>[>>+>+<<<-]>";

        echo "[<+>-]>[<<<+>>>-]>[-]<<<<.<-]") | timwi

This will print the first 20 Fibonacci numbers.

You must not pass any command-line arguments.

### Features

  * Supports the complete set of 8 BF instructions (+-<>[].,).
  * Supports the use of alternative characters for some of those instructions.
Use this to obfuscate your BF programs!

For a challenge, figure out what this obfuscated BF program does:

        J4mzt?Vazexx-20d~&&~AxdUV!x(~Jz&V)x*(P=J)JUN(dizz)xx_!xx'0&{Vz;}&Jj

It takes two integers as input and outputs one integer.

  * Ignores all whitespace (newlines, spaces and tabs) in the input program.

### Limitations

Since the program, naturally, uses ints, the calculations must not exceed the
range of an int. (But then again, you can use the integer overflow to further
obfuscate your BF programs in creative ways!)

You are limited to 3125 input integers and 3125 instructions. If you exceed
one of these limits, the behaviour is undefined.

### Obfuscations

Some of the superficial obfuscations are pretty obvious: I'm using #defines to
make everything look nice and liney, and the program is merely a recursive
main function with only a single 'return' statement which uses nested ternary
operators to make even the pre-processed code unreadable.

However, the more subtle obfuscations relate to the way the program works.
After applying the pre-processing, you will see a lot of "1+1+1+...etc.", and
even if you replace these with their result, those numbers will still not
represent (or even relate to) the ASCII codes of the BF instructions.

The program will first read in all the input integers, but it will begin
execution immediately and only read program instructions as they are needed.
Yet there is no global variable storing how far it has read! Perhaps the
hardest thing to figure out is how it finds the matching square brackets.
# Most ingenious puzzle solution

        Aidan Thornton
        United Kingdom
        makomk@lycos.co.uk

## Judges' comments

Are you puzzled about puzzles?  This entry might puzzle you
more while it puzzles out some puzzles: all in a puzzling way!

Goto the source and notice the lack of functions.  Jump
to the switch statement.  And if you think you can puzzle
it out better, try solving insane1.sudoku all by yourself!

### To build

        cc -O2 -o aidan aidan.c

## Author's comments

This program can solve a type of logic puzzle known as a Sudoku, and also
generate new ones. (Apparently, the puzzle is known as Number Place in the US,
but we in the UK got it via Japan, where it's quite common in magazines, etc.
These things happen sometimes.)

### Contents

  * build file: build.txt - you don't need this
  * program file: sudoku-sf.c - sudoku solver and generator
  * remarks file: sudoku-sf.txt - this file
  * info file: test-su.perl - optional test script (written for Perl5)
  * info file: eg-sudoku.tar - various assorted example sudokus

**XXX - now the tar file includes the test script and the examples**

Yes, the test suite really is 5 times larger than the actual program. You
**did** say this was a parody of the software development process...

> **IMPORTANT!**
>
> test.perl expects the sudoku-sf executable to be `./sudoku-sf`. If you rename
> it, please change the definition of $sf_exe to the new name
>
> **IMPORTANT!**

### Legal blurb

This program comes with NO WARRANTY, not even that it'll do what I say it
should. Any misfortunes that occur as a result of using this are not my fault.
Go find some unpopular multinational to sue instead.

This program is not copyrighted and is entirely my work. Distribute or modify
it as you wish, though please give me credit.

### What is a sudoku?

(If you know, feel free to skip this section. Get more details from [the
wikipedia entry])

   [the wikipedia entry]: http://en.wikipedia.org/wiki/Sudoku

A sudoku is a type of logic puzzle. You are given a grid of 9x9 boxes, some
of which contain digits. This is divided into nine 3x3 boxes, e.g. (from the
Wikipedia article - fairly easy):

        . . . | 1 . . | 7 4 .
        . 5 . | . 9 . | . 3 2
        . . 6 | 7 . . | 9 . .
        ------+-------+------
        4 . . | 8 . . | . . .
        . 2 . | . . . | . 1 .
        . . . | . . 9 | . . 5
        ------+-------+------
        . . 4 | . . 7 | 3 . .
        7 3 . | . 2 . | . 6 .
        . 6 5 | . . 4 | . . .

You have to fill in the remaining boxes so that each row, column, and smaller
box contains all of the digits 1-9. That's all the information I needed to
figure out how to solve them, but there's a useful tutorial on
<http://www.sudoku.org.uk/>, which is roughly affiliated with the Daily
Telegraph (a UK newspaper).

Now, with modern computers this **can** be solved using brute force, e.g.:

        #include <stdio.h> /* sudoku-bfi.c */
        #define S(t) for(n=0;n<9;v[n++]=0);for(n=0;n<81;n++)if(i[n]){z=1<<i[n];if(v[t]\ 
        &z)for(;;){if(p<0)goto d;if(i[p]++<9)goto f;i[p]=0;p=s[p];}v[t]|=z;}
        int i[82],s[81],v[9],n,p,z;int main(void){for(n=0;n<81;){p=getchar()^48;if(p==
        30)p=0;if(p<10)i[n++]=p;}i[81]=0;p=-1;f:S(n%9)S(n/9)S(n%9/3+n/27*3)if(p>80)goto
        d;for(n=p;i[++p];);s[p]=n;i[p]=1;goto f;d:z=p<81;printf("\n%s!\n\n",z?"Fail":
        "Success");for(n=0;n<81;){p=i[n];printf("%c %s",(p?p|48:'.'),(++n%3?"":n%9?"| "
        :n%27?"\n":n%81?"\n------+-------+------\n":"\n\n"));}return z;}

That isn't the approach I've used; it's slow (particularly in worst-case or
nearly so scenarios), inelegant, and not a good starting point for sudoku
generation. It's also much too easy to understand ;-) Instead, I've written a
program which solves them in much the same way as I do, only a lot faster (and
hopefully more reliably).

Oh, and if you think that example sudoku is too easy, try this one (which my
program generated):

        --- insane1.sudoku --
        . . 4 | . . . | . 5 6
        5 . . | . 7 2 | . . .
        . . 1 | . . . | 8 . .
        ------+-------+------
        . . . | . . . | . . .
        . . . | 6 9 3 | . . 5
        . . . | . . . | 7 3 4
        ------+-------+------
        . 5 . | 2 . 1 | 4 . 8
        3 . . | . . . | . . .
        . . . | . . . | . 6 1

Be warned - it's evil! (I certainly haven't been able to solve it by hand. The
brute-force program given above, sudoku-bfi.c, also has trouble - it took 66
seconds to solve it - but probably for different reasons. That's the worst
performance I've had from brute-force so far!)

### Usage

#### Building

        cc -o sudoku-bf sudoku-bf.c

-- or, if using gcc, try --

        gcc -O2 -Wall -Wextra -ansi -pedantic-errors -o sudoku-sf sudoku-sf.c

-- or, if using gcc and feeling lazy --

        sh build.txt

#### Testing (optional)

        perl ./test-su.perl

Note that this requires Perl 5 (I use 5.8.5, earlier versions untested) and is
somewhat slow (should take under a minute on a fairly modern PC - try
appending "-n 0" if you're in a hurry). I wrote it mostly for my own benefit,
really.

#### Solving

        ./sudoku-sf < somefile.txt

Input should be the numbers of each row in turn. Empty spaces can be
represented as a period (.) or zero (0). Other characters are ignored, so you
can cut-and-paste either example sudoku from above into a file and feed that
in. The program has coped with every input I've thrown at it so far, including
an empty grid.

Output consists of the problem, then the solution, then a message of
success/failure.

`./sudoku-sf U` (capital U), may also be useful, or perhaps not. It only took
an extra 15 bytes of (very simple) code to add, so it doesn't really matter to
me. (It's the same as the normal mode for most input you're likely to feed in,
though slightly slower. See if you can figure out what it does.)

#### Generating

        ./sudoku <seed>

Output is a blank grid, then the solution, then the problem. There's no
control over the difficulty. Sorry. However, all generated sudokus should have
exactly one solution - if one doesn't, that's a bug.

### Speed

Fast enough. Solving and generating are practically instant on my 1Ghz Duron.
Of course, there could be some cases which take longer...

More precisely - 400 random sudokus are generated and solved in about 45
seconds in tests on my PC (1Ghz Duron, gcc 3.4.1, -O2 optimisation - takes
about 60 seconds with no optimisation). If that isn't fast enough, what on
Earth are you doing with it?

### Bugs

None known - hopefully I've worked out all the major ones. Nothing has come up
in testing since the last bugfix, but what does that mean?

Tested on:

        - gcc 3.4.1-3mdk, Linux/x86

        *RETEST* Borland C 4.5, 16-bit DOS .exe (small memory model)

I don't count the fact that it first prints a blank grid whenever asked to
generate a sudoku as a bug - just a minor quirk. The fix is slightly awkward
and would make the program slightly longer, so I haven't bothered - it's not
important.

### Missing Features

  * No control over the difficulty of generated sudokus - they vary from easy
to hair-tugging near-impossibility. Solver beware. Seeing as apparently one
program [took six years], I'm in no hurry.

  [took six years]: http://news.bbc.co.uk/1/hi/magazine/4469719.stm

  * Some sort of curses-based UI to let you solve interactively might be cool,
but I don't feel like learning curses just for this. Besides, I spent enough
of the time swearing as it is.

  * If you mistype a sudoku (e.g. from a paper/magazine) - and you will it
can't help you figure out where the mistake is, sadly.

### Portability

Dependant on ASCII, requires that an int is at least 15 bits and a long at
least 32. (No, that isn't a typo - I did say 15, not 16).

Also requires that cpp can properly handle something like:

        #define foo(x,y) x y
        foo(bar,)

Apparently, a few can't (ANSI C specifically doesn't require that this works,
though it usually does). Unfortunately, I didn't discover this issue until too
late. (It was mentioned in the notes for people modifying GCC in the "beware
of obscure compiler limitations" section, so I'm figuring it's quite unusual.)

### Compiler warnings

Some when compiled with `gcc -Wall -Wextra -ansi -pedantic`:

  * The left-hand operand of a comma has no effect in two places
  * Parentheses are suggested around a + in an operand of & in the "i" macro
definition.

Borland C also spots some code in expressions which has no effect, and some
uses of '=' where you'd expect a comparison operator.

### Obfuscation

Let's see now:

  * Squint-inducing variable naming
  * Slightly odd `#defines` (which will be cleaned up by cpp + a code
    beautifier, but see the next item)
  * No functions but main() - all code reuse via #defines, or by various other
    methods (usually somewhat icky ones). This wasn't deliberate - it just ended
    up that way somehow...
  * Gotos from everywhere to everywhere else
  * A slightly... interesting switch statement.
  * Generally odd flow of control (see above items)
  * Plenty of bit-twiddling
  * To save space, no 'A'-style char constants - hard-coded numbers are used.
    (There's one, but it isn't used to make things **clearer**)
  * `array[index]` notation, because:
    - a) it's traditional
    - b) take a look at how the s and N(I,l) macros are used
  * various other little things not worth mentioning

So basically, just what you'd normally expect in an IOCCC entry
# Most ambiguous language

        V. Chia
        Singapore
        bi@mncw.tk

## Judges' comments

Have you had your morning cup of Java?  You might want a
second cup before parsing this entry.  And give your C
pre-processor a triple shot as it tries to handle parameters
for "stringification".

### To build

      cc chia.c -o chia

### To run

      chia

## Author's comments

Two things inspired this entry. First, there were the C programs which were
`#define`'d to look like Pascal or Visual Basic: the /bin/sh code from V7 Unix
(which reportedly was the motivation behind this contest!), the VAL Linker by
David Troendle, the 2000/primenum entry, ... Looking at these programs, I
thought, "hmm... if it's possible to make C code look like some weird cross
between Pascal, VB, and COBOL, then how about making C code look like some
other language?"

As chance would have it, I was writing some Java code at that time, and one of
my net.friends was also working on someone else's Java code. We both hated
Java; indeed, I hated Java so much that I was tired of hating it. Then I
remembered my earlier idea: "Of course! Why not write C code that looks like
Java? And poke fun at Java while I'm at it? All ye behold, as I turn anger
into action! PH34R MII!!!!!!!" And so, this entry was born. :-)

Besides carrying a revolutionary message in the comments, this entry also
draws a spiffy little Koch snowflake fractal on the screen, with the help of
ANSI escape sequences.

The code requires a preprocessor that can stomach all kinds of nonsense that
are passed as parameters to macros for stringification. GNU cpp handles such
things just fine, but certain broken preprocessors may decide to freak out
when they see macro parameters that don't look like C tokens.
# Best of show

Mauro Persano
So Paulo
Brazil
mauro_persano@yahoo.com

## Judges' Comments

### To build

        cc -lm persano.c -o persano

If your system is one of those that distinguish between text and binary
streams, you must know what to do to switch the standard output into
binary mode (e.g. adding a line to the source code or specifying a
linker option).

### Try

        persano 3 16 > knot3-16.gif

Open the GIF file with a viewer capable of displaying animated GIFs and
watch closely at the bottom of the picture (you may need to use
"gifsicle" - a great tool to manipulate animated GIFs - to slow down the
animation and to compress the GIFs generated by the entry).

What needs to be done to fix the problem?

Solving the author's exercises below may or may not help.

At the time of judging, the approximation of  used in the program could
not be found on mathworld.com.

## Selected Author's Comments

### NAME

**knot**
> writes animated GIF images of rendered torus knots to standard output.

### SYNOPSIS

        knot p q [num frames]

### DESCRIPTION

A (p,q)-torus knot is a closed, non-intersecting curve on the surface of
a torus in R3 that winds p times around one cycle of the torus and q
times around the other. p and q should be coprime; otherwise, the
resulting curve will _not_ be a knot (that is, imagining the resulting
curve as a loop of rubber, there will be a way to bend, twist and
stretch it, without cutting it [1], until it ends up looking just like a
circle embedded in R3 [2]).

Sample usage:

        knot 3 2 1 > foo.gif

writes a non-animated GIF (a single frame) stream of a rendered trefoil
knot to the file foo.gif.

        knot 5 2

writes a GIF stream with a rendering of Solomon's Seal knot to standard
output; since the number of frames is not specified, an animation with
40 frames will be written.

Please view the code with 8-character tabs!

### OUTPUT FORMAT

The program writes fully valid GIF 89 streams.

It is suggested that the output be viewed with a program capable of
displaying animated GIFs, such as almost any graphical HTTP browser.

Due to code size constraints, full LZW compression was not implemented
[3]. In fact, the output images are even somewhat expanded, thanks to
GIF overhead.

The GIF format supports only a limited number of bits per pixel, so the
program uses ordered dithering to emulate full RGB output.

### PORTABILITY

The program was tested on Linux, with gcc 3.1; Cygwin, with gcc 3.3; and
Solaris/Sparc, with Sun's C compiler.

The only major portability issue should be reliance on ASCII.

It should also be mentioned that the program won't work on systems that
distinguish between text and binary streams; however, since hardly
anyone uses such systems in this day and age, this is a minor issue. [4]

### EXERCISES FOR THE READER

  1. (1 point) The surface is composed of many small polygons. Try to make it
smoother by increasing the number of polygons.

  2. (2 points) Figure out how to change the radius of the tube cross section.

  3. (5 points) Locate the famous transcendental constant  in the code.

### FOOTNOTES

[1] You can call such a transformation an "ambient isotopy" if you want to
impress people at parties.

[2] Also known as the "unknot", which sounds slightly less impressive than
"ambient isotopy".

[3] Unfortunately (for the author), the convenient excuse that LZW compression
was not implemented in order to avoid the Unisys patent can no longer be used.

[4] ;)
2005 marked the "The Eighteenth International Obfuscated C Code Contest"
========================================================================

Copyright (C) 2005, Landon Curt Noll, Simon Cooper, and Leonid A.
Broukhis. All Rights Reserved. Permission for personal, educational
or non-profit use is granted provided this copyright and notice are
included in its entirety and remains unaltered.  All other uses
must receive prior permission from the contest judges.


Standard IOCCC stuff
--------------------

The IOCCC has a web site and now has a number of international mirrors.
The primary site can be found at,

>	<http://www.ioccc.org/>

Use make to compile entries.  It is possible that on non-Un*x / non-Linux
systems the makefile needs to be changed.  See the Makefile for details.

Look at the source and try to figure out what the programs do, and run
them with various inputs.  If you want to, look at the hints files for
spoilers - this year we included most of the information included
by the submitters.

Read over the makefile for compile/build issues.  Your system may require
certain changes (add or remove a library, add or remove a #define).

Some ANSI C compilers are not quite as good as they should be.  If
yours is lacking, you may need to compile using gcc instead of your
local compiler.


Remarks on some of the entries
------------------------------

There were some outstanding entries that did not win.  Unfortunately
some very good entries lost because they:

+ depended too much on non-portable side effects in expressions;

+ depended too much on a particular byte order;

+ required the use of a special script, data file or pseudo-machine
  language that was not supplied with the entry.

We hope the authors of some of those entries will fix and re-submit
them for the next IOCCC.

We believe you will be impressed with this year's winners.

In particular:

+ The Abuse of the rules used local dictionary data to get around the
size limit.

+ The Most beauteous visuals made cleaver use of {}'s and whitespace in their source code and during execution.

+ The most circuitous walk entry is just amazing.

+ The Best game makes full use of its single function.

+ The Best emulator may allow you to re-connect to your first PET.

+ Our Best of Show this year was simply (or non-simply) the best!

+ (And we need only mention (parenthetically speaking) that the the best use of parenthesis is self re-producing).

+ The most sonorous output might sound like a good idea.

+ The Best 2D puzzle takes editorial license with expressions as well as the
with the vi editor.

+ The Most ambiguous language winner is really a C program.

+ The superfluous output winner is simply Voronoilific!

+ Try not to have your sense of good coding offended by the Most
discourteous interpreter winner.

+ The Best use of the www doesn't include those letters

+ You will be puzzled by Best 3D puzzle winner, we are sure!

+ The Most ingenious puzzle solution might puzzle you more while it
puzzles out some puzzles: all in a puzzling way!  :-)


Final Comments
--------------

Please feel free to send us comments and suggestions about the
competition, this README or anything else that you would like to see in
future contests.

If you use, distribute or publish these entries in some way, please drop
us a line.  We enjoy seeing who, where and how the contest is used.

If you have problems with any of the entries, AND YOU HAVE A FIX, please
send us the fix (patch file or the entire changed file).

For the latest information on how to contact the IOCCC Judges please visit

>	<http://www.ioccc.org/contact.html>

For news of the next contest watch:

>	<http://www.ioccc.org/>

# Best use of parenthesis

Michael Ash
USA
mike@mikeash.com

## Judges' comments

Having problems speaking code?  Do you LISP?  Parenthetically
speaking, this entry takes advantage of C99 features, while
speaking parenthetically.  Best of all, it self-reproduces!

John McCarthy might not of imagined it quite like this!  :-)

### To build

        gcc --std=c99 -o mikeash mikeash.c

### To run

        mikeash < mikeash.c
        mikeash < mikeash.c | diff - mikeash.c

## Author's comments

This program is a self-reproducing program, which is on the IOCCC's list
of discouraged program types. Worse, it's a self-reproducing program
written in Common Lisp. What's this doing as an entry to the IOCCC?

Start over; this program, when compiled with a C99 compiler, is an
interpreter for an extremely limited and highly broken subset of Common
Lisp.

It requires C99 because of C99's ability to declare variables in the
initializer of a for loop. Unfortunately, C99 mode typically warns about
implicitly declared functions, and preprocessor directives prevent the
program from being valid Common Lisp. As a result, several warnings will
be printed about implicit declarations of functions. There are also
warnings about unknown escape sequences in the constant string, due to
different string escape semantics in C and Lisp, and some implicit
integer-to-pointer conversions due to the implicitly-declared functions.

Try:

        echo '(format t "~s" (+ 2 2 ))' | ./lispob

You should see '4"' echoed on your command prompt. The " after the 4 and
the lack of a newline are due to the somewhat broken implementation of
the format function. More sophisticated arithmetic expressions may be
used:

       echo '(format t "~s" (* (+ 2 2 ) (- 5 (/ 9 3 ))))' | ./lispob

This evaluates the expression (2+2) * (5 - 9/3) giving the correct
result, 8.  Note that due to the highly ad-hoc nature of the tokenizer,
the spaces before the closing paretheses are mandatory.

The program can also be run in an interactive mode, by simply executing
./lispob and then typing lisp expressions, but this is difficult due to the
lack of proper editing facilities and the total lack of error recovery in the
interpreter. Typos will most likely crash the program.

Aside from being required to put spaces between tokens and closing
parentheses, there are other limitations on the dialect of Common Lisp
that this program understands:

  * The only built-in functions are defvar, format, substitute, char-upcase,
+, -, *, and /.

  * Only one variable is available. This variable is called 'q', although any
symbol name starting with the letter 'q' will be mapped to this variable.

  * Only the first letter of a function name is significant. For example,
format, f, farm, and various other words starting with 'f' will all map to the
format function.

  * The defvar function completely ignores its first parameter. It will always
store the result of evaluating its second parameter in 'q'. Unlike in Common
Lisp, multiple invocations of defvar on the same variable will overwrite old
values.

  * Character constants are limited to #\Newline and single-character
constants such as #\x.

  * The char-upcase function will give strange results if passed something
other than a lowercase character.

  * The format function takes exactly three parameters. The first parameter is
ignored; output always goes to stdout. The second parameter must have exactly
one ~s format specifier in it, and no other format specifiers are permitted.

  * The arithmetic functions take exactly two parameters.

  * All tokens must be separated from a following ) by whitespace.

  * A lot of other things. Notably, the language which this program interprets
is nowhere near Turing-complete.

Basically, the lisp interpreter is good for some basic math operations, and
for running itself. To do the latter, try this:

        ./lispob < lispob.c > lispob2.c
        diff lispob.c lispob2.c

The program can also be run from an implementation of common lisp. To do
this, run the common lisp compiler and then type the following command:

       (load "lispob.c")

The source code of lispob.c will be printed.

Lispob is obfuscated in several ways. First, it's actually two programs
in one, which actually share a small amount of code. Running a C code
beautifier will destroy the lisp program contained within. Second and
more importantly, it is very badly written, which will presumably
confuse people who are used to looking at well-implemented interpreters.

The program comes in at just under 2k of significant characters.
However, this size is exaggerated, because it contains a complete copy
of itself for the self-reproducing lisp program, making it twice the
size. This doubling effect made it something of a challenge to fit
inside the IOCCC's size limit.

This code should be highly portable. It was tested under Mac OS X and
Linux on i386, but it should run elsewhere. It requires ASCII due to
hardcoding various character constants. Other than this requirement, it
should run anywhere there's a conforming C99 compiler and a standard
C library.
# Most superfluous output

        Francois Boutines
        Toulouse, France
        francois.boutines@gmail.com

## Judges' Comments

### To build

        cc -o boutines boutines.c

### To run

You will need an [SVG] viewer. Look here to find some [SVG Viewer Implementations].

   [SVG]: http://www.w3.org/Graphics/SVG/
   [SVG Viewer Implementations]: http://wiki.svg.org/Viewer_Implementations

The following will create an SVG file,

        perl -e 'map{print rand," ",rand,"n";}(1..20);' | ./boutines > test.svg

Can you explain the author's remark "[generated files] are not as scalable as their name suggests"?

## Author's Comments

_In memory of my father Pierre Boutines-Vignard._

### Walkthrough

My program works as follows:

**Input**
> a list of 2D points in the unit square

**Output**
> a Voronoi diagram of the set as an [SVG] stream

This will possibly save a compressed SVG file and may be useful:

        ./boutines | gzip > result.svgz

Input consists of a list of floating points values separated by whitespaces
(ranging preferably in [0,1]). Alternating an horizontal coordinate, a
whitespace then the other coordinate (pointing downwards in the resulting
graph) and a newline will just go fine :

        0 0
        0 1
        1 0
        1 1
        .5 .5

Strictly speaking, you have to provide a **set** of points. If there are
duplicates in the list, there is no guarantee on the one to be shown (in
addition their labels will overlap) in the resulting colored Voronoi diagram.

### Caution

This program might have been a lot shorter, but nearly impractical even for
medium sized datasets. On the other hand it could have been a lot faster, but
hard to qualify under the IOCCC size limit. So guess what I did a compromise
favoring innermost obfuscation, sacrificing sometimes speed and other tedious
factors.

Therefore this entry is limited to

> ![floor\bigg(\frac{10^6}{4\times(sizeof(double)+1)}-1\bigg)](eqn.png)

points and won't even be suitable for more than a few thousand : although
generated files do pass [W3C SVG Validator], and are highly compressible,
they are not as scalable as their name suggests For serious applications
about Voronoi diagrams, see [Qhull], [CGAL] and the like : but you may
still encounter large output volumes (and have to handle some sort of clipping
in order to represent properly infinite regions of the diagram in SVG).

   [W3C SVG Validator]: http://jiggles.w3.org/svgvalidator/
   [Qhull]: http://www.qhull.org/
   [CGAL]: http://www.cgal.org/

Beware, compilation may report warnings about precision loss, linting may be a
disaster, but the code should remain portable, and the output accurate enough
for most devices (including many inkjet printers). If you ever miss precision
on a particular dataset or peripheral, you may want to dive in and let U be
the next power of `__LINE__`.

Note : bad inputs will be sanctioned by the production of the 42nd Mersenne
prime (ie. 2^25964951 -1), memory will be kept.

### Why I think this code is Obfuscated ?

I'm quite divided on the subject because I wrote :

  * clear SVG key words but complicated output statements
  * no nested loops but loads of function calls
  * easy recursion but no clear data struture
  * easy maths but no use of math.h
  * a single if

Be sure to check the antepenultimate line of code.

### Missing Features

**Color control**
> Cell colors are chosen randomly (with a questionable rejection scheme). It
might have been useful to input them along with sites coordinates, turning the
application into a puzzling graphics engine.

**Site labelling**
> The points are implicitly numbered in the order they were entered
(starting at one). This can be overridden however, via a simple XSL
transformation.

**Site radius**
> The site radius is hardwired in the code, I still wonder why I did not
design it as a function of the underlying cell's area (which can be averaged
for free) or at least a command line parameter. Same with the char set, the
viewport and potentially every SVG property.

## See Also

   [Voronoi at Wikipedia](http://en.wikipedia.org/wiki/Voronoi_diagram),
   [An Excerpt from The Algorithm Design Manual](http://www2.toki.or.id/book/AlgDesignManual/BOOK/BOOK4/NODE187.HTM),
   [Voronoi and Art](http://www.snibbe.com/scott/bf)

## Example Output

> ![Voronoi diagram of two regular pentagon vertices](Voronoi.png)

# Most Obfuscaed Audio

Aaron Grothe
2205 South 51st Street
Omaha, NE 68106
US

## Judges' Comments:

### To build:

        make grothe

### To run:

        ./grothe 65000000 10000000 1344 < twinkle.txt

... and then put on your "electronic ears".  You may find using
a tunable scanning electronic ear helps.

Most of the time, interference is annoying.  This entry is the
exception that proves the rule.  What is a bug to some is a
feature to this entry.  :-)

## Selected Author's Comments:

The program draws patterns on the screen that can be picked up by a
shortwave radio.   It emulates the frequencies for an old fashion touch
tone phone, so old songs can be played by hitting 0-9,#, and *.

To be able to run the program you need to determine the following
parameters

        carrier_freq     - base frequency used to host music
        pixelclock       - refresh rate of the monitor
        horizontal_total - total scan along the horizontal axis

If you have xvidtune installed you can get the pixelclock and
horizontal total with the following command

        xvidtune -show | head -n 1 |
                awk '{ print "pixelclock " $2 * 1000000 " horizontal_total = " $6 }'

example from my laptops

        ./grothe 65000000 10000000 1344 < twinkle.txt

Even if the user gets a setting off, the sound will usually be able to be
heard on AM at a multiple of the original frequency

The core idea of using a machine to play music on AM radio goes all the
way back to the Altair computers and Timex Sinclair ZX-81s.

### Several example songs

Olympic Fanfare - from antang@phakt.usc.edu - Tony

        4-9-91231,2222-321123123-9-91231,2222-32112321

Twinkle Twinkle Little Star - from fsufunkyb@aol.com - Ben Schmidt

        1199##9-6633221-9966332-9966332-1199#9-6633221-

Generic Arabian Tune - from rdippold@qualcomm.com -Ron "Asbestos" Dippold

        453,54,4569564459,9#95458,8987453 54

Others can be found by doing a search for "touch tone phone songs".

### Obfuscations

- Some numbers expressed in Octal, some in hex and some in decimal
  "A foolish consistency is the hobgoblin of little minds" -
  Ralph Waldo Emerson
- Funky scoping, looking at the nanosleep section and
  XsetWindowAttributes declares local variables
- Algorithm is very weird, uses y dimension to draw carrier frequency
  and x dimension to draw audio frequency, based on Erik Thiele's
  Tempest for Eliza
- lack of #defines confuses many people :-)
- figuring out your pixelclock and horizontal total and which carrier
  frequency to use can be an exercise in obfuscation for the user
- use of commas in various places, confuses most c code beautifiers
  sometimes making the beautified code harder to read
- use of static to ensure initilization is EVIL and done in several
  places
- uses static declarations & voids function returns we don't care about
  making the code harder to read
- does sound using only X11 libs, no other libs required
- demonstrates tempest emissions in a fun/easy way
- follows good programming practices of actually setting exit codes and
  giving usage when run with incorrect parameters

### References

Tempest for Eliza - Basis for Algorithms

> <http://www.erikyyy.de/tempest/>

Tempest AM - Another early program in this field

> <http://silcnet.org/priikone/programs.php?lang=en>

Paper by Markus G. Kuhn's and Ross J. Anderson's,
"Soft Tempest: Hidden Data Transmission Using Electromagnetic Emanations"

> <http://www.cl.cam.ac.uk/~mgk25/ih98-tempest.pdf>
# Best Small Program

Oscar Toledo
Av. Santa Cruz del Monte 9-304
Ciudad Satelite. Edo. de Mexico
CP. 53110
Mexico

## Judges' remarks:

### To build:

        make toledo1

### Try:

        ./toledo1 00
        ./toledo1 30
        ./toledo1 99

For most of the arguments (e.g. those above) the resulting path
is not circular, but at least one starting point yields a circular path.

Why do some of the "illegal" starting points work more or less as could
be expected, and some dump core?

## Author's comments:

Can you place a knight on a chess board and make it
to visit the 64 squares without repeating them?

If not, this program does it, just run it with an argument
giving initial position.

        ./toledo1 11         (start is A8)
        ./toledo1 18         (start is H8)
        ./toledo1 81         (start is A1)
        ./toledo1 88         (start is H1)
        ./toledo1 44         (start is D5)

It will print move order. The algorithm is so simple that you can read
it on the source code, at the first glance it can appear checkered :-)
but don't dismail, jar, jar.
# Homer's Favorite

Andy Sloane
1041 Seneca St.
Hartford, WI 53027
US

## Judges' Comments:

### To build:

        make slone

### To run:

        ./sloane

Looks almost good enough to eat, dunnit?  I suppose you could argue that,
at first blush, this looks like a self-reproducing program.

## Selected Author's Comments:

This program doesn't require any special build options, other than that it
uses sin and cos and hence requires the math library.

You will almost certainly get a compiler warning because I declared a bunch
of global ints without types.  The code looks better this way, though, I
think.  There are also no #includes, so there may be warnings for
undeclared references to printf, etc.  There's a chance that my failure to
include math.h or declare sin or cos will make the donut not render
properly -- it's worked on every system I've tried so far though.

You will need some kind of VT100-ish emulation; so while this compiles and
runs OK in Windows, you will need PuTTYcyg or something like that.

The shape of the source gives a hint about its output: it's a little
animation of a shaded donut rotating over an infinite checkerboard.  Like
many IOCCC entries, it is thus self-documenting.

I wanted to create something as "pure" as I could - meaning that the
entire source code is shaped into a work of art, without being prefixed
by any #define hacks, or even #includes, _and_ is portable enough to not
require any special libraries to do the animating.  I achieved this with
two standard escape codes for clearing the screen and moving the cursor
back to the top-left.

The donut isn't raytraced.  It's much simpler than that.

### How is it obfuscated?

There are three main pieces to this program: the donut, the checkerboard,
and the ASCII logo.  The first two are programmed in a straightforward way
(with z-buffering even!), but the mathematics for drawing them is
"optimized".  The ASCII logo has been shrunk into the smallest I could make
it by any means necessary.

The logo can actually be compressed much better (ironically, by doing
something simpler), but I didn't discover this until well after submitting.

### Puzzles

In increasing order of difficulty:

 - Can you change the shading of the donut and checkerboard?

 - Can you change the movement rates of the donut, the checkerboard, and
   the scrolling logo?

 - Can you change the inner/outer radii of the donut?  The height/scaling
   of the checkerboard?

 - How is the "IOCCC 2006" logo encoded?  Can you put something else in its
   place?  Can you find a smaller encoding?

# Best Assembler

Stephen Sykes
Itinen koulupolku
Kauniainen
Finland
<http://www.stephensykes.com>

## Judges' Comments:

### To build:

        make sykes1

### To run:

        ./sykes1

next point your browser to the file:

        sykes1.html

in the same directory.  Next try:

        ./sykes1 10

and refresh your browser.  Now read the sykes1.html page source.
Now then read the C source.  Confused?  :-)

For extra credit, understand what happens when you give this entry
an negative number argument, and why.

## Selected Author's Comments:

This cube shaped program solves the fiendishly difficult "Bedlam Cube"

If you did not get one for Christmas, there is an article about these
puzzles in wikipedia:

> <http://en.wikipedia.org/wiki/Bedlam_cube>

There is also website dedicated to them - <http://www.bedlampuzzles.com>
And some instructions on how to make your own cube here:
<http://ch.twi.tudelft.nl/~sidney/puzzles/downloads/bedlam-pieces.pdf>
Finally, you can watch it being solved here:

> <http://www.youtube.com/watch?v=eDpC7oKQJIQ>

Actually the cube is very hard to do by hand by just trying to fit it
together.  I have not known anyone to solve it in this way - you would
need to be very lucky indeed to stumble across a solution.

### Instructions

Compile the program, then test that it works:

        ./sykes1

Shortly you should see the first solution pop out on your screen.  It
shows you how to build the cube piece by piece, rendered in glorious
3d ascii.

Ascii art is all very well, but you also have a web browser, right?
Well, just open the file sykes1.html.  This html file is just a copy
of prog.c, which helpfully contains an html document that should make
the browser display for you a nice animated gif, showing you how to
build the cube.  Rendered in glorious 3d color.

Want to see another solution?  Try:

        ./sykes1 some_number

The program will discard solutions up to the number, and output numbered
solution.  Refresh your browser window to see the new solution.

Try some more - there are exactly 19186 solutions to choose from.

If you have a fast machine you might try the last solution:

        ./sykes1 19186

On my machine this takes about half an hour to run.

### Implementation

The implementation is an optimized recursive algorithm that tries to fit
the pieces into the cube one by one.  The cube pieces are defined near
the start of the program:

        int s[ ] = { 186, 94, 1426, 3098
                ,1047 , 122 , 1082 , 3083 , 1039
                , 569 , 527 , 1054 , 531  }  ;

Each piece is a bitmap, and represents a 3x3x3 cube.

For instance the first piece is 186 - this is 010111010 in binary.
Written out like this you can see that it is the cross shaped piece:

        010
        111
        010

The other pieces are defined similarly. Most of the rest require more
than one layer, such as piece 3 (1426):

        000
        000
        010

        110
        010
        010

Imagine the two layers on top of each other, and you should see this
shape:

          +---------+
         / +----+  /|
        +-/    /| / |
        |+----+ |/  +
        ||    | +  /
        +|    |   /
         |    |  /
         |    | /
         |    |/
         +----+

The program is in fact a general solver - you can change the shape of
the pieces, and provided that a solution is possible, it will be found.

For example, if you modify line 13 of the source like this, the program
will solve for a different piece set:

        int s[ ] = { 187, 94, 402, 3098

And of course you can make your own.

After the pieces are defined, the first thing the program does it to
fit them into a 4x4 cube.  It collects every possible placing of each
of the pieces.

Once those placings are ready, the program recursively checks each
combination thereof.

In order to complete in a reasonable time, care is take to eliminate
any branches that cannot result in a solution. This is done by checking
after each placing if all the remaining pieces can be placed somewhere,
and that all the free space in the cube can be filled by at least one
viable placing.  Also if a piece is found to only have one possible
placing, it is placed immediately without invoking a recursive function
call.

Once the solution is found, the ascii and gif representations are
generated.  Care must be taken to render cubes in the right order such
that pieces further back are occluded by those in front.

In the ascii output care must be taken with drawing the edges of each
1/64th cube (edges must be removed within each piece).  In the gif
this is taken care of by color, which is graded from the back to the
front to ensure edge visibility.

### Notes

The whole program has just one function - main - which is recursively
called.  In fact if you select solution 19186 it will be called exactly
159,260,759 times.

If you pick a number higher than 19186, the program will return a
solution but it will be a rotation of one of the first 19186.  This is
because the cross shaped piece fits 48 ways in the 4x4 cube, but only
2 of those ways are unique - you can rotate one of those to make any
of the other 46.  The algorithm used always places the cross piece
first, so the first two placings of that piece result in the 19186
unique solutions.

If you pick a number higher than 460464 (24x19186) the program will
return without outputting a solution.  If you can wait that long.

I recommend compiling with the most aggressive optimization options
your compiler supports.  I find --unroll-loops to be helpful with gcc.

The program relies on long long being 64 bits, but has no other special
requirements.

The program is known to compile and run under gcc and intel cc, as well
as PellesC on Windows.

### Bugs

The program is not at all a valid html document, but fortunately
browsers have good error recovery and amongst other things will ignore
the /* at the beginning, and won't mind the missing html and head tags
and the lack of end tags.

The generated gif is not compressed.  This could be argued as an
advantage - at least I don't violate any of those old Unisys patents!

The pieces aren't really those colors.  Unless you make your own.
# Most Irrational

Steinar Hamre
Norway

## Judges' Comments:

### To build:

        make hamre

### To run:

        ./hamre '-1+4/3*(2+1/(3/2*(7/2-7/3+1/6)))/2'

An irrationally coded source presents rational things!

A rational person might want to attempt the irrational task
of supporting a new operator by way of an existing macro
in the source.  And can you determine which macro this is
and understand the purpose of its arguments?

## Selected Author's Comments:

This is a calculator for rational numbers. Believe it or not, that is
a useful tool to have around, and I haven't found a useful version,
much less an obfuscated one.

It is rather feature complete as rational calculators go. The
supported operators are: +, - (binary and unary), *, / and (). Run it
by supplying an expression as the first argument, and the normalized
result will be written to stdout.

        ./hamre '-1+4/3*(2+1/(3/2*(7/2-7/3+1/6)))/2'
        2/3

If you do not supply an argument, the calculator will crash.  Other
arguments are ignored. Supplying more arguments may further limit the
number of nested operators supported.

Remember that 1/0 is not a rational number. You will not get any
answer if you divide by zero.

By default, only 31 nested levels of operators are supported.

The code is well documented, even with an example. In fact this
documentation accounts for 100% of the source.  Personally I find
preprocessing or reindenting the program counterproductive when it
comes to understanding the source. The preprocessed source becomes
rather verbose.

IOCCC entries are often loaded with all kinds of hard-coded numbers. I
have restricted myself to mostly use sensible numbers (<= 7) as
smaller numbers are much easier to remember. Also the macros really
help hiding most of the uses of these numbers away. All macros and
variables are easy-to-remember single character abbreviations, from
some language, meaningful to the purpose(s) of the macro, I hope.
# Best Compiled Graphics

Maurizio Monge
Department of Mathematics
University of Pisa
Pisa
Italy
maurizio.monge at gmail dot com

## Judges' comments:

### To build:

        echo Make sure you have the SDL development environment installed
        make monge

### Try:

        ./monge "z = 0" "z = z*z*z + c; Abs2(z) < 4"

For those who are familiar with the previous IOCCC winners, this program
is best described as "1994/tvr meets 2001/bellard". Here you have
mouse-manipulated fractals AND generated binary code, all in one package.

A more appropriate award could have been "Best abuse of the
rules", because on a non-x86-based architecture this program
is, quite predictably, a dud.

At the time of judging we were too mesmerized by the graphics
to realize it; and, after all, this entry does take a special
effort to work on both i386 and x86_64. Portable it is! :)

## Author's comments:

### For the impatients

0. Compile using the Makefile, or just run:

        gcc monge.c -o monge -O3 `sdl-config --libs --cflags`

1. Run:

        ./monge "z = 0" "z = z*z + c; Abs2(z) < 4"

2. Keep clicked with left or right button to zoom in or out.

3. Use the numpad '+' and '-' to increase/decrease the iteration
   count when needed.

4. Enjoy, unless you're more interested in trying to understand
   how it works. :)

### Introduction

This is a fractal generator that supports custom formulas and
real time zoom.  The program needs to be run with two arguments,
the first being a semicolon separated list of assignments to
do once per pixel, and the second a semicolon separated list
of assignents and conditions that will be executed (and conditions
checked) for each iteration (up to the maximum).  Using the
left and right mouse buttons you will be able to zoom in and
out (a la Xaos), the zooming algorithm is a bit slower than
Xaos's but it should give slightly better results.

Formulas can use all a-z (lowercase) variables, and the special
variables 'c' and 'i' are respectively set by default to the
complex coordinate of the pixel and to the complex imaginary 'i'.

All the constant numbers will be interpreted as real double
values.  Each expression must be an assignment ([variable] =
[expr]) or a comparison with < or > ([expr1] < or > [expr2]),
and you can add spaces as you like (as understood by the c
function 'isspace').

Supported operations and functions are:

> Operation | Description
> :-------- | :----------
> +,-,*,/   | Arithmetic operations, priority of *,/ over +,- is respected.
> <,>       | Compares the real parts of two complex numbers (the imaginary part is ignored). Any number of conditions is allowed, the iteration will just stop as soon as one of them fails.
> Abs2      | Calculates the squared norm, ie: Abs2(a+b*i) is (a*a+b*b)+0*i
> Re        | Extract the real part, ie: Re(a+b*i) is a+0*i
> Im        | Extract the imaginary part, ie: Im(a+b*i) is b+0*i
> Exp       | Calculates the complex exponential, ie Exp(a+b*i) is e^a*(cos(b)+sin(b)*i)
> Ln        | Calculates the principal value of the natural logarithm, ie Ln(a+b*i) is ln(a*a+b*b)/2 + atan(b/a)*i 

Here are a few examples of fractals you can draw:

- Mandelbrot:

        ./program "z=1" "z=z*z+c; Abs2(z)<4"

- Mandelbrot (return time variation):

        ./program "z=c" "z=z*z+c; Abs2(z-c)>0.0001"

- Julia, for c=0.31+i*0.5:

        ./program "z=c; c=0.31+i*0.5" "z=z*z+c; Abs2(z)<4"

- Julia (return time variation), for c=0.31+i*0.5:

        ./program "z=c; c=0.31+i*0.5" "z=z*z+c; Abs2(z-c)>0.0001"

- Newton, for x^3-1:

        ./program "z=c" "p=z; z=0.6666*z+0.3333/(z*z); Abs2(p-z) > 0.001"

- Newton-Mandelbrot:

        ./program "z=0" "p=z; z=z-(z*z*z + (c-1)*z - c)/(3*z*z+c-1); Abs2(p-z) > 0.001"

- Phoenix, Mandelbrot version:

        ./program "z=0; q=0" "t=z; z=z*z+Re(c)+Im(c)*q; q=t; Abs2(z)<4"

- Phoenix, Julia version for c=0.56667-i*0.5

        ./program "z=c; c=0.56667-i*0.5; q=0" "t=z; z=z*z+Re(c)+Im(c)*q; q=t; Abs2(z)<4"

### Compilation and portability

This program will only work on x86 (with an x87 FPU) or x86_64 machines,
and requires the SDL library.

Another system requirement is the mmap function (as #define'd
at the beginning of the program). If it is not available the
macro M(a) will have to be replaced with a system dependent
function that allocates readable, writable *AND* executable
memory (it will not be possible to make this program run on
paranoid systems (like OpenBSD IIRC) do not allow rwx memory).

However i was able to compile and make work the program under
Linux (Debian/x86 and OpenSuSE/x86_64) and under Cygwin/x86. A
friend of mine was able to make it work under MacOSX too.

If you want you can change the window width and height, or the default
number of iterations (that one can be tweaked at runtime, anyway) by
changing the definitions of W, H and I at the beginnning of the code.

### Caveats (i just a selected few of them!)

- The zooming speed depends on the speed of the computer.
- Incorrect formulas will ungracefully crash the program.
- Many SDL identifiers are hardcoded as number, this is safe up to ABI
  incompatibility.
- Better optimization could be done treating known real numbers as just one
  double, instead of adding a 0 imaginary part to treat them as complex
  numbers.
- There should be some way to switch from Mandelbrot to Julia with choosen
  parameter.

### Spoiler 

Sure, i don't want to deprive you of the pleasure of digging
into the infernal mess created by my corrupted mind (writing
this remark i noticed that i was ending senteces with ';' instead
that with '.', and i worried for my sanity), but just in case...

I used many obfuscation techniques, including a few ones that
are different from the tricks used in most common IOCCC program
(more 'highlevel', in the sense that they require an understanding
of how all the program works to be worked out).

This program is a formula parser that outputs machine code that
calculates the formula and check the given conditions. The
machine code targets the x87 stack based FPU, and it is almost
identical for x86 and x86_64 (except for the comparison
instructions, that have to be generated differently).  The
program keeps track of the FPU stack (the FPU has a cyclic stack
of 8 registers) and will automatically swap to and from the
main memory when required (ie, adds instructions to the generated
machine code to take care of this issue).

The formulas are parsed recursively and machine code for the
inner iteration loop is also generated.

After generating the machine code, a big event loop creates (or
zooms into) the factal executing the generated code when needed,
and then waits for input events.

The zooming algorithm works by remembering for each pixel the
floating point offset to where the value was actually calculated.
When zooming, the best match is searched, and if the offset is
too big (>1) the pixel is recalculated.
# Best Computed Graphics

Thomas Stewart
US

## Judges' Comments:

### To build:

        make stewart

### Try:

        stewart 640 480 FILE

where FILE is one of:

        altar box box2 box3 build carpet circles cross cross2 cross3
        crystal curve diamonds diamonds2 dragon dragon2 dragon3
        fern gasket gasket_mod gasket_mod2 ioccc maze octagon
        pentagon pentagons rings rings2 spirals spirals2 spirals3
        spirals4 squares stars stars2 tree tree2 tree3 tree4 triangle

Note the interesting choice of using a #define in the output.
The selection of input files makes this one endlessly fun to play
with.  Many image viewers will be able to read the results, as will
a reasonably experienced user who can parse formats in their mind.  :-)

## Selected Author's Comments:

### Execution

The program should be run with the following

        prog <m> <n> <ifs>
           m   = The size of the picture (picture will be m X m in size).
           n   = The number of iterations to run (More will make for a
                 clearer picture).
           ifs = The file to use as input.

The program will spit out a xbm image on standard out.
Minimal checking is done on the arguments mainly that there are 3.
Wrong arguments will cause the program to bomb out.

Ex:

        ./stewart 1024 1000000 gasket > gasket.xbm

### Compilation/Testing

The program compiles without warning with gcc -ansi -Wall.
lint also seems to like the code.  This must be a bug in lint.

The program was tested on Linux on a x86 and NetBSD on an alpha.
Only gcc was tested for compilers (4.0.3 and 3.3.3)


### Entry originality

In looking through past winners.  THere seem to be only 2 (92 and 94)
that generated fractals.  Both of those were Julia fractals from the
Mandlebrot set.  Those do make for some pretty pictures.  I figured
it would be nice to add some more fractals to the IOCCC, since one
hasn't won since 1994.

Instead of something that has already won I figured I would go with
another kind of fractal, those from the Iterated Function System (IFS).


### Input File

The format of the input file is as follows:

        <num ifs> <x min> <y min> <x max> <y max>
        <a> <b> <c> <d> <e> <f> <p>
        <a> <b> <c> <d> <e> <f> <p>
        <a> <b> <c> <d> <e> <f> <p>
        .
        .
        .

This file describe an IFS.

One of the most well known would be the Sierpinski Gasket:

        3 0 0 1 1
        .5 0 0 .5   0    0 .33
        .5 0 0 .5  .5    0 .33
        .5 0 0 .5 .25 .433 .34

or the fern:

        4 -5.5 0 5.5 11
        0    0    0  .16   0    0  .01
        .85  .04 -.04  .85   0  1.6  .85
        .2 -.26  .23  .22   0  1.6  .07
        -.15  .28  .26  .24   0  .44  .07

etc...

Included in my submission will be a tar ball of some ifs files,
including one that attempts (not very well) to mimic the IOCCC logo
(I figure it can't hurt to attempt to suck up, right?)

I would try to explain how to create an IFS file but I am not smart
enough to condense it down to something that is coherent.

Basically the break down is:
num is the number of equations in the IFS.
x (min, max) and y (min, max) define the ranges that will be displayed
in the xbm.

The a b c d e f are used to iterative find points that lie in the IFS
from the algorithm

        x = a * prevx + b * prevy + e;
        y = c * prevx + d * prevy + f;

The p is for the probability that the equation will run.


### Obfuscations

The main obfuscation is using a void* as my only variable (aside from
the args for main).  This causes me to do much casting and porinter
arithmetic to get the correct location and completely does away with
any meaning the variables could have.  This also makes the code more
convientient to read in the current form vs preprocessed.  After
preprocessing there will almost be 300 casts in the code and I believe
they are all needed...  (I would double check but my brain is kinda
mushy right now from chasing down a segfault in the code.)

The other main obfuscation being that it generates an IFS.  Which isn't
all that common for a program to do.  I mean google only has something
like 66,000 hits for "Iterated function system" so that means it is
obscure, right?

Some other minor obfuscations:
Since I formatted it as a "normal" program I did inject something that
on first glance will looks like a possible bug.  (When you run it through
a c-beautifier this will be removed.)

I decided not to use rand() to generate a pseudo random number.  Instead
I use xor and bit shifting.

The input file is used to make the program flexible and to allow it to
generate many different IFSs.  This has the added bonus of hiding
information about the algorithm.

The use of many magic numbers.  I figured if I get yelled about them in
a review they must be bad, right?

Silly things:
The use of decimal numbers where one would expect hex.  Octal numbers
where one would expect decimal.  Shifts instead of devides.

Using xbm as the output format.  This might confuse someone who doesn't
have an X background.  It happens to be easy but is probably a very bad
choice from a filesize standpoint.  1024x1024 image is 641k in size.
# Most Useful

Szabolcs Borsanyi
Department of Physics and Astronomy
University of Sussex
Brighton
East Sussex BN1 9QH
United Kingdom
s.borsanyi at sussex dot ac dot uk

## Judges' comments:

### To build:

        make borsanyi

### To run:

        ./borsanyi ioccc@example.com > example.gif

This entry uses a very user-friendly representation of the font
it uses (with a few exceptions).   Check out the source and see
yourself!  :-)

The resulting GIF file is likely to puzzle optical character
recognition tools.  The amount ofimagination necessary to
recognise the @ character will certainly challenge a few
anti-CAPTCHA tools.

## Author's comments:

Email address to gif converter
==============================

Introduction:
-------------

Most spam robots collect email addresses from the web sites of
innocent people, like you. Conference organizers cannot disclose
the participant's address to prevent malicious users from
grabbing them. One solution is to write as my_email _at_ address
_dot_ com. But robots are clever enough to sort that out.  A
more sophisticated approach is to create an image file with the
email address and put that on the web page.

This program creates a GIF image file from the address given
in the command line. To avoid complications with patent issues
the LZW compression feature is not used. A typical email address
is stored in less than 1-2 kilobytes.

Usage:
------

        $ gcc email.c -lpthread -o email
        $ ./email my@email.address.com > email.gif
        $ my_favourite_gif_viewer email.gif

The address cannot be longer than 42 characters, and may consist of
the characters: a-z_A-Z0-9@.-
The program is (like email addresses are) case insensitive.

Obfuscation:
------------

Multicore support is a must in present-day applications. This
entry supports up to 25 cores.  The odd names in the bottom
part of the program do have a meaning, they are not there just
for obfuscation. The preprocessor is used to keep the program
small, in fact, everything is a macro. Are you familiar with
the GIF format? Studying this program will give you a (very
little) insight.

Questions:
----------

After analyzing the source code, try to answer these questions:
1. How can you add a further supported symbol?
2. Can you alter the look of the output characters?
3. What limits the number of input characters to 42?

Portability:
------------

The program uses posix threads (using the linker flag -lpthread).
The program accepts email addresses not longer than 42 bytes
composed from letters, digits, and the @._- symbols. An address
not obeying these rules will cause undefined behaviour.  The
program is not expected to depend on endianness.  The standard
output is used for a binary output, which might cause problems.
To avoid most caveats, the program does not output the octet
0x0a.  The program assumes the use of ASCII.
# Best Game

Raphael Meyer
US

## Judges' Comments:

### To build:

        make meyer

### To run:

        ./meyer

For your first input try:

        a 0 1

This entry turns a newspaper solitare puzzle into a competition
with the computer to be the last one moving.  The object of this
source code is to determine the object of this source code!  :-)

## Selected Author's Comments:

I wanted submit a fully object-oriented entry to show that
object-orientated code:

  1. is ridiculously bloated
  2. is unreadable
  3. isn't WYWIWID anymore

But I just totally failed. No, I didn't fail in showing any of
the points above. Before I even had the chance to prove any of
these claims, (1) already brought me to my knees. The code got
so much bloated up, that I missed the size limit by a few hundred
bytes. Therefore, I broke the only rule in this contest, I think
you shouldn't break in any case: Rule Nr 2, The size of ...

The degree of claim (2) actually depends on the compiler. As I
_manualy_ compiled it from [a generic object-oriented programming
language] to C, it didn't just end up unreadable, but awfully
messed up, i.e. obfuscated.

As it is already (pre)compiled to C, you could also call it an object-
disoriented progam.

Comparing this progam to a potential object-oriented implementation,
it is obvious, that object-oriented code isn't WYWIWID (what
you write is what it does). It may be tempting to think that

        Object o;

might do something similar as

        struct not_an_object o;

But this program reveals that it doesn't. Even worse, this program only
reveals the tip of the iceberg, what kind of black magic is involved in
a simple declaration of an object.

A few things you can explore about object-orientation in this program
include:

  - constructors (invoked by the new operator)
  - new operators (every class gets its own new operator at compile time)
  - virtual method tables
    (all the virtual method tables have been combined to a single vtable)
  - runtime method binding
  - inheritance and polymorphism

It is left as an exercise to the reader to find a corresponding
implementation in a popular object-oriented programming language.

### Starting the game

        ./meyer [SEED]

### Gameplay

It is a sudoku based game. The goal of the game is to be able
to do the last valid 'move'.

On your turn you have to set a free cell to a value between 1 to 9 without breaking the following rule:

any number must be unique in its
    1. row
    2. column
    3. 3x3 block.

Expected input for your move:

        row column number

where

        row:    [a-i]
        column: [0-8]
        number: [1-9].

The game can be aborted with 'q'.

The one who can do the last move wins the game.
# Most Portable Chess Set

Oscar Toledo
Av. Santa Cruz del Monte 9-304
Ciudad Satelite. Edo. de Mexico
CP. 53110
Mexico

## Judges' Comments:

### To build:

        make toledo3

NOTE: You may have to alter the paths suitably, and you do need X. Modify the makefile as needed.

### To run:

        ./toledo3 1

It's pretty obvious from looking at it what this program does,
since it's clearly spelled out in the code.  The interesting
question is whether this is easier or harder to understand than
the code for Deep Blue.

## Selected Author's Comments:

There are so many text-based chess programs, what is that of
A1, H5, C4, D5?  The queen is really pointing to the king?

So I managed to do a graphical X11 chess program (WYSIAIE, or
What You See Is An IOCCC Entry), point'n'click to move pieces
is the only required action, and of course the command-line
options:

        ./toledo3        Two-players mode
                                (useful if you don't have a board at hand)
        ./toledo3 1      Human white - Computer black, level 1 (fast)
        ./toledo3 2      Human white - Computer black, level 2 (medium)
        ./toledo3 3      Human white - Computer black, level 3 (slow)
        ./toledo3 1 b    Human black - Computer white, level 1 (fast)
        ./toledo3 2 b    Human black - Computer white, level 2 (medium)
        ./toledo3 3 b    Human black - Computer white, level 3 (slow)

The computer will check that your moves are legal, full legal
chess moves are allowed, except minor promotions on human side.

The game will continue up to its logical conclusion, you make
a mistake and the computer surpasses you. ;)

### WHAT ABOUT THE ENGINE

Uses an alpha-beta search up to a depth of 3+level ply, extended
with quiescence search, that helps playing strength, something
around 1500 ELO (level 1) to 1700 ELO (level 3)

It searches the board and generates moves for each piece located,
a lot of comparisons are used for empassant, castling and
promotion. Would be faster with optimizations, but that
optimizations use valuable IOCCC characters.

It plays a different game every time, using the C library random
number generator.

Because it is resource-hungry, I strongly recommend to compile it
using maximum optimization, on GCC you can use:

        gcc -O3 -fexpensive-optimizations prog.c -o prog -lX11


### KNOWN "FEATURES"

1. Because this is my second X11 program (the first was
   point'n'click happy face), I added sentences everywhere
   until it worked. :)

2. It is portable to Wind*ws (using the supplied layer.c file)
   Change #include <X11/Xlib.h> to #include "layer.c" and
   use a Wind*ws compiler (only tested with Dev C/C++ 4.9.9.2)
   The play level is fixed, though you can change it easily.
   Of course, this is an example of an obfuscated Wind*ws
   program (there exists another way of write them?)

3. It will give warnings on compilation, so you can be sure
   that your compiler works.

4. It will not update the window while it is "thinking"

5. The space character has many useful applications, specially
   when it comes about the character limit. 8)

6. I still don't understand what to do after semicolons. :P

### CHALLENGES

It is possible to convert this code into Javascript with a
graphical interface.  Can you do it?

Can the evaluation function be enhanced to make the program
play stronger?

### UPGRADES

Using toledo3-sbar.c (which is too large for this IOCCC size
rules) creates a status display about gameplay on the window title bar,

Using toledo3-txt.c turns this into being purely text based.
# Best of Show

Oscar Toledo
Av. Santa Cruz del Monte 9-304
Ciudad Satelite. Edo. de Mexico
CP. 53110
Mexico

## Judges' comments:

### To build:

        make toledo2

### Try:

        cp C.BASIC C
        ./toledo2

We're impressed! Last year, it was a 6502 emulator; this year,
it's 8080!  It requires an input file ("C") to be present, but
it does not have to be one of C.BASIC or C.BIOS - you're welcome
to write a standalone 8080 program yourself! How about C.FORTH
or C.LISP?

In addition to the functionality you could expect from a program
of this size, it allows importing files from the host file
system (one by one, so you'll have to be patient).

Remember the good old days and play (or let your kids play)
Adventure (in the directory ADVENTUR within the KAYPROII.ZIP
file referred in the author's comments); walking in a maze of
twisty little passages all alike is easier than understanding
the code!

## Author's comments:

This program emulates a complete Intel(r) 8080
processor, along with a teletype and a disk
controller, just like at the start of the personal
computers revolution (circa 1975).

It needs an initial memory image to do something
usable, so along it you will find two files
(C.BASIC and C.BIOS). Rename C.BASIC to C and run
the emulator, and et voila! you have the public
domain Palo Alto Tiny BASIC (by Li-Chen Wang),
published on the very first volume of Dr. Dobb's
Journal.

Type using uppercase letters, here are three example
programs, press Enter after each line:

        10 PRINT "Hello, world!"
        LIST
        RUN

        10 FOR A=1 TO 10       10 INPUT A
        20 PRINT A             20 INPUT B
        30 NEXT A              30 PRINT A+B
        LIST                   LIST
        RUN                    RUN

Press Ctrl+Z to quit, by the way, the segmentation fault is
normal at this point.

All good programmers started learning BASIC, now, what about a
CP/M emulator?

Download the following file (not included because of possible
copyright and blah, blah):

> <http://www.retroarchive.org/cpm/os/KAYPROII.ZIP>

Extract CPM64.COM from the SOURCE directory, and copy it to
files named A and B (these will be the disk drives). Now rename
the provided C.BIOS to C and run the emulator.

Now you have a running CP/M system!, with two files on A: drive,
HALT.COM to stop the emulator (so it closes drives) and IMPORT.COM
to introduce new files.

To get a complete CP/M system, you will need the following files
from the KAYPROII.ZIP, SOURCE directory:

        ASM.COM  DDT.COM   DUMP.COM   ED.COM   LOAD.COM
        PIP.COM  STAT.COM  SUBMIT.COM XSUB.COM

To import them, you must run the emulator with an argument, by
example:

        prog DDT.COM

When the A> prompt appears, do:

        IMPORT DDT.COM

When it ends, do HALT, so the file is saved, and you can start
the same process with another file.

At this time I have tested successfully the following software
from retroarchive.org:

> <http://www.retroarchive.org/cpm/lang/c80v30.zip>
> <http://www.retroarchive.org/cpm/lang/Mbasic.com>
> <http://www.retroarchive.org/cpm/business/MULTPLAN.ZIP>

Some programs requiere installation to configure the terminal,
locate ANSI or VT-100.

### What is an 8080?

It is simply the little brother of the Z80, it has no extended
registers (AF', BC', DE', HL', IX or IY), no relative jumps,
and every instruction beginning with CB, DD, ED or FD doesn't
exist.

The flags are only S (Sign, bit 7), Z (Zero, bit 6), P (Parity,
bit 2) and C (Carry, bit 0).

### Porting it

It is easy if your platform has getch/kbhit and
ANSI terminal

        read    -->  Z=kbhit()?getch():0
        write   -->  putchar(7[o])
        system  -->  nothing

Also add the following to trap Ctrl-C:

        #include <signal.h>
        signal(SIGINT, SIG_IGN);

On PC/DOS you need to add ANSI.SYS to CONFIG.SYS

In *NIX the min 0 on stty is required, circa 2001
it was not required.

.
.
.

### How it works (SPOILER)

.
.
.

The l array contains the 64K memory, it is initialized with a
boot image loaded from the 'C' file, the program counter is the
c pointer, and regitser are on o[]. The main loops reads every
op-code and separates it in one of three common forms, a lot
of trinary operators selects the instruction.

        o[0] = B register   o[1] = C register
        o[2] = D register   o[3] = E register
        o[4] = H register   o[5] = L register
        o[6] = Flags        o[7] = A or accumulator

The following instructions do peripheral operation:

        76           Quits emulator
        DB 00        Reads key pressed status
        DB 01        Reads key
        DB 02        Reads byte from file (Carry=EOF)
        D3 xx        Writes byte from acc. to console
        ED ED 02     Reads sector
        ED ED 03     Writes sector

Memory addresses:

        FBFA = Low source/target direction
        FBFB - High source/target direction
        FBFC - Sector
        FBFD - Low cylinder
        FBFE - High cylinder
        FBFF - Drive.

The BIOS is tailor made for this emulator, and helps to simplify it.

Other notes:

- The 8080 runs at your computer speed divided
  between a number that I have not calculated.
- This obfuscated processor is created using
  obfuscated code produced by an obfuscated mind,
  no brains were harmed during its production,
  except those that tried to read the code.
- The original version of this code was eated
  by my C++ dog.
- I intended to make it simple to understand,
  it uses only four C keywords.
- Also I discovered that braces are very useful
  for commenting.
- Why to bother with prototypes?, every good C
  programmer can develop its C programs using
  only one function.

# Best One Liner

Stephen Sykes
Itinen koulupolku
Kauniainen
Finland
<http://www.stephensykes.com>

## Judges' Comments:

### To build:

        make sykes2

### To run:

        ./sykes2

Then "Lather, rinse, repeat":

        while :; do
                clear
                rm -f sykes2
                make sykes2
                ./sykes2
                sleep 1
        done

If you have the time, figure out how this small 1-line entry works!

## Selected Author's Comments:

At 130 characters of C code (without the newline at the end), this
should fit into the "1-liner" category.

The clock numerals are rendered as an old fashioned 7 segment display.
The encodings for which segments light for which number, and for where
each segment appears on screen are hidden in the two strings.

When reading the program, you may want to refer to a table of
operator precedence - careful choices were made to keep the usage of
brackets to a minimum, and to keep the character count as low as
possible.

One interesting bit of obfuscation - the null at the end of the second
string actually forms part of the lookup table.

Intel CC warns about the lack of a declaration for the argument to main.
(gcc does not notice this though, even with -Wall.)  But anyway it can
easily be declared as int at the expense of 4 more characters.

I'm not sure of the effects on a hard disk of rewriting the same file
multiple times per second for a long time.  Run at your own risk!
2006 marked the "The Nineteenth International Obfuscated C Code Contest"
========================================================================

Copyright (C) 2006, Landon Curt Noll, Simon Cooper, and Leonid A.
Broukhis. All Rights Reserved. Permission for personal, educational
or non-profit use is granted provided this copyright and notice are
included in its entirety and remains unaltered.  All other uses
must receive prior permission from the contest judges.


Standard IOCCC stuff
--------------------

The IOCCC has a web site and now has a number of international mirrors.
The primary site can be found at,

>	<http://www.ioccc.org/>

Use make to compile entries.  It is possible that on non-Un*x / non-Linux
systems the makefile needs to be changed.  See the Makefile for details.

Look at the source and try to figure out what the programs do, and run
them with various inputs.  If you want to, look at the hints files for
spoilers - this year we included most of the information included
by the submitters.

Read over the makefile for compile/build issues.  Your system may require
certain changes (add or remove a library, add or remove a #define).

Some ANSI C compilers are not quite as good as they should be.  If
yours is lacking, you may need to compile using gcc instead of your
local compiler.


Remarks on some of the entries
------------------------------

There were some outstanding entries that did not win.  Unfortunately
some very good entries lost because they:

+ depended too much on non-portable side effects in expressions;

+ depended too much on a particular byte order;

+ required the use of a special script, data file or pseudo-machine
  language that was not supplied with the entry.

We hope the authors of some of those entries will fix and re-submit
them for the next IOCCC.

We believe you will be impressed with this year's winners. The Best
of Show is a fine example of (retro) obfuscation.  But don't ignore the other
winners!  There are games, puzzles, puzzle solvers, simulators, emulators,
calculators and graphical and audio tools.

This year a single person won three awards and another two awards!  Many
winners won for the first time. (Please note that judging is done completely
anonymously.  Be warned that we may disqualify entries that reveal the identity
of the submitter).

Final Comments
--------------

Please feel free to send us comments and suggestions about the
competition, this README or anything else that you would like to see in
future contests.

If you use, distribute or publish these entries in some way, please drop
us a line.  We enjoy seeing who, where and how the contest is used.

If you have problems with any of the entries, AND YOU HAVE A FIX, please
send us the fix (patch file or the entire changed file).

For the latest information on how to contact the IOCCC Judges please visit

>	<http://www.ioccc.org/contact.html>

For news of the next contest watch:

>	<http://www.ioccc.org/>

# Best Abuse of Computation

Christopher Night
Harvard University
Department of Astronomy
Cambrige MA 02238
US
<http://www.people.fas.harvard.edu/~night/>

## Judges' Comments:

### To build:

        make night

### To run:

        ./night

You'd never guess, from looking at the code, that there is a
genetic algorithm involved.  Somewhere.  But what does it do?
Well, it might take you a while to navigate the results, let
alone the code.

## Selected Author's Comments:

Don't worry; this is not a self-reproducing program, as you might at
first guess from the layout. I would never be so foolhardy as to
submit an entry on an over-used theme!

Oh, wait a second... it is a maze-generating program. Oops!

### What it does:

This program solves an optimization problem, namely, generating a
challenging maze. It uses a very simple genetic algorithm: a maze
layout's DNA is represented as a 32-bit integer, and mutations consist
of flipping three different bits. The algorithm is simple in that it
doesn't employ sexual reproduction, only mutations, and it has a
population size of 1. So much for diversity!

This particular optimization problem, I believe, has a unique maximum:
there is but one maze out of 2^32 that requires 64 moves to solve. The
program will run until finding this global maximum, or if you get
bored, you can accept a sub-optimal solution by pressing any key. On
my system, it takes an average of 15 minutes to find the maximum,
whereas a random search would take an average of 3.5 days.

Should you take my word for it that the maze it generates requires as
many moves as I say it does? The answer is yes. But if you're not
convinced, you can try to solve it yourself. The goal is to traverse
from the upper-left to the upper-right and out the top, where the
number of moves remaining is printed. Use the arrow keys for suckers
(w, a, s, d) to move around. q quits and r restarts. Also, the maze
changes as you move through it, in a predicatable way. It should be
easy enough to figure out the pattern. For best results, use a display
with bold-text capabilities and color.

Finally, in the world of DNA, the medium is truly the message. There's
a short message encoded in here that will only appear when you
complete the optimal maze in the required 64 moves.

### Issues:

These depend on your compiler, and they were all intentionally
added for obfuscation purposes. No, really!

My compiler warns of nulls in a string literal, and the redefinition
of the macro T.

On one compiler, compilation took about two minutes.

`sizeof(unsigned short)` must be 2, and `sizeof(unsigned long)` must be 4.

CLOCKS_PER_SEC is assumed to be 1000000. If it's a lot less than that,
expect delays.

### Algorithmic obfuscation:

The representation of the maze layout in a 32-bit integer type is
pretty opaque. As a hint, the optimum layout's DNA is, in base 4,
2102231031201230. Try getting from there to the maze that appears on
screen.

The recursive function CGAC replaces a nested for loop in a handy way.

The maze-solving function TGA returns no solution both if no solution
exists, and if the search space grows too large, with a single test.

### Stylistic obfuscation:

Four-letter alphabets are confusing. I don't know how ribosomes
manage.

Overloaded symbols, such as G and G().

Who needs != when you've got ^?

Who needs if when you've got while?

For that matter, who needs fixed-iteration-count for and while when
you can just duplicate code with the preprocessor? Duplication by this
macro causes one particular graphics line to be replicated 512
times. On my system the preprocessed code is over 80KB in length,
hindering the preprocessor's ability to deobfuscate.

Keypad support was removed to save space. To restore, modify the
following two macros to:

        #define ATG srand(time(0)); initscr(); cbreak(); noecho(); start_color(); keypad(stdscr,1);
        #define AGG A&2?KEY_UP:KEY_DOWN:A&1?KEY_RIGHT:KEY_LEFT

Code on!
# EDAMAME Award
# (Electronic Design Automation - Mechanical Abstract Machine Emulator)

Michael Birken
US
o__1 at hotmail dot com

## Judges' comments:

### To build

        make birken

Try:

        ./birken < counter.tofu

What is TUFO?  It's not a veggy friendly food, nor it is Verilog or
VHDL.  It is not even Pascal!

NOTE: On some systems, file(1) claims one of the .tofu files is Pascal
source. :-)

It may not be the most readable hardware description language, but it is
one of the easiest 55 page long manual to learn.  :-)

For a small but non-trivial design, try implementing a
[Linear Feedback Shift Register](http://en.wikipedia.org/wiki/LFSR)

And for those who are still confused:

> <http://en.wikipedia.org/wiki/Edamame>
> <http://en.wikipedia.org/wiki/Tofu>

## Author's comments:

If man is capable of creating tofu hotdogs (simulated meat), then why
not tofu circuitry (simulated circuits)?  This program is my tribute to
the early computer pioneers like Konrad Zuse.  It's an educational tool
designed to introduce students to digital circuit theory using
technology that was considered state of the art in the 1940's!  To
enable you to fully understand the capabilities of this circuit
simulator, I have included a 55 page manual (info.pdf) in the info
portion of the entry submission.

The primary obfuscation is the data structure chosen for parsing the
input file and for executing the simulation.  Oh man...  coding that
data structure gave me such a bad headache.  But, I figure, who needs
more than a pair anyway?  Subtle obfuscations abound.  Bonus points go
out the one who discovers the hidden program within the source.

Note that the shape of the source is a wave, not a waveform.
# Best solved puzzle

Shinichiro Hamaji  
<shinichiro.hamaji@gmail.com>  

bsoup  


## Judges' comments:
### To build:

    make hamaji

### To run:

    ./hamaji < a_nonogram_file

### Try:

    ./hamaji < dragon.nono
    ./hamaji < random.nono
    ./hamaji < soccer.nono
    ./hamaji < codegolf.nono
    ./hamaji < face.nono
    ./hamaji < penguin.nono
    ./hamaji < samurai.nono

### Selected Judges Remarks:

This program solves "Nonogram", which also known as "Paint by Numbers":

<http://en.wikipedia.org/wiki/Nonogram>

This entry roar as the Year of the Dragon: A year considered
some to be good luck.  Well it was certainly true that the
IOCCC was lucky to get such a fine submission!

The source code is a solution to a Paint by Numbers puzzle when you
paint by C.  Try your hand at solving a few of the other .nono
files and then compare your solution with this program!

NOTE: NONOGRAM (r) is a registered Trademark and is used with permission.
      See http://nonogram.com/ for more information.

## Author's comments:
The format of the input files are as same as this site:

<http://codegolf.com/paint-by-numbers>

For example, for a simple problem which shows a glider of [conway's
lifegame](http://en.wikipedia.org/wiki/Conway's_Game_of_Life).

       1
       .
      112
    
    1  X
    1   X
    3 XXX

the input should be

    1
    1
    3
    -
    1
    1.1
    2

The width and the height of an input puzzle should be less than or
equal to 60.

When this solver finds the problem has no solution, it prints "invalid".
This means the problem is indeed broken. For example, this happens for
an input like

    2
    -
    2

When this solver cannot find a solution, it prints "failed". This
failure can happen when the problem has more than one solution or the
solver cannot solve the input problem. Here is an example input of the
former:

    1
    1
    -
    1
    1

There are two solutions:

      11
    
    1 X 
    1  X

and

      11
    
    1  X
    1 X 

### Detail

Solving Nonogram is known NP-complete, so we cannot make a solver
which solves all puzzles. However, we can write a solver which solves
most problems solvable by humans. There are a bunch of ways to write
such programs. The two most obvious approaches are:

1. Check all possible solutions with backtracking.
2. Implement all techniques which humans use.

The former, brute-force approach is easy to implement. However, it
works only for smaller problems (width and height should be at most 30
or so). Similarly, using generic probabilistic metaheuristics such as
simulated annealing doesn't work for big problems.

<http://ccl.northwestern.edu/netlogo/models/community/Nonogram>

By its definition, the latter works for all human-solvable
problems. The issue of the latter approach is this kind of programs
tends to be lengthy. This approach still requires some recursions. The
most difficult problems which are considered human-solvable may
require some "guesses". For this kind of problems, we need to assume a
cell is a space or a box, go ahead some steps with simple methods,
mark the tried cell as a box (or a space if we assumed the tried cell
is a box) if a contradiction is found.

My program uses an approach like "Set based solver" introduced in
[http://www.haskell.org/haskellwiki/Nonogram](http://www.haskell.org/haskellwiki/Nonogram) .
This should be equivalent to the combinations of simple methods (no
advanced reasoning with guess). My solver also runs non-recursive
guess for each undetermined cells. So, my program should be able to
solve most human-solvable problems (assuming humans cannot execute
deeper recursions).

### Obfuscation

First of all, as you see, my program looks like a nonogram puzzle
which results a dragon. This puzzle is "dragon.nono" in this
directory. Note that whitespaces in character literals, a string
literal, and around the last comment are considered as a boxed cell.

My program is based on bit operations for speed. Many values are
stored using negative logic (0 means on and 1 means off) to utilize
the initial value of global variables. Thus, it might be difficult to
figure out how it works.

My program is decently shortened, because the size of source code is
limited by IOCCC's rule (2048 non-whitespace characters) and a lot of
characters are just wasted for numbers around the picture.

The three requirements (dragon, speed, and size) naturally ended up
with the well obfuscated code.

### Portability

This program uses two C99 features. One line comments and "long long".
GCC's "-ansi -pedantic" check should pass:

    $ gcc -ansi -pedantic -std=c99 hamaji.c

I checked my program with gcc-4.6.2 on linux, llvm-gcc-4.2 on mac, and
clang-3.0 on mac.

Note that the behavior of scanf differs on linux and mac, but this
program supports both semantics.

This program should not depend on sizeof(int), sizeof(void*), ASCII,
memory layout, undefined evaluation order (e.g., a[i++]=i), etc. 
This program won't work if the size of long long literal is less than 8.
By grepping the source code of gcc

    grep LONG_LONG_TYPE_SIZE gcc/config/*/*

I found long long may be 32bit integers only on AVR.

### A few more

This code is considered as a new year's postcard in Japan. We chose
the dragon because 2012 is the year of dragon.

<http://en.wikipedia.org/wiki/Japanese_New_Year#Postcards>

The second author wrote the picture, and the first author did
everything else.

The dragon.nono, samurai.nono, and penguin.nono was written by the
second author.  The soccer.nono was from a wikipedia entry.  This file
is important because it requires some guesses.  The random.nono file
was randomly generated. The codegolf.nono and face.nono have borrowed
from this site:

<http://codegolf.com/paint-by-numbers>

You can reproduce dragon.nono from hamaji.c using c2nono.pl:

    perl c2nono.pl hamaji.c | ./hamaji

--------------------------------------------------------------------------------
<!--
(c) Copyright 1984-2012, [Leo Broukhis, Simon Cooper, Landon Curt Noll][judges] - All rights reserved
This work is licensed under a [Creative Commons Attribution-ShareAlike 3.0 Unported License][cc].

[judges]: http://www.ioccc.org/judges.html
[cc]: http://creativecommons.org/licenses/by-sa/3.0/
-->
# Most sound

Daniel Vik  
802 Durshire Way  
Sunnyvale, Ca 94087  
<daniel@vik.cc>  
<http://www.danielvik.com>  


## Judges' comments:
### To build:

    make vik

### To run:

    ./vik file.mod > audio_file.raw

### Try:

    ./vik randowan.mod | mplayer -demuxer rawaudio -
    ./vik mad_world.mod | mplayer -demuxer rawaudio -

Alternatively, you can use

    ./vik file.mod > file.raw; ./raw2wav file.raw > file.wav 

It is possible to download a number of Mod files from [The Mod Archive](http://modarchive.org).

The randowan.mod and mad_world.mod files were created by
[Henrik Bertilsson](http://www.translucentboy.com) and
are included with his permission.

### Selected Judges Remarks:

This entry converts .MOD audio files to a playable stream
in a most pleasing manner if you don't like tremolo or vibrato.

Also it abuses the C compiler and/or assembler with a partially
initialized 32 MByte array.   Can you tell what is that partial
initilzation for?

Does it take your system a long time to compile?  You may want to do try:

     cc -S vik.c

and to examine the resulting assembly file vik.s.  On some platforms
the assembly file is about 128 MBytes in size!

## Author's comments:
Introduction
============

In 1987,  Karsten Obarski changed the way music was handled in games and
demos with the introducton of the MOD file format on Commodore Amiga.

A MOD file contains a set of samples,   a number of patterns  indicating
how and when the samples  are to be played,   a list of what patterns to
play in what order, and a number of effects.


Features
========

This program converts MOD files  created  with the standard trackers for
Amiga,  e.g. Pro Tracker,  Noise Tracker and Sound Tracker to raw 16 bit
44.1kHz stereo audio.   The program  supports MOD music with 4, 6, and 8
channels MOD files with up to 31 samples.

The MOD format includes  many effects  for each  audio channel  and this
program supports most of them, including:

  * Arpeggio
  * Slide and fine slide up/down/to note
  * Set sample offset
  * Volume slide
  * Pattern break
  * Filter on/off
  * Set volume
  * Cut sample
  * Delay sample
  * Delay pattern
  * Set speed

Due to size constraints tremolo and vibrato is not supported.   Also, to
avoid infinite long songs, the position jump feature is ignored.


Songs
=====

With his permission, the package incldues two songs composed by Henrik
Bertilsson, also known as Deelite:

  1. Mad World
  2. Randowan


Build
=====

Compiling for *nix systems (including cygwin) is straight forward:

    $ gcc -o vik vik.c


Usage
=====

### Convert MOD file to raw 44.1kHz stereo audio file

    $ ./vik mad_world.mod > audio_file.raw

### Listen to the MOD file (streaming to mplayer)

    $ ./vik randowan.mod | mplayer -demuxer rawaudio -

(Don't forget the last '-' as it makes mplayer read from stdin.)


Obfuscation
===========

The IOCCC rules did not put a limit  on the entropy of the  source code,
and it appears that the general entropy rules doesn't apply. An estimate
is that the code density entropy of this entry is ~1.2 which means  that
there are around 2500 characters of code carrying information, yet there
are only 2037 IOCCC characters of actual code.    Most of the additional
characters are  encoded with  non-counting characters  in the  frequency
table.   But there are also ~50 or so  white space characters spread out
through the source code that carry information.

The use of macros  certainly adds  to the obfuscation but the reason for
using them is mainly to fit as many features as possible within the size
limits. So please excuse the use of them.

Once the preprocessor is run,  the code gets more interesting.   The MOD
player is basically a register based state machine and all the magic  is
hidden in a fog of short statements.   Many of the register  updates are
conditional  and the program  uses the ? operator (sigh) mainly  to save
space,   but also to leverage  the comma operator  and  precedence  more
efficiently.


Portability
===========

The progam is portable to most platforms.  The only system dependency is
that the program relies on writing binary data to stdout.

Microsoft compilers adds a carriges return to newlines,   and to compile
the program with this platform,   the following line  can be added after
the main declaration in order for the program to run correctly:

    _setmode(_fileno(stdout), 0x8000);


Limitations
===========

The program  only runs when  a valid  MOD file is passed as argument. If
no argument is passed, the program crashes.

--------------------------------------------------------------------------------
<!--
(c) Copyright 1984-2012, [Leo Broukhis, Simon Cooper, Landon Curt Noll][judges] - All rights reserved
This work is licensed under a [Creative Commons Attribution-ShareAlike 3.0 Unported License][cc].

[judges]: http://www.ioccc.org/judges.html
[cc]: http://creativecommons.org/licenses/by-sa/3.0/
-->
# Best non-chess game

Oscar Toledo G.  
Av. Sta. Cruz del Monte 9-304  
Cd. Satelite. Edo. de Mexico.  
CP. 53110. Mexico.  
<biyubi@gmail.com>  
<http://nanochess.110mb.com/>  


## Judges' comments:
### To build:

    make toledo

### To run:

    ./toledo

    # NOTE: This requires X11 to run or modifications to use layer.c on
    # Windows

### Try:

    ./toledo

### Selected Judges Remarks:

This two player game uses X11. The control keys can be configured by
modifying the A,B,C and D macros at compilation.

After a quick splash screen the objective should be clear.  There
are Red, Green and Cyan tanks. A larger window can be made by altering
the source early on, right before the code gets hard to follow.

Like Oscar's previous winning X11 program for the 19th IOCCC, if
you remove both the X11 include files and replace them with

	#include "layer.c"
	
you ought to be able to compile and run this program on Windows.

## Author's comments:
        /=========\                 
        \==\   /==/                ||
           || ||   /====\  |\/=\   ||      //==\   ==\ |=\
           || ||       ||  ||  ||  ||  //  ||       =| | |
           || ||   //===|  ||  ||  ||=//   \\=\\   ==/ |=/
           || ||   ||  ||  ||  ||  || \\      ||   User's
           \===/   \\==//  ||  ||  ||  \\  \==//   Manual

This  is a color X11 3D tank-game for two players, just compile
and run it without arguments.

You will see briefly a tank spinning before each level.

Left  half  of  the  window shows the red player view and right
half shows the green player view, the background will change to
blue when the view goes inactive.

The  objective  is to chase and destroy the other player's tank,
there  is  also  an  aqua tank for testing your aim and getting
extra points.

> Caveat: You can shoot only 3 bullets at a time.
> Trick: You can fire faster if they explode on anything.
> Believe it or not, it has strategy!

When only one tank remains on the field, the level will advance.
Don't forget to destroy the aqua tank.

The  playground  is  surrounded by mountains  and each level is
filled with random obstacles (pyramids and cubes).

The  bars  show players energy and score, each bar shows energy
and  indicates  current  player view (wider on the left), right
part grows with every point.

Keys for player 1 (lowercase):

* Tab - Fire
* w   - Go ahead
* s   - Go backwards
* a   - Turn left
* d   - Turn right

Keys for player 2:

* Backspace   - Fire
* Up arrow    - Go ahead
* Down arrow  - Go backwards
* Left arrow  - Turn left
* Right arrow - Turn right

> Note: Numeric keys don't work. 

If you don't like the keys assignment, you can change it on the
the makefile.

PARENTAL ADVISORY WARNING:
--------------------------

This  game  is  highly  violent, when the tank explodes you can
see the little stick man blowing in parts.

Not really, just kidding :D

PLATFORMS TESTED:
-----------------

* openSuSE 10.2 x86-32, X11R6 1024x768 32-bits color.
* Fedora Core 8 x86-64, X11R6 1280x1024 32-bits color.
* Fedora Core 11 x86-64, X11R6 1024x768 32-bits color.
* Fedora Core 14 x86-64, X11R6 1024x768 32-bits color.

COMPLETE FEATURE SET:
---------------------

* Multiplayer out of the box.
* Totally self-contained, no external files.
* Fast-furious action at 29.97 frames per second.
* Just as the movies, 16:9 aspect-ratio.
* Beautiful mountains landscape plus horizon line :)
* Tanks and bullets exploding as wires with weird physics.
* Tanks backoff when firing.
* There is an infinite number of levels.
* Always different levels.
* Animated intro.
* It has color!.

FEATURES THAT PROGRAMMERS WILL FIND APPEALING:
----------------------------------------------

* Works both with x86-32 and x86-64 processors.
* Double buffered, portable to any X11 with 24/32-bit color.
* Memory-hungry  as  must  be  any 3-D program, uses a 256 MB
  array.
* Total and absolute irreverent coding style, so it generates
  a lot of warnings when compiled.
* It  can  take  several  minutes  to compile (known culprits:
  Fedora Core 11-14 on x86-64 512 MB)
* It is written in the only true C: K&R, and no, it not means
  Katherine & Rose.
* Vectorial   scalable   graphics,   do  you  want  a  bigger
  playfield? change variables M & N.
* Half  of  the  program  is formatted as 3-D cube, view with
  Tabs  at  8  columns  and a square font.
* The  other  half  of the program is unprintable source code,
  so  no  typing from paper, you have to write a converter of
  tabs and formfeeds to its C escaped forms.
* No  text, so this program can be used and understood easily
  on any country.
* This  program  is highly ecologic, it sleeps when it is not
  doing anything.
* Virtual world with its own physics laws.
* When closing the window it will show an X11 error :P

OBFUSCATION TRICKS:
-------------------

* Loop code included inside loop test.
* Function arguments used as variables.
* Operators used freely.
* Precalculated values to save bytes.
* Uses the +++, +- and *+ undocumented C operators :P


                                       ....,,,,---++++++--,,..                        
                     .,,,.......     .$@@@@@@@@@@@@$$@@@@@@@@@@@@@@#+                 
                     @@@@@###@@@@$$$@@@@$$$@@@-......-@+......,,,,,,##                
                     =++==++++++++=@@$==#$$$$$---,,,,@@@,,,,,,-------@@,..........,,. 
        ,===#$$$$$$###$####=======@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@+=##$@@@@@@@@.
        +@,,++++++++=+=========++++===++++++++++-+++@@-,,,,,,,,---+++=++++--,,...   @.
        .@.                      .......,,,,-----++=@=++==@$=+--,,...               @.
         $#         S P O I L E R              .,,-#@--,,,@$.....                   @.
         .@                           ..,--+==++-,,,,.,,,,=@+++++====+++++---,,,....@.
          @+                ..,,-+++++++-,,..              @.         ....,,,,,---+@@ 
          ,@       ..,--+++=+++,,..                        $#                   .==+  
           @#--++==++-,,..                                 ,@  S P O I L E R  .==+    
           ,#@@$+,,.                                        @.               ==+      
               .,,+++++,,.            S P O I L E R         $=             +=+        
                     ..,-==++-,.                            ,@           ---          
                            .,-+=+++,..                      @.       .++-            
                                  .,,++=++-,.                @+      ==+              
                                        .,-++==+-,.          +@    ==+                
                                              ..,+++=+-,..   .@. +=+                  
                                                     .,-+++++,@@==                    

THE HISTORY OF THIS PROGRAM:
============================

When I started working on this program, I figured that it would
be  easy  to  fit  on  the  character limit, but I missed three
things,  the enormous X11 names, the unportable keycodes and my
2 KB of artwork.

Very  hard  coding  did  the  first thing, in fact I worked out
twenty-nine  different  versions,   at  one  step  I  had  four
parallel   versions   with  different  characteristics  removed
(mountains,  horizon  line,  score/status  bars and explosions),
I've managed to fit it all together!. 

The  second  thing was solved using the makefile,  it  is under
160  bytes  and  you  get  adjustable  keyboard.  The  greatest
mistery  on the earth is why X11 handles unportable keycodes to
the user.

And  finally,  the  third  "Thing" was growing and growing, and
growing,  eating  bytes  for  lunch...  after endless rounds of
crunching  I  obtained  three-hundred  seventy-eight  bytes  of
artwork and guess what?, it doesn't fitted.

So  I  had  to  integrate  a  decompressor,  based on the space,
tabulators and other non-counted characters.

The  final  program is composed of eight microfunctions, one is
the  core  and does most of the hard work, other functions help
doing  the  X11 things, explosion effects, 3-D calculations and
viewing.

* K()    - 3-D transformation
* s()    - Rendering
* b()    - Line color selection
* G()    - Explosion animation
* g()    - Moves 3-D object backward and forward
* F()    - Collision detection
* T()    - Core (also known as main loop :D)
* main() - Initialization and uncruncher, what a common name!,
           C programs should start in the cool() function :).

The  source  code  was  formatted as an cube using a specially
written program, the reality is that the program is smaller and
obfuscated  of  what  is  needed  so  the  reformatting doesn't
exceeded  the  character  limits,  the  crunched  vectors  were
generated   by  another  special  program  and  the  tank  that
surrounds this text was generated by yet another program.

*Have fun!*


--------------------------------------------------------------------------------
<!--
(c) Copyright 1984-2012, [Leo Broukhis, Simon Cooper, Landon Curt Noll][judges] - All rights reserved
This work is licensed under a [Creative Commons Attribution-ShareAlike 3.0 Unported License][cc].

[judges]: http://www.ioccc.org/judges.html
[cc]: http://creativecommons.org/licenses/by-sa/3.0/
-->
# Best ball

Peter Eastman  
<peter.eastman@gmail.com>  


## Judges' comments:
### To build:

    make eastman

### To run:

    ./eastman

### Try:

    Quit the program.  Resize your terminal window.  Run it again.

### Selected Judges Remarks:

This round program will generate a classic spherical result!

You will need a terminal capable of displaying coloured ANSI
characters (for example an xterm or a Terminal.app window).

You might also want to turn off any scrollback history. The program will
size itself to the initial geometry of your terminal.

If you are ambitious, make the font really small and the window really
large for hi-rez graphics!

## Author's comments:
This program uses ANSI graphics to recreate the classic Boing Ball demo from
the Commodore Amiga.  See http://www.youtube.com/watch?v=-ga41edXw3A if you
aren't familiar with it.  Back in its day, this demo inspired lust and awe in
geeks around the world.

The graphics are raytraced, with procedural textures on the ball and the back
wall.  I did cheat a little to simplify the calculations: it uses a parallel
projection, but textures the back wall to look as if there were a floor being
viewed in perspective.  The shadow is also just part of the texture, not an
actual raytraced shadow.

This program automatically adapts to the size of the terminal it is running in,
so try enlarging the window to get higher resolution.  Don't resize while the
program is running, though.  It only checks the size once, when it starts up.

To compile:

cc -lm ball.c

Portability:

It should be completely portable.  I've tested with gcc on Mac OS X 10.7 and
Fedora 10.  I would expect it to work in any Unix-like environment.

Obfuscation:

I have merged expressions wherever possible, making extensive use of ternary
operators, commas, return values of assignment operators, etc.  The entire
raytracing computation, include ray intersection tests and procedural texture
evaluations, is a single expression involving 41 operators.

Variables are named alphabetically in the order they are declared.

The third argument to ioctl() should really be a "struct winsize", and I should
then look up the ws_row and ws_col fields, but that makes it way too obvious
what I'm doing there.  Since a winsize just contains four unsigned shorts, I
replaced it with an array.  And since all the values will be much less than
32767, I further simplified the type to just short[].

A wonderful thing about ANSI graphics is that it produces nearly unintelligible
code.  Consider the printf spec to print a single space in a desired color:
"\x1B[%dm ".  I could have done something to further obfuscate it, but it's
already indistinguishable from line noise, so why bother?

There are lots of other minor obfuscations to make the code less obvious.  For
example, I could have written the outer loop as while(1), but why write a 1
when I can calculate it from the return value of usleep() instead?  And I could
have written usleep(80000), but usleep(79383) just looks so much better.  And
so on.

--------------------------------------------------------------------------------
<!--
(c) Copyright 1984-2012, [Leo Broukhis, Simon Cooper, Landon Curt Noll][judges] - All rights reserved
This work is licensed under a [Creative Commons Attribution-ShareAlike 3.0 Unported License][cc].

[judges]: http://www.ioccc.org/judges.html
[cc]: http://creativecommons.org/licenses/by-sa/3.0/
-->
# Most self deprecating

David Lowe  
434 Tenney Drive  
Rogue River, OR  
97537  
<j.david.lowe@gmail.com>  
<http://www.pootpoot.net/>  


## Judges' comments:
### To build:

    make dlowe

### To run:

    ./dlowe -<n_iterations> corpus1/ [...] corpus0/ < start.net > end.net

	NOTE: The directory entries MUST end in a /

    ./dlowe file [file ...] < trained.net

### Try:

    Download the dlowe-aux-data.tar.bz2 file from:

    	curl -O http://www.ioccc.org/2011/dlowe/dlowe-aux-data.tar.bz2

    tar -jxf dlowe-aux-data.tar.bz2

    ./dlowe dlowe.c < ioccc-winlose-trained.net
    ./dlowe dlowe < ioccc-winlose-trained.net

    ./dlowe xor-0/00 < xor-trained.net
    ./dlowe xor-0/11 < xor-trained.net
    ./dlowe xor-1/01 < xor-trained.net
    ./dlowe xor-1/10 < xor-trained.net

    ./dlowe hint.html < english-trained.net

    ./dlowe dlowe-aux-data.tar.bz2 < png-trained.net

### Selected Judges Remarks:

This entry is a ghoulish example of a brain (dead?) neural network classifier.
It comes with a set of corpora for you to try.

#### ioccc-winlose-trained.net

You can create your own trained networks.  For example, we trained a network
on the C code of entries that were supplied to the 20Th IOCCC.

The ioccc-winlose-trained.net was trained using the earlystop.pl tool:

    rm -f ioccc-winlose-trained.net
    ./earlystop.pl ioccc-winlose-trained.net ioccc_won_training/ ioccc_lost_training/ ioccc_won_test/ ioccc_lost_test/

where:

    ioccc_won_training/
    	1/2 of C code of the 20th IOCCC winners (except for dlowe.c from 2011)
	plus 1/2 of the C code winners from prior IOCCC contests

    ioccc_won_test/
    	1/2 of C code of the 20th IOCCC winners (except for dlowe.c from 2011)
	plus 1/2 of the C code winners from prior IOCCC contests

    ioccc_lost_training/
	1/2 of C code from entries that that did not win

    ioccc_lost_test/
	1/2 of C code from entries that that did not win

    NOTE: The above directies were not shipped and the C code from
    	  entries that that did not win was flushed to /dev/null.

The earlystop.pl tool wrote:

    training 1 to 1001...
    training 1001 to 2001...
    prior error = 56.746974766043; current error = 58.095691135305

The resulting ioccc-winlose-trained.net file was included in the
dlowe-aux-data.tar.bz2 file in the above mentioned URL.

The dlowe.c was explicitly excluded from this trailing set.  So this test is interesting:

    ./dlowe dlowe.c < ioccc-winlose-trained.net

The match of dlowe.c to the lose/win trailed network was:

    dlowe.c 0.125108

NOTE: The non-artificially intelligent decisions of the IOCCC judges include random
      quirks and their non-linear judgment calls not found in the ioccc trained network.
      Just because C code is or isn't scored highly by this network does not
      mean it will win or lose a future IOCCC.  On the other hand ... it just might!

#### other data sets to try

While we cannot supply you with the losing IOCCC source code, the author did supply a number
data sets on which to test:

We created the english-trained.net as follows:

    ./dlowe -8000 english-1/ english-0/ < /dev/null > english-trained.net

	english-0/
	    Non-English (French) text
	english-1/
	    English (non-French) text

We created the png-trained.net as follows:

    ./dlowe -8000 png-1/ png-0/ < /dev/null > png-trained.net

	png-0/
	    Non-png (gif) images
	png-1/
	    png (non-gif) images

We created the xor-trained.net as follows:

    ./dlowe -8000 xor-1/ xor-0/ < /dev/null > xor-trained.net

	xor-0/
	    Data that XORs to 0
	xor-1/
	    Data that XORs to 1

## Author's comments:
# Synopsis:
This is an artificially intelligent judging tool to help the IOCCC judges.
Here's to shorter, more frequent contests!

# Description:
This is a multilayer perceptron (a feedforward artificial neural network)
which can be trained, using on-line backpropagation, to classify input files.

It has a fixed topology of 2^16 input neurons, 6 hidden neurons and 1 output
neuron.

The neurons' activation function is the logistic function 1 / (1 + e ^ -x).

## Classifying

    ./dlowe file [file ...] < trained.net

To classify files, one specifies a trained network (on stdin) and one or more
files to classify. The program will output one line per successfully-classified
file to stderr, with the filename and the classification: a number between 0
and 1.

The interpretation of the classification number depends on how the network was
trained, but it's geared toward interpretation as a *probability* or a
*confidence*.

## Training

    ./dlowe -<n_iterations> corpus1/ [...] corpus0/ < start.net > end.net

    NOTE: The directory args must end in a / for them to work.

To train a network, one specifies a starting network (on stdin), two or more
corpora (directories containing training data), and the number of training
iterations to run. The program will write some progress data to stderr and,
when it's done, will serialize the updated network to stdout.

If no input network is given, a random new network will be generated as a
starting point (i.e. provide an empty stdin).

The first corpus will be assigned a target value of 1. The last will be
assigned a target value of 0. Intervening directories (if any) will be assigned
intermediate target values.

The learning rate is hard-coded as 0.3. No momentum factor is used.

### png corpora

The png-1 corpus was obtained by manually scraping the first results from an
https://images.google.com search for "obfuscate filetype:png".

The png-0 corpus was obtained by manually scraping the first results from an
https://images.google.com search for "obfuscate filetype:gif".

Results:

 * using these corpora as a training set
 * using several hundred random *.gif and *.png files from my home computer as
   a test set
 * using the included "earlystop.pl" script, which stopped after 67000 iterations.
 * interpreting output of "> 0.5" as "probably a .png" and "< 0.5" as "probably
   a .gif"
 * produced a network with about 87% accuracy

### english corpora

The english-1 corpus was obtained by manually scraping the first results from
a https://www.google.com/webhp?lr=lang_en search for "paris filetype:txt".

The english-0 corpus was obtained by manually scraping the first results from
a https://www.google.com/webhp?lr=lang_fr search for "paris filetype:txt".

Results:

 * using these corpora as a training set
 * using several dozen additional text files (obtained by the same methods)
   as a test set
 * using the included "earlystop.pl" script, which stopped after 10000
   iterations.
 * interpreting output of "> 0.5" as "probably english" and "< 0.5" as
   "probably french"
 * produced a network with 100% accuracy

### xor corpora

The xor-1 corpus consists of two files containing '01' and '10' respectively.

The xor-0 corpus consists of two files containing '00' and '11' respectively.

Results:

 * using these corpora as a training set
 * takes about 8000 iterations to learn xor to within a tolerance of <0.01

# Limitations
The program can't tell you anything meaningful about files with less than two
bytes in them (I'm looking at you, smr.c!)

You must include the trailing directory separator on training directories
(this allows the program to be portable without wasting precious bytes on
figuring out how to concatenate directory and file names...)

Serialized network files are only portable between systems with the same
floating-point representation and endianness.

Making sure not to overfit the network to the training data is a bit of a
black art. I have enclosed 'earlystop.pl', a wrapper script that implements
a simple 'early stopping' algorithm; other techniques are possible.

Bad input (e.g. nonexistent files, non-numeric number of iterations, etc.)
tends to result in empty output.

Given exactly one corpus, the program will crash or produce garbage.

Leaks memory and file descriptors while processing files.

Will crash and die horribly if it runs out of memory.

The Microsoft C compiler doesn't provide a dirent API, so to get this working
on a Windows system you'll need cygwin+gcc (tested) or a dirent compatibility
library (untested, but they do exist).

Backpropagation doesn't always converge: if you play with this long enough,
you'll eventually have a training session that completely fails to converge.

# Obfuscation:

Zombies! (Since neural networks are modeled after BRAINS, ya know? And
corpus sounds a lot like corpse. And I have 4- and 7-year-old kids ;)

Neural networks are interesting, and while the math isn't terribly difficult,
their behavior is difficult to fully understand.

Had some extra space in one of the major data structures, and it seemed a
shame to waste it.

Similarly, I think three file pointers ought to be enough for anyone.

Lots of magic numbers expressed in various ways.

Random abuse of random C trivia.

Some textual changes were made to maximize the classification of this program
by a network trained to recognize ioccc winners ;)

... but mostly zombies!

--------------------------------------------------------------------------------
<!--
(c) Copyright 1984-2012, [Leo Broukhis, Simon Cooper, Landon Curt Noll][judges] - All rights reserved
This work is licensed under a [Creative Commons Attribution-ShareAlike 3.0 Unported License][cc].

[judges]: http://www.ioccc.org/judges.html
[cc]: http://creativecommons.org/licenses/by-sa/3.0/
-->
# Best data utility

Szabolcs Borsanyi  
Theoretische Physik  
Gaussstrae 20  
42097 Wuppertal  
Germany  
<borsanyi@uni-wuppertal.de>  


## Judges' comments:
### To build:

    make borsanyi

### To run:

    ./borsanyi < some_data_file

### Try:

    ./borsanyi < data.1
    ./borsanyi < data.2
    ./borsanyi < data.3

### Selected Judges Remarks:

This is a nice quick histogram plotter.  A useful utility when you need to
look at the distribution of some data.

Here are some challenges:

You can modify the number of histogram bins and the scaling of the histogram
by editing the source.  Try to find them!

If you look at the source you will notice that the usual array of
histogram bins is missing. The source contains no arrays and it does not
use malloc or alloca. How does it build the histogram?

While the input does not need to be sorted, the histogram output is sorted.
How does it put the data into buckets?  Why does it fork 22 times?

## Author's comments:
This small piece of program is meant to be a useful tool, when
there are some data around and you need a quick glance at the
histogram. I am all too often logged in to a remote machine with
slow X connection, and a terminal-based program would be of
great help.

# Limitations:

* I optimized the output for the data I had around, you might want to adjust
  for your needs. For a great excess of data points the program will crash
  (depending on the available stack).
* Giving too few (distinct) points can also cause crash (or division by zero).
* The program expects plain numbers separated by white spaces.
* ASCII is assumed. 
* Some POSIX-like system is assumed (fork and wait(NULL) are used)
* Do not give any arguments to the program.
* Could rounding errors cause the omission of the highest bin? There might be
  empty bins at the edges.

# Obfuscation:

* The program follows a rather unconventional approach to the task
  of histogram building. The usual array of integers (for the histogram
  bins) is missing entirely. The data are read once, the range is determined,
  but the data points are not put in any array. Yet they are remembered,
  and each of them is put into its own bin afterwards. But where are the bins?
* I tried to use as few keywords as possible, hence there are no loops.
* Multi-process approach for optimal use of resources.
* Some bin size obfuscation.

--------------------------------------------------------------------------------
<!--
(c) Copyright 1984-2012, [Leo Broukhis, Simon Cooper, Landon Curt Noll][judges] - All rights reserved
This work is licensed under a [Creative Commons Attribution-ShareAlike 3.0 Unported License][cc].

[judges]: http://www.ioccc.org/judges.html
[cc]: http://creativecommons.org/licenses/by-sa/3.0/
-->
# Most shiny

Matt Zucker  
<mzucker1@swarthmore.edu>  
<http://www.swarthmore.edu/NatSci/mzucker1/>  


## Judges' comments:
### To build:

    make zucker

### To run:

    ./zucker > image.ppm

### Try:

    ./zucker "Hello!!!" > hello.ppm
    ./zucker faster\! -preview > image2.ppm

    # Display the PPM image with your favorite image viewer

### Selected Judges Remarks:

The rendered image is centered and is output as a 600 by 220 pixel PPM.
The vector font is proportional.

This entry uses no local variables. None! At! All!

## Author's comments:
An image generator
==================

What it does:
-------------

This program makes pretty pictures.  To see the default output, try
running

        ./zucker > image.ppm

On the author's 2.5 GHz MacBook Pro, this command takes approximately
1 minute and 18 seconds to run -- your runtime may vary.  You will
need an image viewer capable of displaying Netpbm images in order to
display the output. On the Mac, [Xee](http://wakaba.c3.cx/s/apps/xee)
works well; otherwise [ImageMagick](http://www.imagemagick.org/)
and/or [GraphicsMagick](http://www.graphicsmagick.org/) are both
capable of displaying Netpbm files, and are available on multiple
platforms. (Using Xee is particularly nice because it periodically
reloads the image as it is rendered.)

Aside from the default image, you may create your own by running the
program as follows:

        ./zucker "your text" > image.ppm

To mitigate long runtimes, the program can be invoked in a "preview"
mode by appending `-preview` to the command line arguments, like so:

        ./zucker faster\! -preview > image.ppm

If your platform distinguishes between binary and text streams, you
may need to insert some code to reopen standard output in binary mode
at the start of `main`. An ASCII platform is assumed.

Pedagogical value:
------------------

This program is quite suitable for the inexperienced programmer, due
to a number of considerations:

  * It is fairly short: just 4 preprocessor directives followed by 29
    lines of source.

  * It compiles cleanly as ANSI C under gcc 4.2.1 with very strict
    compilation flags.

  * It uses a very small subset of the keywords available in C, namely
    `char`, `float`, `int`, `typedef`, `struct`, `for`, and `return`.
    More difficult concepts such as `void`, `if`, `switch`, and
    `while` are eschewed for simplicity's sake.

  * It also uses a very small number of library functions: just `putchar`,
    `cos`, `sin`, `atan2`, `sqrt`, and `pow`.

  * New programmers often prefer to use global variables when
    possible. Hence, *all* variables in this program (aside from
    function parameters) have global scope.

  * An important aspect of the computation is graphically illustrated
    by the source code itself: the geometric construction of a
    reflection ray at an object's surface, given the incoming
    direction and surface normal.
    

Further details (contains spoilers):
------------------------------------

The program is not quite a traditional ray tracer, but a "sphere
tracer" which uses distance fields to encode proximity to objects in
the scene. Using sphere tracing to compute visibility instead of
analytic ray tracing provides two advantages: first, it greatly eases
the computation of ray-torus intersection (which would otherwise
require solving a quartic polynomial), and second, it makes it
possible to compute ambient occlusion (which is used to generate soft
shadows). Unlike many traditional ray tracers and sphere tracers, this
one uses iteration instead of recursion to compute the effect of
reflections. This, unfortunately, resulted in the programmer going
insane; however, program size was reduced and readability
hindered. Neither the plaintext for the program's default output nor
for the Netpbm header appears in the program source, which hinders
readability as well. Also, unlike some previous IOCCC entries which
render ASCII text, this one uses a vector (as opposed to raster)
font. Although the program does not generate uppercase letters, it
handles them in a reasonable manner when they appear in the input.

Even when the program is pretty-printed and preprocessor macros are
expanded, it should be fairly resistant to analysis due to reckless
reuse of global variables, to the inherently opaque nature of the
math, and to its overall density. Global variables are used to store
the results of intermediate computation. As a result, seemingly simple
functions have important side effects. Although some of the global
variables are simply constants, their use is overloaded. For instance,
the variable `X` is used both as the number 40 and as the ASCII
character `'('`.  Maintainability is hindered due to hardcoding
several aspects of the program in multiple locations. As an example,
it is impossible to modify either the image width or height without
changing the source in at least three different places, including
inside the large string literal.

Some of the functions are simple vector algebra operations such as
vector construction, dot product, and normalization. However, it was
found to be much more compact to define a single operation for
multiply-and-add rather than to have separate functions for addition,
subtraction, and scaling. Again, compactness led to obfuscation.

This program heavily abuses `for` loops. The comma operator is used to
get as much milage as possible out of statements inside of loop
declarations. Between `for` loops, the comma operator, and the ternary
operator, it was possible to avoid `if` and `while` altogether.

Bitwise and arithmetic operators are used instead of logical operators
whenever gcc doesn't warn about it. Conversely, integer
multiplication, division, and modulus are sometimes used in place of
traditional bitwise operators just to keep the reader on his or her
toes. Automatic casting between characters, integers, and floats is
performed just about everywhere. Fascinatingly, this doesn't seem to
affect performance too badly. Sometimes when an explicit cast
(i.e. from float to int) is needed, the program instead simply assigns
to a free variable of the desired type instead. Both the `array[index]`
and `index[array]` notations are used interchangably throughout the
program.

Two other programs were written to support development of this
program. The first used a randomized search algorithm to deduce the
most compact encoding of the vector font instructions into ASCII; the
second used a modified form of the Knuth-Plass algorithm to layout the
final text on top of a hand-generated ASCII "stencil".  The programs
were not submitted as entries for this year's IOCCC, not because they
lack obfuscation, but because neither is written in C (they are in C++
and Python, respectively).

--------------------------------------------------------------------------------
<!--
(c) Copyright 1984-2012, [Leo Broukhis, Simon Cooper, Landon Curt Noll][judges] - All rights reserved
This work is licensed under a [Creative Commons Attribution-ShareAlike 3.0 Unported License][cc].

[judges]: http://www.ioccc.org/judges.html
[cc]: http://creativecommons.org/licenses/by-sa/3.0/
-->
# Best self documenting program

Hou Qiming  
<hqm03ster@gmail.com>  


## Judges' comments:
### To build:

    make hou

### To run:

    ./hou 'a calculator expression -- see the C Code for details'

### Try:

    ./hou 11/26+222/31

    ./hou 'log((21701-19937)-(23209-21701))/log(2)'

    ./hou 'sin(1.5708)+0.04321+log(sqrt(exp(1*1*1)))+(1+2*3)-0.4-0.6+(4+6)*(2-1+2*3)-tan(0.785398)+2*10/3*6*sqrt(16/2/2)*10+10000-1000'

### Selected Judges Remarks:

This self-documenting scientific calculator compiles clean with no
warnings under the most strict pedantic mode of gcc and clang.

The first example, along with the correct result appears in the
source code. What does it mean?

The calculator obeys the precendence rules and allows parenthesis,

        ./hou '1+2*3'
        ./hou '(1+2)*3'

What exactly does the text formatting do?

What does this evaluate to in C?

        +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+

#### Self documenting source

Comments would almost be redundant.  :-}

#### The ASCII art is valid C code

Not just fancy formatted comment removed by the C Pre-processor

#### The only multi-byte strings are format strings

The code does not contain some simple string-encoded lookup table for calculator operations.

#### Example input and output in the source

The example input and output in the C code is significant.  Can you find out why?

#### The button layout

The button layout in the C code is significant ... not just a nice looking layout.

#### input parsing

The parser is functionally equivalent to a normal arithmetic parser for all valid inputs.
For another fun challenge: try to determine how it parses the command line argument.


## Author's comments:
### Obfuscations

This program is designed to be self-documenting. It doesn't just provide an
example command line. It also provides the expected output and illustrates all
supported functionality using embedded ASCII art.

- A few line numbers are significant and careless beautification will break the program.
- The entire ASCII art is valid code. The preprocessor won't remove any part of it.
- The only strings longer than 1 byte are printf/sscanf format strings, even
  after preprocessing. No string-encoded lookup table is used.
- The example input and its expected output are both algorithmically significant.
- The button layout is also significant.
- The actual syntax being parsed is not the obvious, despite being
  functionally equivalent for all correct inputs.

### Portability

- This program requires "argv" to point to writable memory. It doesn't require
  the actual argv strings to be writable, though.
- This program requires ASCII.
- This program doesn't work with %e style numbers like "1e-4".
- Some seemingly redundant code works to eliminate warnings and evade a gcc bug.

### Spoilers

The parser parses function names, substraction, and division as single-letter
unary operators. A bitmask encoded hash table is used to check no-ops/digits
and another hash function maps the ASCII to a function ordinal, which is then
executed by the button panel.

Both hash functions are found using a separate search program. Another program
is used to find a way to format one hash function as example input such that
it produces something resembling the bitmask hash table as part of its output.

--------------------------------------------------------------------------------
<!--
(c) Copyright 1984-2012, [Leo Broukhis, Simon Cooper, Landon Curt Noll][judges] - All rights reserved
This work is licensed under a [Creative Commons Attribution-ShareAlike 3.0 Unported License][cc].

[judges]: http://www.ioccc.org/judges.html
[cc]: http://creativecommons.org/licenses/by-sa/3.0/
-->
# Best of Show - Most Shrinkable

Don Yang  
<omoikane@uguu.org>  
<http://uguu.org/>  


## Judges' comments:
### To build:

    make akari

### To run:

    ./akari [input_file_or_- [output_file_or_- [even]]]

### Try:

    ./akari < example.ppm > odd_output.ppm
    ./akari - - even < example.ppm > even_output.ppm
    ./akari example.ppm odd_output.ppm

    make akari2.c
    cat akari2.c

    make akari2

    ./akari2 < akari2.c
    ./akari2 rot13 < akari2.c

    make akari3.c
    cat akari3.c

    make akari3

    ./akari3

    make akari4.c
    cat akari4.c

    ./akari4

### Selected Judges Remarks:

Akari is an image downsampling utility that accepts 3 inout formats:

    * PGM (netpbm grayscale image).  Akari only accept PGM files with this
      header: P5 <width> <height> 255.  Images with extra comments such as
      the ones produced by GIMP will not be parsed properly.

    * PPM (netpbm RGB image).  Only PPM files with this header are
      accepted: P6 <width> <height> 255.

    * ASCII art (with end of lines in LF bytes only, not CR-LF)

Anything that is not parseable as PGM or PPM will be downsampled as ASCII art.

## Author's comments:
Akari is an image downsampling utility.  She accepts up to 3 arguments:

First argument is the input image.  If it's "-" or unspecified, Akari
will read from stdin.

Second argument is the output image.  If it's "-" or unspecified,
Akari will write to stdout.

Third argument, if specified, causes Akari to keep even pixels on even
scanlines.  By default Akari will keep odd pixels on odd scanlines.

Examples:

    gcc akari.c -o akari
    ./akari < example.ppm > odd_output.ppm
    ./akari - - even < example.ppm > even_output.ppm
    ./akari example.ppm odd_output.ppm

Akari accepts 3 input formats:
* PGM (netpbm grayscale image).  Akari only accept PGM files with this
  header: P5 <width> <height> 255.  Images with extra comments such as
  the ones produced by GIMP will not be parsed properly.
* PPM (netpbm RGB image).  Only PPM files with this header are
  accepted: P6 <width> <height> 255.
* ASCII art (with end of lines in LF bytes only, not CR-LF)

This is useful for decoding some curiously interlaced images, such as
the included example.ppm

Anything that is not parseable as PGM or PPM will be downsampled as
ASCII art.  Since the source code is formatted as ASCII art, it's only
natural to try:

    ./akari akari.c akari2.c

akari2.c is also a valid C program, and accepts up to 1 argument.
By default, this second program reads text from stdin and writes
expanded output to stdout.  If the extra argument is specified, the
output text will also pass through a rot13 filter.

    gcc akari2.c -o akari2
    ./akari2 < input.txt > expanded_output.txt
    ./akari2 rot13 < input.txt > expanded_and_rot13_output.txt

You can combine the two programs together to have just a regular rot13
filter:

    ./akari2 rot13 < input.txt | ./akari > rot13.txt

Of course, we wouldn't stop with just 2 programs, you can downsample
the source *again* and get yet another C program:

    ./akari < akari.c | ./akari > akari3.c

We must go deeper:

    ./akari < akari.c | ./akari | ./akari > akari4.c

akari3.c and akari4.c are still (mostly valid) C programs.
"gcc -Wall" will output a few warnings, but still produce output
executables.  The output executables each print a message to stdout.

It takes quite a bit of skill and obfuscation to interleave a
C program 4 levels deep, it's much easier to interleave something like
a brainf#$% program in a C program, for example.  For comparison, a
brainf#$% program is embedded inside akari.c

--------------------------------------------------------------------------------
<!--
(c) Copyright 1984-2012, [Leo Broukhis, Simon Cooper, Landon Curt Noll][judges] - All rights reserved
This work is licensed under a [Creative Commons Attribution-ShareAlike 3.0 Unported License][cc].

[judges]: http://www.ioccc.org/judges.html
[cc]: http://creativecommons.org/licenses/by-sa/3.0/
-->
# Most devolving

Philip Blakely  
Cambridge, UK  
<pmblakely@gmail.com>  


## Judges' comments:
### To build:

    make blakely

### To run:

    # Zoom out and make your terminal window 53 or more lines deep 
    ./blakely < blakely.c | head -300

### Try:

    ./blakely < 3.dat | head -100
    ./blakely - < 3.dat | head -40
    ./blakely < evolve_to_3.dat | head -55
    ./blakely < t0_3.dat

### Selected Judges Remarks:

This program plays Life, computes Pi to 16 digits
if given its own source as input, and allows to check if your garden
is a [Garden of Eden](http://en.wikipedia.org/wiki/Garden_of_Eden_%28cellular_automaton%29), all in one source. 

If you have enough time to spare, put the plan of your garden in a text file, 
and run:

    ./blakely - < garden.txt

## Author's comments:
Remarks
-------

This program uses a well-known algorithm in order to display pi to
fifteen decimal places. The source-layout itself demonstrates the importance of
using the correct amount of whitespace in code and the clear superiority of spaces over tabs.

In order to see the main feature of the code, type:

    ./blakely < blakely.c

and wait for about four seconds before using Ctrl-C (or whatever) to end the program. The
results are best viewed in a terminal window at least 60 characters
high and wide. Alternatively, redirect the output to a separate file
(killing when necessary).

Overview
--------

The program emulates John Conway's ceullular automaton known as "The
Game of Life", using standard input as a starting grid. The layout of
the source-code is such that it evolves to a digital representation of
the first 15 decimal places of pi after 4 time steps. This was setup
using the other feature of the program which can be demonstrated as follows:

    ./blakely - < 3.dat

The program will first display the grid given in 3.dat, and then three
more grids (taking a few minutes to display the last). Waiting for any more grids will
take a substantial amount of time. The final grid has been put into
evolve\_to\_3.dat, and if you type

    ./blakely < evolve_to_3.dat

then the 3 will reappear after three time steps.

As should now be clear, this use of program will attempt to evolve a given setup backwards in
time according to the Life rules. The resulting grid is clearly not
necessarily unique. The program will evolve backwards given *any* single
command line option.

When evolving forwards, the code can only be stopped by killing the
program. In the reverse direction, the code can either be killed, or
will stop if it is unable to find a grid that will evolve to the
current layout correctly. This can be seen with the sample grid
t0_3.dat, which evolves backwards by only two time-steps.

Input file format
-----------

The input files must encode a square grid, where a space is a dead
cell, and any other character (except a newline) is a living cell. Each line must be the same
length, and end with a single newline character \n (ASCII 10), including the last line. When
designing grids, it may help to type full-stops in place of spaces,
and do a global replace afterwards. Any deviation from this format will
cause errors in the output.

Limitations
-----------

This is only an approximation to the original Life, as it takes place
on a finite grid, with borders that are automatically killed off
before each time step. However, when evolving backwards, the resulting
grids will not cause any cells on the boundaries to come alive.
As the display is performed before killing off the borders, some
boundary cells may sometimes appear to be alive, but not be treated as
such for the following time-step, although any living cells on the
right border will never be displayed.

The maximum grid size is currently 99 by 99 (exceeding this will cause a
seg-fault), but changing the two 9802s to MAX\_SIZE*MAX\_SIZE+1 will
solve this, although some reformatting of the
code may have to be done to allow larger numbers.

Compiler warnings/assumptions
-----------------------------

When compiled with the -Wall -pedantic -ansi options of gcc, some
warnings suggesting extra parentheses occur (not necessary for anyone
fully conversant with operator precedence). There is one unused
variable, v, but unnamed function parameters are not permitted in ANSI
C, so naming it is necessary, and gcc no longer warns about its
existence, although earlier versions did.

Since the program calculates ASCII character values for display, an
ASCII based system is required to run it. Also, as mentioned above,
any system that uses anything other than a plain '\n' to end a line will cause
problems when reading in files.

Obfuscations
------------

Given the finely-tuned layout required to evolve into pi, this is one of the
main obfuscations used in the code. However, running the code through the
preprocessor, expanding the defines, and applying GNU's indent, although
making the location of functions and statements clear, by no means makes the
code entirely clear.  Note that expanding out the #defines does not take the
program over the character limit. The main reason for these is to do with the
layout, since there are few places that keywords or tokens of over 2
characters can be fitted, and requiring the first few lines to be #includes
would cause similar problems.

Other obfuscations used are:

- Use of the classic 2[a] syntax to access the third element of the
  array a
- Nested ternary operators, combined with shortcut evaluation being
  required for correct operation
- Use of the comma operator to embed operations inside one another
- Calculation of ASCII codes
- Needlessly recursive functions
- Use of bitwise-operations.
- Storing a variable whose value could easily be found from another
- Use of gotos to emulate a for loop

Algorithm
---------

The forwards evolution of the grid is straightforward.

The reverse evolution is done using a brute-force method. As far as I
know, a brute-force method is the only viable automatic approach for
general grids, although more intelligent algorithms would be possible
given more space.

The program starts with an empty "trial" grid and, starting from the
top-left, tries all possibilities for the neighbours of the current
cell that will cause the cell to evolve to the required state. It then
proceeds to the right and down. Thus, it only ever needs to look at
the cells below and to the right when testing. However, the already
defined cells above and/or to the left of the cell may mean that there
are no possibilities that will give the correct state, in which case
the code backtracks and tries other possibilities on previous
cells. The program knows it has a valid grid if it gets to the last
cell. If it cannot find a valid grid, the program exits.

Since this uses brute-force, it can be very slow. (In fact, the
various obfuscations have, at least for the gcc compiler,
caused a substantial slowdown.)

Program layout
--------------

The "calculation" of pi was chosen purely because algorithms to find
pi are numerous, but the Game of Life is rarely (if ever?) used for
this purpose. Also, separate digits made determining the layout somewhat easier.

Deriving the layout was the most complicated part of the program. As is clear from
the final layout featuring pi, the grid was divided into sixteen squares,
and layouts that would evolve to each of the nine digits required were
found. (This used the three-by-five digit-layout embedded in, at first, a
nine-by-nine grid, then in larger grids, until fifteen-by-fifteen was
reached.) The fifteen-by-fifteen grids give enough blank cells around
them that the digits will not collide when evolving.

However, this did not allow for sufficient characters to fit the code
into. Therefore it was necessary to add some regions that would quickly die off
without expanding to collide with the digits' evolution.
Groups of cells such as singletons, pairs, and larger groups like

    * * * * * * * * * *
     *****************
    * * * * * * * * * *

were useful in this regard.

Other problems were given by keywords which need to be all in one
string, keywords requiring space after them, and
multi-character tokens. Some of these problems were dealt with by
using the #defines and #includes given in the build-script, as there
was no way to have sufficient separate lines in the code to do this
without causing many difficulties. Some rejigging of the grid's layout
as the code was fitted into its format was also done, resorting to
trial-and-improvement in some cases. Occasional use of constructs such
as f -= -3 was made as f += 3 could not be fitted into the required format.
The fact that the borders would be killed off immediately was also helpful.

It should be noted that evolving a full 60-by-60 grid backwards using
this code would probably take us at least up to the heat-death of the
universe.

The command ./blakely - < blakely.c is therefore *not* recommended.

--------------------------------------------------------------------------------
<!--
(c) Copyright 1984-2012, [Leo Broukhis, Simon Cooper, Landon Curt Noll][judges] - All rights reserved
This work is licensed under a [Creative Commons Attribution-ShareAlike 3.0 Unported License][cc].

[judges]: http://www.ioccc.org/judges.html
[cc]: http://creativecommons.org/licenses/by-sa/3.0/
-->
# Most useful

Kimmo Fredriksson  
<kimmo.k.k.fredriksson@gmail.com>  


## Judges' comments:
### To build:

    make fredriksson

### To run:
    
    ./fredriksson [-icvtnk#] regexp < file

### Try:

    ./fredriksson -k1 -i POOT < /etc/group
    ulimit -s unlimited
    ./fredriksson -k2 -t -n bofuskate < /usr/share/dict/words

### Selected Judges Remarks:

The author of this entry was making sure that it does not win the
"Best Short Program" award.  On the outside, the program behaves
as an approximate grep.  On the inside, it is a Burrows-Wheeler
transform decompressor that produces the source code of the actual
obfuscated approximate grep program and calls it. As an exercise,
try writing the compressor.



## Author's comments:
# Approximate grep

Implements a variant of grep.

## Usage

To search regexp from file, do:

	./fredriksson [-icvtnk#] regexp < file

Pipes may not work, see the section Limitations.
The options `-i -c -v` and `-n` are the classic ones:

* `-i`	Ignore case.

* `-c`	Count only, prints the number of matches, but not the matching lines.

* `-v`	Invert match.

* `-n`	Prefixes each printed line by its line number (only if
	`-c` was not given).

This version of grep recognizes two more options, not present in normal
grep implementations:

* `-kN`	Permit `N` insertions, deletions or mismatches of characters in the
	matches (aka edit-distance). E.g. "obfuscated" matches "obfuscation"
	with one deletion and two mismatches. Likewise, "obfuscate" and
	"oversimplify" match with 7 edit operations. The default is `-k0`
	(i.e. exact match).

* `-t`	Add local transpositions to the set of allowed edit-operations.
	That is, "ab" matches "ba" with one transposition (swap), and
	"obfuscated" matches "bofsuact" with three swaps and two insertions,
	i.e. use `-tk5` to find this.

Of course, one could construct a standard regexp that matches the same
patterns, but the problem is that such a regexp grows exponentially in
size when the number of allowed edit operations is increased.

This version does not recognize all regular expressions, but the
following are allowed:

* Wild card: `.` (dot) matches any character.

* Bracket expression: list of charactres enclosed by `[` and `]`,
  matches any single character in the list.

* Range expression: two characters separated by hyphen and enclosed in
  brackets, matches any character that is lexicographically between the
  two characters (inclusive). E.g. `[a-d]` is the same as `[abcd]`.

The special characters must be escaped, if they are to be taken
literally (i.e. use e.g. `\.` to match period). You might want to protect
these with `'`, i.e. use `'foo\[bar'` instead of `foo\[bar`. If you want to
use the literal `-` in bracket expression, protect that too (`\-`),
otherwise this is not needed. Note that the syntax differs from standard
(?) grep a bit, i.e. in plain grep you can use `]` and `-` in bracket
expressions by putting `]` as the first character, and putting `-` last.

### Other uses

* You can use this in place of cat. Just say

		./fredriksson -k3 cat < file

* Like with cat, you can append line numbers too:

		./fredriksson -nk3 cat < file

### Other features

* It is assumed that the user knows how to feed correct input to the
  program. If undefined options are given, the result is also undefined.
  This is a feature.

* It may consume huge amounts of memory, and a stack overflow may occur.
  This results in Segmentation fault (or the equivalent of your favorite
  system, such as Bus error). This is a feature, that can be used to detect
  overly long lines in the input file, such as checking the lenght of one
  liners in IOCCC entries, just adjust your stack size to a suitable
  threshold, and search for "ioccc", with option `-vk5`.

## Limitations and remarks

* Using warning options (such as -Wall) when building gives a lot of warning,
  such as `suggest parentheses around '&&' within '||'`, `value computed is
  not used`, `implicit declaration of function 'putchar'`, `implicit
  declaration of function 'getchar'`, `control reaches end of non-void
  function` and `format not a string literal and no format arguments`.
  Please ignore them all, since they just try to tell you that the source
  is obfuscated.

* Only standard input is handled. And _only_ if stdin comes from a file,
  i.e. pipes may or may not work. If you want to count only (`-c` option),
  then this shouldn't be an issue.

* The total lenght of the (preprocessed) pattern is at most
  `sizeof(long)*CHAR_BIT`. That does not count things like bracket expressions
  or escape chars, that is, the pattern `'a[bcd]e\.f'` is 5 chars long, not
  10 chars. That does not mean that the matched substring in the standard
  input has this limit, as using the edit operations can make the string
  longer. However, no assumptions are made for `sizeof(long)`. In fact,
  you can easily use `long long` instead,

* Depending on the file, may require a lot of stack space. If the
  program segfaults (because of this), say

		ulimit -s unlimited

  cross your fingers, hope it is enough, and try again.

* Assumes C99 standard, because of the one very long line. Most C compilers
  handle this just fine even in C89 mode, though.

* The code should be reasonably portable, it assumes standard ASCII codes
  for each char, and that a C compiler is on $PATH; the latter is hard coded
  to be 'gcc', but any compiler would work, provided that it supports
  C99, or long lines as an extension. This code has been tested on:

	- GNU/Linux FC4, i386, gcc
	- GNU/Linux FC7, x86_64, gcc 4.1.2, tcc 0.9.24 and icc 10.0
	- GNU/Linux FC9, x86_64, gcc 4.?.?
	- GNU/Linux CentOS 5, gcc 4.1.2
	- GNU/Linux Ubuntu 11.04, gcc 4.5.2
	- SunOS 5.8, UltraSPARC IIIi, gcc 4.1.2
	- SunOS 5.9, UltraSPARC IIIi, gcc 4.1.1 and Sun ONE Studio 8 CC
	- AIX 5.3, IBM eServer p5-550, gcc 3.3.3 and AIX CC Version 6

  (Btw, tcc has its roots in IOCCC...)

## Obfuscations (a.k.a. spoilers...)

* The initialized char array includes the source code of the real program,
  as well as its name and commands to build and run it, all Burrows-Wheeler
  -transformed, then run-length-encoded with unary coding. The main program
  extracts and builds that, and then calls it. More precicely, the command
  to build is

		gcc -O3 ag.c -o ag

  To change that you need to edit the char array `p[]` and (possibly) two
  specially encoded constants, `-~('('*'(')` and `'C'*' '-'-'`.
  The extracted source (`ag.c`) is obfuscated as well.

  (The original version also deleted the generated source and the
  corresponding binary after running it, but this feature was removed
  from the submitted entry.)

* The code demonstrates several useful programming paradigms, such as

	- recursion to remove all loops
	- sub routines (`main()` contains several logical sub routines,
	  selected by the first argument)
	- function pointers

* Algorithmically, it incorporates the following

	- (inverse) Burrows-Wheeler transform (used also e.g. in bzip2)
	- data compression (really expansion :-), run-lenght-encoding,
	  unary coding (this is why it is expansion rather than compression)
	- approximate string matching
	- dynamic programming to compute the edit distance
	- parallel computation in sequential computers (by packing
	  several objects into a single long, to speed up the dynamic
	  programming)
	- self extracting, compiling and running code

* As a C program, it demonstrates that

	- a C subset without reserved words is complete enough,
	  (excluding data type specific things (`int`, `char`, `void` ...))
	- only letters are needed (i.e. the digits 0-9 are not)
	- only one statement is enough to code any program (plus
	  variable definitions)
	- white space has other uses than just indenting the code

* It also shows the power of boolean logic and bitwise arithmetic.

* This is the first (?) entry in the history of IOCCC, that cannot be
  totally un-obfuscated by the author. This is due to the clever choice of
  the actual algorithm, that is obfucated by nature, and it is an open
  research problem whether a simpler algorithm exists, with the same time
  complexity.

* The main obfuscation comes from using only arithmetic and boolean
  (short-circuit) logic combined with recursion to remove all loops and
  if-then-else constructs (also, no ternary `?:` constructs are present).
  Two's complement representation of integers is also abused. E.g. instead
  of writing `x++` or `x-1`, it is much better to write `x=-~x` and `~-x`.

* No numerical values, other than in the initialized char array, try

		./fredriksson -ck0 [0-9] < fredriksson.c

  This should print 1, as there is a numer '3' in the char array (only).
  You can also try

		./fredriksson -ck0 [0-9] < ag.c

  after running fredriksson at least once (since this generates that
  `ag.c` file), and this should print 0.

* The source code is best viewed with cat (or using the program itself),
  instead of some editor. (This is a somewhat system dependent thing.)

  One reason for this is that the code builds (some of the) constant
  values from string literal `"\b"`, except that the backspace `\b` is not
  escaped like that, the source uses the raw ascii value (010 octal) instead.
  Thus when viewing with cat or something, that backspace erases the leading
  quotation mark. Makes it appear uncompilable, and it is: if you copy-paste
  the cat output from terminal to some editor, save it, the result would not
  compile.

  Some other constants are built from ASCII values of chars.

  Besides of making the code hard to read, all this makes it also quite large.

* Running it through GNU indent or bcpp (C beautifiers) does not beautify
  it a bit. In fact, indent makes it only worse (at least with the default
  options). Running it through the preprocessor does basically nothing,
  since no `#define`s are used.

* Some _abuse of the rules_. The number of non-whitespace and `;`, `{`
  and `}` chars is below the limit, but most of the whitespace chars are
  in an _initialized character array_. That is, the number of chars in the
  program exceeds the 2048 limit. However, whitespace is whitespace and
  the rules did not specify that these must be in between the statements.
  A character is a whitespace if `isspace()` returns non-zero value. Even
  if deleting even one of those chars breaks the program! (This does not
  apply to the generated source `ag.c`.)


--------------------------------------------------------------------------------
<!--
(c) Copyright 1984-2012, [Leo Broukhis, Simon Cooper, Landon Curt Noll][judges] - All rights reserved
This work is licensed under a [Creative Commons Attribution-ShareAlike 3.0 Unported License][cc].

[judges]: http://www.ioccc.org/judges.html
[cc]: http://creativecommons.org/licenses/by-sa/3.0/
-->
# Most surprisingly portable

Gregor Richards  
<Richards@codu.org>  


## Judges' comments:
### To build:

    make richards

### To run:

    ./richards

### Try:

    echo '10 9 8 7 6 5 4 3 2 1*p*p*p*p*p*p*p*p*p' | ./richards

### Selected Judges Remarks:

Oh no, yet another dc-style calculator? (see 2000/dlowe using an embedded Perl
interpreter and deemed Worst Abuse of the Rules). 
Well, this one does it (expression calculation, that is, not the rule abuse) in a different way. 
The author claims that his calculator does just-in-time compilation.
What would you do to prove or disprove his claim without attempting to unravel the source?

## Author's comments:
This is an implementation of the classic UNIX dc command, the reverse-polish
calculator. Actually it's a pretty bad implementation, since it only implements
32-bit integers (well, sizeof(int)-sized integers). It only implements the
commands +, -, *, /, p (only for numbers), register stacks, macros and
comparisons. Wow, you'd think I could've done better in 2K of code.

OH! I forgot to mention! It's a JIT.

Wait, don't stop reading! I know what you're thinking, platform-specific code
is discouraged in IOCCC. But do you see any platform-specific code? There's no
assembler here! This JIT works on a dozen platforms, and the only
platform-specific assumptions it makes are that the stack grows down and
integers are at least 32-bit.

You will probably get warnings while compiling the code. In particular:

 * If your system requires the inclusion of alloca.h to use alloca, use the
   compile flag -DAH
 * If your system cannot use mmap, use the compile flag -DNM
 * I don't include any headers I don't strictly need to, so you'll get warnings
   about (at least) memcpy, isdigit, atoi, calloc, malloc and alloca if you
   didn't use -DAH.
 * GCC likes to complain about while (a = b) (assignments as a condition).
 * I don't return from main, even though it's declared to return int.

Platforms on which all known/tested optimization levels work with no additional
flags:

 * gcc 4.6.2 + x86[_64] + GNU/Linux, Mac OS X or Windows
 * clang 2.9-16 + x86[_64] + GNU/Linux or Mac OS X
 * tcc 0.9.25
 * gcc 4.4.5 + alpha, arm, mips[el], powerpc[64], s390x (IBM zSeries)
 * gcc 4.1.3 + vax + NetBSD

Platforms which work but not at all optimization levels or needing special
flags:

 * owcc 1.9 + x86 + Windows: Needs -DNM -DAH -fno-stack-check
 * gcc 4.4.5 + sh4: -O0 works, higher optimization levels don't work for unknown reasons.

--------------------------------------------------------------------------------
<!--
(c) Copyright 1984-2012, [Leo Broukhis, Simon Cooper, Landon Curt Noll][judges] - All rights reserved
This work is licensed under a [Creative Commons Attribution-ShareAlike 3.0 Unported License][cc].

[judges]: http://www.ioccc.org/judges.html
[cc]: http://creativecommons.org/licenses/by-sa/3.0/
-->
# Most artistic

Uri Goren  
<goren.uri@gmail.com>  


## Judges' comments:
### To build:

    make goren

### To run:

    echo "some text" | ./goren

### Try:

    echo "Hello, world!" | ./goren

### Selected Judges Remarks:

In the words of [Ren Franois Ghislain Magritte Magritte](http://en.wikipedia.org/wiki/Rene_Magritte):

![This is not a pipe](http://upload.wikimedia.org/wikipedia/en/b/b9/MagrittePipe.jpg "Ceci n'est pas une pipe")

One may ask the surrealist question:

    echo 'If | is just a representation of a pipe, then how can data stuff it?' | ./goren

However if one takes a firm stand and declares:

    echo '| is just a representation of a pipe because I say so! So stuff it!' | ./goren

something happens!  Why?

## Author's comments:
This program was written in homage to Rene Magritte's picture "La
trahison des images" (The Treachery of Images).

In order to show my unconditional admiration of this work, I avoided
using conditions.

In this work, Magritte points out that a picture of a pipe is not
a pipe.  But what IS a pipe? This program tries to provide an answer.

Magritte's [test for pipes](http://en.wikipedia.org/wiki/The_Treachery_of_Images} is:

    The famous pipe. How people reproached me for it! And yet, could
    you stuff my pipe? No, it's just a representation, is it not?

Accordingly, this program only approves pipes which can be used for
stuffing data.

One thing I tried to achieve is condition free programming.  Many
have noted that conditions make the code harder to read and understand.
A good example would be:

[Brent Burley's 2004 IOCCC winner](http://www.ioccc.org/years.html#2004_burley)

That entry omits conditional statements such as "if" and "while".
His achievement in improving clarity by omitting conditions is
impressive, but I think it can be taken further, in two ways.

First, conditional operators, such as ?:, && and ||, can be thrown
away.  Second, using setjmp and longjmp, which are unfortunately
not in common use, might make it difficult for a novice programmer
to understnad the code without referring to the man page.

By removing these, the code is 100% condition free, and every
function runs its instructions in perfect order. Naturally, this
makes the program flow trivial to understand.  This can be verified
by disassembling the compiled code and looking for conditional jumps
(when compiled with gcc on x86, there are none).

### Compatibility:

The program should compile with any C compiler, but was tested
mostly with gcc on Linux.

It doesn't support 64 bits (due to integer-pointer casts, and a >>31).
It does work on 64-bit Linux, becasue all functions are below 4GB.

--------------------------------------------------------------------------------
<!--
(c) Copyright 1984-2012, [Leo Broukhis, Simon Cooper, Landon Curt Noll][judges] - All rights reserved
This work is licensed under a [Creative Commons Attribution-ShareAlike 3.0 Unported License][cc].

[judges]: http://www.ioccc.org/judges.html
[cc]: http://creativecommons.org/licenses/by-sa/3.0/
-->
# Best one liner

Taketo Konno  
Tokyo, Japan  
<inaniwa3@gmail.com>  


## Judges' comments:
### To build:

    make konno

### To run:

    ./konno just_a_single_argument_of_lower_case_letters

### Try:

    ./konno qwerty
    ./konno ioccc
    ./konno "the quick brown fox jumps over the lazy dog"

### Selected Judges Remarks:

This tiny program outputs what looks like a tiny keyboard.  
OK, so the letters are missing. But that is no problem because 
this program identifes the lower case letters that were pressed!

It is one of those minimal keyboards without all of those
confusing symbols keys.  No shift for SHOULDING CAPS
but at least it does not have that useless caps lock key!

We recommend that you completely deconstruct / figure out
how this program works and does what it does.  Can you
extend this program to deal with a full QWERTY keyboard?
Can you then minimize the size of that code?

## Author's comments:
### Limitation

This program ignores non-lower case letters.

### Obfuscation

* "for" is not used. 
* A part of program is encrypted.

--------------------------------------------------------------------------------
<!--
(c) Copyright 1984-2012, [Leo Broukhis, Simon Cooper, Landon Curt Noll][judges] - All rights reserved
This work is licensed under a [Creative Commons Attribution-ShareAlike 3.0 Unported License][cc].

[judges]: http://www.ioccc.org/judges.html
[cc]: http://creativecommons.org/licenses/by-sa/3.0/
-->
# Most conspiratorial

Aaron Grothe  
2205 South 51st Street  
Omaha, NE 68106  
US  
<ajgrothe@yahoo.com>  

David Madore  
<http://www.madore.org/~david/>  


## Judges' comments:
### To build:

    make grothe

### To run:

    # To create a shared secret shared among M people with N+1 needed to reconstruct
    ./grothe -secret 1-/dev/urandom 2-/dev/urandom ... N-/dev/urandom \
    1+shared1 2+shared2 ... M+sharedM

    # To reconstruct the original (an arbitrary combination of N+1 or
    # more shared files with their proper numbers)
    ./grothe I-sharedI J-sharedJ K-sharedK ... +reconstructed

### Try:

    ./grothe -grothe.c 1+grothe.c.1 2+grothe.c.2

    ./grothe -cookie_recipe.txt 1-/dev/urandom 2-/dev/urandom \
    1+cookie_piece1.dat 2+cookie_piece2.dat 3+cookie_piece3.dat 4+cookie_piece4.dat

    ./grothe 1-cookie_piece1.dat 2-cookie_piece2.dat 4-cookie_piece4.dat
    +cookie_recipe_restore.txt

### Selected Judges Remarks:

Also known as Best abuse of the judging process.

The IOCCC 2012 submission page didn't enforce the 2048 meaningful
character limit.  This entry, as submitted, weighed in at 2222 chars
but was, luckily for it, extremely easy to bring down below the
limit.  There were a number of strings that when concatenated allowed
the program to slide under the limit.

It was clear to the judges that the extra size was an entry
beautification step.  Had it not, this entry would have been
rejected in round 0.

The judges also took some liberty obfuscating this entry a litte more.

How does this entry work? The only place multiplication is used is
to perform the atoi conversion.


## Author's comments:
**Description**

This program implements a version of Shamir's Secret Sharing.  Shamir's Secret
Sharing allows you to encrypt a file into N parts where it will take M parts to
recreate the original file.  E.g. you can split the secret recipe for Crystal Pepsi
into 3 parts and require two of them be available to extract the original recipe.

Actually surprisingly useful for an IOCCC entry :-)

**Usage**

To share a secret

E.g.

file to be shared - cookie\_recipe.txt
number of pieces - 2 + file to be shared
total number of pieces created by program 4
pieces needed to reassemble recipe 3 or greater

**example usage**

\# to share secret into 4 pieces of which at least 3 will be needed to get back the recipe

    ./grothe \
        -cookie_recipe.txt 
        1-/dev/urandom 2-/dev/urandom 
        1+cookie_piece1.dat 2+cookie_piece2.dat 3+cookie_piece3.dat 4+cookie_piece4.dat

\# put recipe back together using 1, 2 and 4th piece

    ./grothe \
        1-cookie_piece1.dat 2-cookie_piece2.dat 4-cookie_piece4.dat
        +cookie_recipe_restore.txt

**Limitations**

* program is limited to 256 input and output files and will slow down dramatically when you get past 20-50 inputs and outputs

**Obfuscations**

* nothing is done consistently throughout the program E.g i+=1, i=i+1, i++ and ++i are all used in the program.  The mark of true code buggery. - "A foolish consistency is the hobgoblin of little minds" - Ralph Waldo Emerson
* uses the most powerful obfuscation of all "Math".  "Any sufficiently advanced cryptography is indistinguasble from magic" - Apologies to Arthur C. Clarke
* shadows variables by using brackets in main program to create local copies of variables that are the same as global scope variables.  -Wshadow should probably be a part of -Wall in gcc
* uses array\_index[array\_name] instead of array\_name[array\_index] in several places.  Still don't know why C continues to allow this
( error strings are encoded with offsets that are also used to select them in the case statement.  All strings are located in one function for easy localization
* liberal use of octal numbers, hexadecimal numbers and regular decimal numbers throughout program
* variables and function names are semi-random and upper and lower case characters are used
* use of #defines from stdio.h, stdlib.h for values \_STDIO\_H and EXIT\_SUCCESS used to represent 1 and 0 respectively in the program
* arrays only need to be 256x256 most are set to greater values than they need to be so trying to figure it out can be a bit tough

**References**

* Shamir's Secret Sharing - <a href="http://en.wikipedia.org/wiki/Shamir%27s_Secret_Sharing">http://en.wikipedia.org/wiki/Shamir%27s_Secret_Sharing</a>
* David Madore's implementation of Shamir's Secret Sharing - <a href="http://www.madore.org/~david/programs/programs-1.36.html">http://www.madore.org/~david/programs/programs-1.36.html</a>
* Steve's Recipe Database - source for the $25k Cookie Recipe - <a href="http://recipes.stevex.net/">http://recipes.stevex.net/</a>

--------------------------------------------------------------------------------
<!--
(c) Copyright 1984-2015, [Leo Broukhis, Simon Cooper, Landon Curt Noll][judges] - All rights reserved
This work is licensed under a [Creative Commons Attribution-ShareAlike 3.0 Unported License][cc].

[judges]: http://www.ioccc.org/judges.html
[cc]: http://creativecommons.org/licenses/by-sa/3.0/
-->
# PiE in the sky award

Yusuke Endoh  
<mame@ruby-lang.org>  
<https://github.com/mame/>  


## Judges' comments:
### To build:

    make endoh2

### To run:

    ./endoh2 > pi.c
    gcc -o pi pi.c
    ./pi > 314.c
    ...

    ./endoh2 e > e.c  
    gcc -o e e.c
    ./e > 271.c
    ...

### Try:

    make pi
    make e
    make everything

### Selected Judges Remarks:

A pi/e printing quasi-quine in ASCII art with a compressed font in it;
what else to wish for in this program? Virtual machine emulation?

## Author's comments:
Yeah, "Again".  Sorry.  But I don't feel guilty or uncomfortable.

This entry is based on 'over-used themes' such as self reproducing
program and pi or e computation.  I know you're tired of them.


But have you ever seen **all-in-one**?


### What it is

This program generates a new program in the shape of the Greek letter
`pi`.  Then, the generated program:

- computes 3 digits of pi and prints it as a ASCII-art program that:
- computes 4 digits of pi and prints it as a ASCII-art program that:
- computes 5 digits of pi and prints it as a ASCII-art program that:
- computes 6 digits of pi and prints it as a ASCII-art program that:
- etc.

One more thing...  When you give a command line option "e" to the
first program, the generated one will compute Napier's constant
rather than pi.


### Obfuscation

This program itself is in the shape of a spigot.  This is derived
from analogy with "spigot algorithm" which infinitely computes the
value of a mathematical constant such as `pi` or `e`.

<http://en.wikipedia.org/wiki/Spigot_algorithm>

The two sets of programs, 314\*.c and 271\*.c, are almost the same
except its shape and constant computation part.  I tailored the
common part to parse in both shapes ("3.14..." and "2.71..."), by
tweaking the computation order and adding meaningless code fragment.

On the other hand, to make it fit inside one screen (80 x 25), my
program is shortened properly, more than it looks.  (As you may
know, Quine needs to make its program size doubled.)
For example, this program involves 3x5 bitmap font data of ten
characters ('0' -- '9'), as just 20 bytes: "G1%xJ{;Q7wunmuGuu%uu".
We can decode character n as `275*s[n+10] - 8*s[n] - 8`.  I solved the
system of Bezout's identities to find the magic string, with the
aid of a brute force.  See `find-font-table.rb` in detail.

<http://en.wikipedia.org/wiki/B%C3%A9zout's_identity>

I used many other tricks for short coding.

I'm sorry that many ASCII-art-style winning entries of IOCCCs
ignore preprocessor directives.  In my program, #include is a part
of ASCII-art with comment padded.

These design requirements made my program well-obfuscated
willy-nilly.


### Portability

I expect it to work in any major environment and C compiler.
To build with no warning, it requires two C99 features: string
literal more than 509 characters and omissible return in main
function.  In fact, recent compilers with "-std=c99 -Wall -W
-Wextra -pedantic" would say nothing.

    gcc -std=c99 -Wall -W -Wextra -pedantic spigot.c
    clang -std=c99 -Wall -W -Wextra -pedantic spigot.c

I've tested with gcc-4.6.3 and clang-3.0 on Linux (Ubuntu 12.04)
and gcc-4.5.3 and clang-3.1 on Cygwin.


### Synopsis

    gcc endoh2.c -o endoh2

    ./endoh2 > pi.c
    cat pi.c

    gcc pi.c     -o pi     ; ./pi     > 314.c     ; cat 314.c
    gcc 314.c    -o 314    ; ./314    > 3141.c    ; cat 3141.c
    gcc 3141.c   -o 3141   ; ./3141   > 31415.c   ; cat 31415.c
    gcc 31415.c  -o 31415  ; ./31415  > 314159.c  ; cat 314159.c
    gcc 314159.c -o 314159 ; ./314159 > 3141592.c ; cat 3141592.c
    etc...

    ./endoh2 e > e.c
    cat e.c

    gcc e.c      -o e      ; ./e      > 271.c     ; cat 271.c
    gcc 271.c    -o 271    ; ./271    > 2718.c    ; cat 2718.c
    gcc 2718.c   -o 2718   ; ./2718   > 27182.c   ; cat 27182.c
    gcc 27182.c  -o 27182  ; ./27182  > 271828.c  ; cat 271828.c
    gcc 271828.c -o 271828 ; ./271828 > 2718281.c ; cat 2718281.c
    etc...

You can do `make everything` for the process (with no `cat`).

Note: The executable may return a failure (non-zero) exit status
unless -std=c99 option is given.

--------------------------------------------------------------------------------
<!--
(c) Copyright 1984-2015, [Leo Broukhis, Simon Cooper, Landon Curt Noll][judges] - All rights reserved
This work is licensed under a [Creative Commons Attribution-ShareAlike 3.0 Unported License][cc].

[judges]: http://www.ioccc.org/judges.html
[cc]: http://creativecommons.org/licenses/by-sa/3.0/
-->
# Best use of cocoa - Bronze award

Daniel Vik  
<daniel@vik.cc>  
<http://danielvik.com/>  


## Judges' comments:
### To build:

    make vik

This entry requires [Zlib](http://www.zlib.net/).

### To run:

#### Embed text (from file or command line):

    ./vik e base.png filename > encodedimg.png
    # or
    ./vik e base.png SomeRandomText > encodedimg.png

#### Extract the embedded text:

    ./vik d encodedimg.png

#### Embed a PNG into another

    ./vik e base.png source.png > encodedimg.png

#### Extract the embedded PNG:

    ./vik d encodedimg.png > restored.png

### Try:

    ./vik e ioccc.png chocolate.png > chocolate-in-ioccc.png
    ./vik e chocolate.png ioccc.png > ioccc-in-chocolate.png
    ./vik d chocolate-in-ioccc.png > restored-chocolate.png
    ./vik d ioccc-in-chocolate.png > restored-ioccc.png

### Selected Judges Remarks:

References to chocolate had no effect on judging this entry. We
guarantee it.

Can you discern hidden pieces of chocolate in chocolate-in-ioccc.png ?


## Author's comments:
Introduction
------------

This program is a  steganography application for embedding an image or text
into another image as well as extracting  the embedded image  or text back.
The program stores  the embedded  image or text in  the low bits of the RGB
values.

The program supports any 8 bit true color PNG images (RGB, RGBA, grayscale,
and grayscale+alpha). The output image is always 8 bit RGB.  When embedding
one image into another, the width and height needs to be the same.

The program only updates the IDAT and IHDR chunks of the source image.  Any
additional chunks are copied into the resulting image.

### Bonus Extractor:

For some reason the chocolate image seems to have some  special properties.
Apart from  being quite big  and a little bit noisy,  it appears  that when
embedded into  another image and extracted, the bitmap data is also a valid
brain$#@$ program. It is of course possible to get the bitmap data from the
extracted image, and run it through  any of the previous  winning brain$#@$
interpreters, but I thought it would be easier to include an interpreter in
the program  to avoid the hassle:

    ./vik e ioccc.png chocolate.png > encodedimg.png
    ./vik b encodedimg.png

It is of course also possible  to embed a brain$#@$ program  as a text file
(as explained above) and decode it, e.g.:

    ./vik e ioccc.png .+[.+] > encodedimg.png
    ./vik b encodedimg.png


### Obfuscation

I really wanted to keep  the program simple,  so instead of adding multiple
macros or helper methods that can be confusing,  I placed all functionality
in the main function. Main is called recursively and quite extensively, but
it gives  the benefit  that all  invocations of  the function  has the same
parameters, argv and argc.   This really helps readability, as a programmer
doesnt need to remember several variable or function names.   I also tried
to reduce the number of keywords,  and the program only  has four for-loops
followed by a single return statement.  There is a little bit of use of the
question mark operator,   but this is really  there to keep  the program as
simple as possible.


### Portability

The program is portable to most platforms that  have zlib  available.   The
only system dependency is that the program relies on writing binary data to
stdout.

By default, Microsoft compilers adds carriage returns to new lines,  and to
compile the program on this platform, the following line can be added after
the  variable  declarations  in  the  main  declaration  in  order  to  run
correctly:

    _setmode(_fileno(stdout), 0x8000);


### Limitations

The program doesnt have many error checks so passing in  invalid arguments
or images of mismatching sizes, or unsupported pixel formats will cause the
program to crash.


### Extendability

Since a lot of care was taken to keep the code simple,  it turned out to be
quite easy to extend functionality. I did include a small brain$#@$ after I
realized that the chocolate image had some interesting properties.

But there  is more functionality  I added that didnt  fit within  the size
limits and could not remain included.   For example,  I added  a method  to
format source code based on a PNG image.   So the format  of the program is
actually done by the program itself.

And to be honest,   the chocolate  image  did not have  a brain$#@$ program
embedded to begin with.   I added functionality to the  program to  embed a
brain$#@$  into a  PNG image and used it  to create the image provided with
the entry.

I also added a method to analyze PNG images,  to print the size and format,
as well as the scan line filters.

All these features  were quite easy to add,   much thanks to  the (actually
pretty good) design of the code.

--------------------------------------------------------------------------------
<!--
(c) Copyright 1984-2015, [Leo Broukhis, Simon Cooper, Landon Curt Noll][judges] - All rights reserved
This work is licensed under a [Creative Commons Attribution-ShareAlike 3.0 Unported License][cc].

[judges]: http://www.ioccc.org/judges.html
[cc]: http://creativecommons.org/licenses/by-sa/3.0/
-->
# Most surreptitious

Don Yang  
<omoikane@uguu.org>  
<http://uguu.org/>  


## Judges' comments:
### To build:

    make nyaruko

### To run:

    ./nyaruko [seed.txt] < original.bin > output.c
    bash output.c > key.c
    perl output.c > data.c

    cat key.c data.c > output.c

    gcc output.c -o output
    ./output > regenerated.bin

### Try:

    echo "A quick brown fox jumps over the lazy dog" | ./nyaruko > output.c
    perl output.c > data.c
    gcc -o data data.c
    ./data
    gcc -o output output.c
    ./output


### Selected Judges Remarks:

The judges have nothing to add that has not already been written
about in the spoiler.html.gz file!  :-)

## Author's comments:
Usage
=====
Nyaruko is a binary to text filter.  Given some input on stdin,
Nyaruko will produce C code that reproduces this input on stdout:

    ./nyaruko < original.bin > output.c
    gcc output.c -o output
    ./output > regenerated.bin

Output is encrypted, but both key and data are included in the output.
To separate the key from the data, run these commands:

    bash output.c > key.c
    perl output.c > data.c

The key-less data.c still compiles, but produces a different message
on stdout instead of the original input.  This message is a hint to
why the code is formatted the way it is.

To combine the key and data, concatenate them together in either
order:

    cat key.c data.c > output.c
    cat data.c key.c > output.c

By default, Nyaruko generates a unique random key for every message,
using /dev/urandom as the seed.  If given an extra command line
argument, Nyaruko will seed using that file instead of /dev/urandom:

    ./nyaruko seed.txt < input.bin > output.c

This makes the output key deterministic, allowing the same key to be
shared across different files.  On operating systems that do not have
/dev/urandom, users should always specify this extra seed argument to
avoid deterministic keys.


Features
========
Implementation details that makes Nyaruko more obfuscated than usual
programs:

   * Nyaruko recycles variables and buffers to reduce internal state.
     The variable names are also carefully chosen for mixed-case
     madness.
   * Nyaruko employs some preprocessor magic to share much of the same
     code and state between the encoder and decoder, and to increase
     occurrences of smileys ;)

Output code has these features:

   * Fits nicely under 80 columns, and does not contain any trigraphs.
   * Uses a fairly efficient encoding scheme, better than uuencode for
     files larger than ~13K, and better than base64 for files larger
     than 20K.
   * Encryption with ISAAC, a cryptographically secure pseudorandom
     number generator.
   * Trivial 3 language polyglot.

Code layout is meant to resemble Nyaruko, also known as Nyarlathotep,
the Crawling Chaos.  The most obvious thing to do with chaos is to
make a random number generator, and the most obvious thing to do with
a random number generator is to make one-time-pads for encryption.


Compatibility
=============
Nyaruko has these environment dependencies:

   * Requires ASCII character set.
   * Assumes sizeof(unsigned int) == 4.
   * Best viewed with tab stops set to 8 spaces.

Output code has the same dependencies, with the additional
requirement that the compiler must support arbitrarily long string
literals.  Maximum input size that can be encoded while still
producing standard-compliant output is ~276 bytes for C89, and ~3168
bytes for C99.

Nyaruko has been to verified to work with these compiler/OS
combinations:

   * gcc 4.4.5 on Linux (32bit and 64bit)
   * clang 3.1 on Windows (Cygwin)
   * gcc 4.5.3 on Windows (Cygwin)
   * gcc 4.5.3 on Windows (MingW)
   * gcc 4.3.5 on JSLinux
   * tcc 0.9.25 on JSLinux

Note that on MingW, stdin and stdout are not opened in binary mode by
default, this means Nyaruko may not faithfully encode files on MingW.


Extra files
===========

spoiler.html.gz - Contains full recording of how the code went from
blank state to an obfuscated program, gzipped to fit under 1MB.

--------------------------------------------------------------------------------
<!--
(c) Copyright 1984-2015, [Leo Broukhis, Simon Cooper, Landon Curt Noll][judges] - All rights reserved
This work is licensed under a [Creative Commons Attribution-ShareAlike 3.0 Unported License][cc].

[judges]: http://www.ioccc.org/judges.html
[cc]: http://creativecommons.org/licenses/by-sa/3.0/
-->
# Most functional

John Tromp  
<john.tromp@gmail.com>  
<http://tromp.github.io/>  


## Judges' comments:
### To build:

On a 32-bit machine:

    make tromp

On a 64-bit machine:

    make tromp64
    # And mentally substitute ./tromp64 for ./tromp everywhere below
    
### To run:

    cat ascii-prog.blc data | ./tromp -b
    cat binary-prog.Blc data | ./tromp

### Try:

    (cat hilbert.Blc; echo -n 1234) | ./tromp
    (cat oddindices.Blc; echo; cat primes.blc | ./tromp -b) | ./tromp
    cat primes.blc | ./tromp -b | ./primes.pl

### Selected Judges Remarks:

The judges dare to say that the data files this entry is processing
are more obfuscated than the entry itself.

## Author's comments:
This program celebrates the close connection between obfuscation and conciseness,
by implementing the most concise language known, Binary Lambda Calculus (BLC).

BLC was developed to make Algorithmic Information Theory, the theory of smallest programs,
more concrete. It starts with the simplest model of computation, the lambda calculus,
and adds the minimum amount of machinery to enable binary input and output.

More specifically, it defines a universal machine, which, from an input stream of bits,
parses the binary encoding of a lambda calculus term, applies that to the remainder
of input (translated to a lazy list of booleans,
which have a standard representation in lambda calculus),
and translates the evaluated result back into a stream of bits to be output.

Lambda is encoded as 00, application as 01, and the variable bound by the n'th
enclosing lambda (denoted n in so-called De Bruijn notation) as 1^{n}0.
That's all there is to BLC!

For example the encoding of lambda term S = \x \y \z  (x z) (y z),
with De Bruijn notation \ \ \ (3 1) (2 1),
is 00 00 00 01 01 1110 10 01 110 10

In the closely related BLC8 language, IO is byte oriented,
translating between a stream of bytes and a list of length-8 lists of booleans.

The submission implements the universal machine in the most concise manner conceivable.
It lacks #defines and #includes, and compiles to a (stripped) executable of under 6K in size.

Without arguments, it runs in byte mode, using standard in- and output.
With one (arbitrary) argument, it runs in bit mode, using only the least significant
bit of input, and using characters '0' and '1' for output.

The program uses the following exit codes:
0: OK; result is a finite list
5: Out of term space
6: Out of memory
1,2,3,4,8,9: result not in list form

The size of the term space is fixed at compile time with -DA

A half byte `cat'
=================

The shortest (closed) lambda calculus term is \x x (\ 1 in De Bruijn notation)
which is the identity function. When its encoding 0010 is fed
into the universal machine, it will simply copy the input to the output.
(well, not that simply, since each byte is smashed to bits and rebuilt from scratch)
Voila: a half byte cat:

      echo " Hello, world" | ./tromp
    Hello, world
 
Since the least significant 4 bits of the first byte are just arbitrary padding
that is ignored by the program,
any character from ASCII 32 (space) through 47 (/) will do, e.g.:

      echo "*Hello, world" | ./tromp
    Hello, world
 
Bad programs
============

If the input doesn't start with a valid program, that is,
if the interpreter reaches end-of-file during program parsing,
it will crash in some way:

      echo -n "U" | ./tromp
    Segmentation fault

Furthermore, the interpreter requires the initial encoded lambda term to be closed,
that is, variable n can only appear within at least n enclosing lambdas.
For instance the term \ 5 is not closed,
causing the interpreter to crash when looking into a null-pointer environment:

      echo ">Hello, world" | ./tromp
    Segmentation fault
 
Since these properties can be checked when creating BLC programs,
the interpreter doesn't bother checking for it.

A Self Interpreter
==================

The BLC universal machine may be small at 650 bytes of C
(952 bytes including layout), but written
as a self interpreter in BLC it is downright minuscule at 232 bits (29 bytes):

      01010001
       10100000
        00010101
         10000000
          00011110
           00010111
            11100111
             10000101
              11001111
              000000111
             10000101101
            1011100111110
           000111110000101
          11101001 11010010
         11001110   00011011
        00001011     11100001
       11110000       11100110
      11110111         11001111
     01110110           00011001
    00011010             00011010

The byte oriented BLC8 version weighs in at 43 bytes (shown in hexadecimal).

     19468
      05580
       05f00
        bfe5f
         85f3f
          03c2d
         b9fc3f8
        5e9d65e5f
       0decb f0fc3
      9befe   185f7
     0b7fb     00cf6
    7bb03       91a1a

      (cat uni8.Blc; echo " Ni hao") | ./tromp
    Ni hao

A prime number sieve
====================

Even shorter than the self-interpreter is this prime number sieve in 167 bits (under 21 bytes):

    000100011001100101000110100
     000000101100000100100010101
     11110111          101001000
     11010000          111001101
     000000000010110111001110011
     11111011110000000011111001
     10111000
     00010110
    0000110110

The n'th bit in the output indicates whether n is prime:

      cat primes.blc | ./tromp -b | head -c 70
    0011010100010100010100010000010100000100010100010000010000010100000100 

For those who prefer to digest their primes in decimal, there is oddindices.Blc,
which will print the indices of all odd characters (with lsb = 1)
separated by a given character:

      (cat oddindices.Blc; echo -n " "; cat primes.blc | ./tromp -b) | ./tromp | head -c 70
    2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97

A Space filling program
=======================

Program hilbert.Blc, at 143 bytes, is a very twisty "one-liner" (shown in hexadecimal):

    1818181   8111154   6806041   55ff041
    9d   f9   de   16   ff   fe   5f   3f
    ef   f615ff9   46   84   058117e   05
    cb             fe   bc             bf
    ee86cb9   4681600   5c0bfac   bfbf71a
         85   e0             5c   f4     
    14d5fe0   8180b048d0800e078   016445f
    fe                                 5f
    f7   ffffe5fff2fc   02f7ad97f5bf   ff
    ff   bf        ff   ca        af   ff
    7817ffa   df76695   4680601   57f7e16
              05             c1          
    3fe80b2   2c18581   bfe5c10   42ff805
    de   ec        06   c2        c0   c0
    60   8191a00167fb   cbcfdf65f7c0  a20

It expects n arbitrary characters of input, and draws a space filling Hilbert curve of order n:

      (cat hilbert.Blc; echo -n "1") | ./tromp
     _ 
    | |

      (cat hilbert.Blc; echo -n "12") | ./tromp
     _   _ 
    | |_| |
    |_   _|
     _| |_ 

      (cat hilbert.Blc; echo -n "123") | ./tromp
     _   _   _   _ 
    | |_| | | |_| |
    |_   _| |_   _|
     _| |_____| |_ 
    |  ___   ___  |
    |_|  _| |_  |_|
     _  |_   _|  _ 
    | |___| |___| |

      (cat hilbert.Blc; echo -n "1234") | ./tromp
     _   _   _   _   _   _   _   _ 
    | |_| | | |_| | | |_| | | |_| |
    |_   _| |_   _| |_   _| |_   _|
     _| |_____| |_   _| |_____| |_ 
    |  ___   ___  | |  ___   ___  |
    |_|  _| |_  |_| |_|  _| |_  |_|
     _  |_   _|  _   _  |_   _|  _ 
    | |___| |___| |_| |___| |___| |
    |_   ___   ___   ___   ___   _|
     _| |_  |_|  _| |_  |_|  _| |_ 
    |  _  |  _  |_   _|  _  |  _  |
    |_| |_| | |___| |___| | |_| |_|
     _   _  |  ___   ___  |  _   _ 
    | |_| | |_|  _| |_  |_| | |_| |
    |_   _|  _  |_   _|  _  |_   _|
     _| |___| |___| |___| |___| |_ 

A BrainFuck interpreter
=======================

The smallest known BF interpreter is written in... you guessed it, BLC,
coming in at 112 bytes (including 3 bits of padding):

	 od -t x4 bf.Blc 
	0000000          01a15144 02d55584               223070b7        00f032ff
	0000020          7f85f9bf        956fe15e        c0ee7d7f 006854e5
	0000040          fbfd5558        fd5745e0        b6f0fbeb 07d62ff0
	0000060          d7736fe1 c0bc14f1               1f2eff0b        17666fa1
	0000100          2fef5be8        ff13ffcf        2034cae1 0bd0c80a
	0000120          e51fee99        6a5a7fff        ff0fff1f d0049d87
	0000140          db0500ab 3bb74023               b0c0cc28 10740e6c
	0000160

It expects its input to consist of a Brainfuck program
(looking only at bits 0,1,4 to distinguish among ,-.+<>][ )
followed by a ], followed by the input for the Brainfuck program.

	  more hw.bf
	++++++++++[>+++++++>++++++++++>+++>+<<<<-]>++.>+.+++++++..+++.>++.<<+++++++++++++++.>.+++.------.--------.>+.>.]
	  cat bf.Blc hw.bf | ./tromp
	Hello World!

Curiously, the interpreter bf.Blc is the exact same size as hw.bf.

A BLC assembler
===============

Writing BLC programs can be made slightly less painful with this parser that
translates single-letter-variable lambda calculus into BLC:

	  echo "\f\x f (f (f x))" > three
	  cat parse.Blc three | ./tromp
	000001110011100111010

Converting between bits and bytes
=================================

THe program inflate.Blc and its inverse deflate.Blc allow us to translate between
BLC and BLC8.
If you assemble a byte oriented program, you'll need to compact it into BLC8:

So we could assemble an input reversing program as

	  echo "\a a ((\b b b) (\b \c \d \e d (b b) (\f f c e))) (\b \c c)" > reverse
	  cat parse.Blc reverse | ./tromp > reverse.blc

and change it to BLC8 with

	  cat deflate.Blc reverse.blc | ./tromp > rev.Blc
	  wc rev.Blc 
	0 1 9 rev.Blc

and then try it out with:

	  cat rev.Blc - | ./tromp
	Hello, world!
	^D
	!dlrow ,olleH

Symbolic Lambda Calculus reduction 
==================================

BLC8 program symbolic.Blc shows individual reduction steps on symbolic lambda terms.
Here it is used to show the calculation of 2^3 in Church numerals:

	  echo "(\f\x f (f (f x))) (\f\x f (f x))" > threetwo
	  cat parse.Blc threetwo | ./tromp > threetwo.blc
	  cat symbolic.Blc threetwo.blc | ./tromp
	(\a \b a (a (a b))) (\a \b a (a b))
	\a (\b \c b (b c)) ((\b \c b (b c)) ((\b \c b (b c)) a))
	\a \b (\c \d c (c d)) ((\c \d c (c d)) a) ((\c \d c (c d)) ((\c \d c (c d)) a) b)
	\a \b (\c (\d \e d (d e)) a ((\d \e d (d e)) a c)) ((\c \d c (c d)) ((\c \d c (c d)) a) b)
	\a \b (\c \d c (c d)) a ((\c \d c (c d)) a ((\c \d c (c d)) ((\c \d c (c d)) a) b))
	\a \b (\c a (a c)) ((\c \d c (c d)) a ((\c \d c (c d)) ((\c \d c (c d)) a) b))
	\a \b a (a ((\c \d c (c d)) a ((\c \d c (c d)) ((\c \d c (c d)) a) b)))
	\a \b a (a ((\c a (a c)) ((\c \d c (c d)) ((\c \d c (c d)) a) b)))
	\a \b a (a (a (a ((\c \d c (c d)) ((\c \d c (c d)) a) b))))
	\a \b a (a (a (a ((\c (\d \e d (d e)) a ((\d \e d (d e)) a c)) b))))
	\a \b a (a (a (a ((\c \d c (c d)) a ((\c \d c (c d)) a b)))))
	\a \b a (a (a (a ((\c a (a c)) ((\c \d c (c d)) a b)))))
	\a \b a (a (a (a (a (a ((\c \d c (c d)) a b))))))
	\a \b a (a (a (a (a (a ((\c a (a c)) b))))))
	\a \b a (a (a (a (a (a (a (a b)))))))

As expected, the resulting normal form is Church numeral 8.

Taking only the first line of output gives us a sort of BLC disassembler,
an exact inverse of the above assembler. The prime number sieve disassembles as follows:

	  cat symbolic.Blc primes.blc | ./tromp | head -1
	\a (\b b (b ((\c c c) (\c \d \e e (\f \g g) ((\f c c f ((\g g g) (\g f (g g)))) (\f \g \h \i i g (h (d f))))) (\c \d \e b (e c))))) (\b \c c (\d \e d) b)

Hardly any less obfuscated...

The last line of
    cat symbolic.Blc primes.blc | ./tromp | head -16
starts out as
    \a \b b (\c \d c) (\c c (\d \e d) (\d d (\e \f f) (\e e (\f \g g) ((\f (\g \h \i

The \a is for ignoring the rest of the input (to which the universal machine
applies the decoded lambda term). The \b b (..) (...) is the list constructor,
usually called cons, applied to a head (a list element) and a tail (another list).
In this case the element is (\c \d c), which represents the boolean true, and
which we use to represent a 0 bit. This is the bit that says 0 is not prime.
The next list element (following another cons) is (\d \e d). Another 0 bit,
this time saying that 1 is not prime. The third list element is (\e \f f),
a 1 bit, confirming our suspicion that 2 is prime. As is the next number,
according to (\f \g g). We can see that the tail after the first 4 elements
is still subject to further reduction. The bit for number 4 will show up
for the first time in line 30, as (\g \h g), or 0, as the result of zeroing
out all multiples of the first prime, 2.
Since my computer reaches swap hell before line 40, we can't see the next bit arriving,
at least not in this symbolic reduction.

Performance
===========

Performance is quite decent, and amazingly good for such a tiny implementation,
being roughly 50% slower than a Haskell implementation of the universal machine
using so-called Higher Order Abstract Syntax which relies on the highly optimized
Haskell runtime system for evaluation. Of course individual blc programs running
under the interpreter perform much worse than that same program written in Haskell.

Our interpreter copes well with extra levels of interpretation:

	  time cat primes.blc | ./tromp -b | head -c 210 > /dev/null
	real    0m0.043s
	  time cat uni.blc primes.blc | ./tromp -b | head -c 210 > /dev/null
	real    0m0.191s
	  time cat uni.blc uni.blc primes.blc | ./tromp -b | head -c 210 > /dev/null
	real    0m1.919s
	  time cat uni.blc uni.blc uni.blc primes.blc | ./tromp -b | head -c 210 > /dev/null
	real    0m23.514s
	  time cat uni.blc uni.blc uni.blc uni.blc primes.blc | ./tromp -b | head -c 210 > /dev/null
	real    4m52.700s

Obfuscation
===========

Obfuscation is due entirely to conciseness. Some questions to ponder:

Which of the term space codes 0,1,2,3 serves multiple purposes?

Why is the environment pointer pointing into the term space?

What does the test u+m&1? do?

How does the program reach exit code 0?

And how do any of those blc programs work?

Portability
===========

The program freely (without casting) converts between int and int\*, causing
many warnings;
  note: expected int * but argument is of type int
  warning: assignment from incompatible pointer type
  warning: assignment makes integer from pointer without a cast
  warning: assignment makes pointer from integer without a cast
  warning: incompatible implicit declaration of built-in function calloc
  warning: incompatible implicit declaration of built-in function exit
  warning: passing argument 1 of d makes pointer from integer without a cast
  warning: passing argument 1 of p makes pointer from integer without a cast
  warning: pointer/integer type mismatch in conditional expression

Avoiding these would make the program substantially longer,
and detract from its single minded focus on conciseness.

It implicitly declares functions read, write, exit and calloc, the latter two incompatibly.
32 bit and 64 bit executables are separate Makefile targets, involving a change
from int to long and from a hardcoded sizeof of 4 to 8.

The program has been tested to work correctly on Linux/Solaris/MacOSX both in 32 and 64 bits.

How the program works
=====================

See the file how13.

Acknowledgements
================

Christopher Hendrie, Bertram Felgenhauer, Alex Stangl, Seong-hoon Kang,
and Yusuke Endoh have contributed ideas and suggestions for improvement.

References
==========

Binary Lambda Calculus
<http://en.wikipedia.org/wiki/Binary_lambda_calculus>

G J Chaitin, Algorithmic information theory, Volume I,
Cambridge Tracts in Theoretical Computer Science, Cambridge University Press, October 1987.
<http://www.cs.auckland.ac.nz/~chaitin/cup.html>

Jean-Louis Krivine. 2007.
A call-by-name lambda-calculus machine
Higher Order Symbol. Comput. 20, 3 (September 2007), 199-207.
<http://www.pps.univ-paris-diderot.fr/~krivine/articles/lazymach.pdf>

--------------------------------------------------------------------------------
<!--
(c) Copyright 1984-2015, [Leo Broukhis, Simon Cooper, Landon Curt Noll][judges] - All rights reserved
This work is licensed under a [Creative Commons Attribution-ShareAlike 3.0 Unported License][cc].

[judges]: http://www.ioccc.org/judges.html
[cc]: http://creativecommons.org/licenses/by-sa/3.0/
-->
# Balanced use of obfuscation - Gold award

Adar Zeitak  
<aa4z2@walla.co.il>  


## Judges' comments:
### To build:

    make zeitak

### To run:

    ./zeitak < file.c

where file.c is the file to be checked for nesting errors. For example, you may
try incorrect.c and the program itself.

### Try:

    ./zeitak < zeitak.c
    ./zeitak < incorrect.c

### Selected Judges Remarks:

This is an extremely subtle and twisted piece of Gold award winning code!

The judges had spent a considerable amount of time analyzing this entry.
At one point we spent
[18 minutes](https://twitter.com/ioccc/status/252162898800033792)
just to understand 18 key characters of this code.

The file zeitak\_deobfucate.c provides a version that has been slightly
deobfuscated.  You may find reading that file helpful in your attempt
to understand this extremely subtle entry.

## Author's comments:
### Nesting Errors Detector

#### What does it do

As you have probably understood by looking at the source\*, this program has
something to do with parenthesis (and equality of opening and closing
parenthesis, if you look close enough). It goes over the file given to it and
checks that every opening (, [, or { has a matching closing one and
vice versa. It also checks that every " or ' is closed.

If an error is detected, an error message will be printed. If the problem
is a superfluous closing bracket, it will even print a few characters
around it's position.

* Make sure you view the source with 4 spaces tab width.

#### Features

* Ignores parenthesis inside strings or character constants, so no errors
  will be detected in the following line:

        printf(")");

*   Doesn't get confused by the 1984/anonymous entry!

#### Mis-Features

*   Escapes (e.g. `\"`) are ignored, so the following line will produce
    an error:

        printf("\"");

#### Obfuscation

IOCCC winners already contain entries without digits, control-flow
keywords and certain operators in their source. This entry has an
even more limited source, that is:

*   Without any digits.
*   Without any character constants.
*   Without using functions from headers other than stdio.
*   Without any control-flow keywords (not even the ?: operator).
*   Without any arithmetic or logic operators!

So, what's left? Parenthesis, and lots of them, as looking at the source will
reveal immediately. The main obfuscation is building the whole algorithm using
only function calls, typecasts, array lookups and pointer operators.

Additional obfuscations include:

*   Extensive reuse of identifiers: Macros share names with variables, inner
    curly braces scopes contain variables with names identical to those in the
    outer scopes and some of the variables have different uses in different
    parts of the program. Even the large array has more than one use.
*   A complicated data structure with "unused" fields.
*   Mostly one-letter identifiers.
*   Complex recursion: A function might call itself once, twice, or not at all.

#### Compilation/Running Notes

*   The program requires `char` to be one byte and pointers to be
    at least two bytes long.

*   The program was tested on the following platforms:

**  Ubuntu 9.04 32-bit with GCC
**  Windows 7 32-bit with GCC
**  Windows 7 32-bit with OpenWatcom

--------------------------------------------------------------------------------
<!--
(c) Copyright 1984-2015, [Leo Broukhis, Simon Cooper, Landon Curt Noll][judges] - All rights reserved
This work is licensed under a [Creative Commons Attribution-ShareAlike 3.0 Unported License][cc].

[judges]: http://www.ioccc.org/judges.html
[cc]: http://creativecommons.org/licenses/by-sa/3.0/
-->
# Most elementary use of C - Silver award

Tsukasa Hamano  
<hamano@cuspy.org>  


## Judges' comments:
### To build:

    make hamano

### To run:

    ./hamano < textfile > output.pdf

### Try:

    ./hamano < hint.text > hint.pdf

    # You can read output.pdf with PDF reader
    acroread hint.pdf
    # or
    evince hint.pdf

    # deobfuscate
    gcc -xc hint.pdf -o hint
    ./hint

    # Of course, You can obfuscate c code
    echo 'void main(){puts("Hello World!");}' | ./hamano > hello.pdf
    gcc -xc hello.pdf -o hello2
    ./hello2 | gcc -xc - -o ./hello3
    ./hello3

### Selected Judges Remarks:

This entry treads into a new territory for IOCCC - generating PDF files.

The originally submitted entry could have been thought of as a "Best abuse of
Ghostscript" winner.  :-)

The source code and rendered pages are obfuscated for humans (where
is the font?), and the submitted entry created PDF files that left Ghostscript
confused.

The results can be viewed with Acrobat Reader,
[evince](http://en.wikipedia.org/wiki/Evince) and Apple's Preview.

The updated version can also be viewed using Ghostscript.

There is something strange about the little flags in the output.
A search of English literature will provide a hint.  The conclusion
you might draw is too elementary.  :-)

So what do those flags really mean?

The [Dancing men algorithm][1] might be useful.

Don't forget to take a look at the generated PDF, perhaps you might even want
to compile the output with a C compiler.  When you run it, what does it
output?


## Author's comments:
This program obfuscate text file into PDF file with Dancing men
algorithm.

<http://en.wikipedia.org/wiki/The_Adventure_of_the_Dancing_Men>

Probably, the output PDF file is compliant with PDF 1.3. And also
available to compile as C code.

I've been tested with GCC 4.7 and Clang 3.0 on Linux, and following
PDF Reader:

 * Adobe Acrobat Reader
 * Evince
 * Ghostscript
 * Xpdf

### Obfuscations
This program is obfuscated by using classical methods.
But can you find out the embedded font from fragmented glyph?

--------------------------------------------------------------------------------
<!--
(c) Copyright 1984-2015, [Leo Broukhis, Simon Cooper, Landon Curt Noll][judges] - All rights reserved
This work is licensed under a [Creative Commons Attribution-ShareAlike 3.0 Unported License][cc].

[judges]: http://www.ioccc.org/judges.html
[cc]: http://creativecommons.org/licenses/by-sa/3.0/
-->
# Best way to lose a life

J. David Lowe  
434 Tenney Drive  
Rogue River, OR  
97537  
<j.david.lowe@gmail.com>  
<http://www.pootpoot.net/>  


## Judges' comments:
### To build:

    make dlowe

### To run:

    ./dlowe

### Try:

    ./dlowe
    # Watch for a while if you like, then press a key within the window
    # Use up and down keys to escape death

### Selected Judges Remarks:

The judges lose playing this game. This entry wins!

OS X users running Mountain Lion and later will need to download and install:

	http://xquartz.macosforge.org/landing/

Q: How did we get past the variadic macro problem on a Mac?

A: Don't use -pedantic-errors in the Makefile.


## Author's comments:
# Conway's Game of DEATH

This is a challenging, fast-paced arcade game, based on the famous Game of
Life.

## Story

In the game, you are Mr.C, a lightweight spaceship making a futile dash for
escape from the rigid rules and predictability of life in the B3/S23 universe.

Use the up and down arrow keys to steer: collisions are fatal for Mr.C! Learn
to spot incoming gliders, skim the surfaces of beehives and blocks, and give
blinkers plenty of space. Things get crazier as Mr.C picks up speed... can he
escape?

No. There is no winning. Sadly for Mr.C, this universe goes on forever. Just
see how far you can make it!

Press 'q' any time to quit.

## Features

* casual gameplay
* infinite, procedurally generated universe
* progressive difficulty
* animated splash screens

## Limitations

* Flicker, especially at high speeds, and in spite of "double-buffering" (X11
  doesn't make it possible to lock drawing to the display refresh rate.)
* Cannot be run outside of the directory containing the data files (splash.d,
  dead.d and sprites.d).
* Cannot build or run without X11 (or an X11 compatibility layer).

## Wish List

* Score keeping
* Color
* In-game instructions
* Sound

## Hosts Tested

* Darwin 10.8.0 i386 (clang 1.6 and gcc 4.2.1)
* Linux 2.6.32 i686 (clang 1.1 and gcc 4.4.3)
* Linux 3.2.0 x86\_64 (clang 3.0 and gcc 4.6.3)

## Obfuscations

The code is formatted into a 14-cell shape which will evolve into a glider in
19 generations.

Lots of globals, including a global struct whose members have the same names
as global variables.

Global variables getting reused in different contexts.

Huge and convoluted expressions, abusing ternary operators and operator
precedence.

Lots of magic numbers, abuse of the relationships between magic numbers, and
abuse of the arithmetic properties of magic numbers.

--------------------------------------------------------------------------------
<!--
(c) Copyright 1984-2015, [Leo Broukhis, Simon Cooper, Landon Curt Noll][judges] - All rights reserved
This work is licensed under a [Creative Commons Attribution-ShareAlike 3.0 Unported License][cc].

[judges]: http://www.ioccc.org/judges.html
[cc]: http://creativecommons.org/licenses/by-sa/3.0/
-->
# Most notable and best tool

Alex Deckmyn  
<alex.deckmyn@gmail.com>  


## Judges' comments:
### To build:

    make deckmyn

### To run:

    # A shell interpreter with proper backtick interpolation is required
    ./deckmyn "`cat deckmyn.c`" "`cat musicfile.txt`" > sheetmusic.pbm

### Try:

    ./deckmyn "`cat deckmyn.c`" "`cat example_greensleeves`" > greensleeves.pbm

### Selected Judges Remarks:

The C of this entry is definitely sharp. The program cleverly uses its own
source at runtime to define the notes, time signature and accidental bitmaps.

In addition to sheet music, this program is also able, given the right input,
to generate an image of a 10-pin DIP chip (a sound processor?).

Ironically, the way this entry is called from the command line is an abuse of C Shell.
Please use Bourne-family shells to run this entry.

## Author's comments:

Example use
===========

You need the source code and example input (either one of the example files, or manual input as below) ready. And a program capable of showing .pbm bitmap format.

    ./deckmyn "`cat deckmyn.c`" "`cat example_greensleeves`" > greensleeves.pbm
    display greensleeves.pbm

    ./deckmyn "`cat deckmyn.c`" "KF m44c4 c4 g4 g4 :  a4 a4 g2 :; " > short_bass.pbm
    display short_bass.pbm

Description
===========

Every major C competition should have an entry capable of producing C major.
This is a music notation program. It produces bitmaps (.pbm) of music based on ASCII input. A full manual is added as a separate file. Some musical examples are also included.

The program is capable of printing notes, rests, (double) bar lines and accidentals on a single melodic line (multiple staves). No chords, polyphony etc.

The program expects *two command line arguments*. The first is a (very long) string that contains the complete music font. Note that it should *not* be given as a file name! The default music font is encoded in the (whitespace of the) source code deckmyn.c itself. Therefore, the first argument should be "`cat deckmyn.c`".

The second command line argument is the music itself. This is, again, a string, not a file name. All music signs are entered as tokens of exactly 3 characters. The code is very sensitive to bad spacing! So for instance, if you use a file to write the music (e.g. example\_greensleeves), you should keep in mind that newline is also a character! 


Internals
=========

To minimise the memory footprint, this program has *no variable declarations at all*, except for the arguments to main(). The only available memory space is from the command line arguments and count (argv and argc). Parts of argv are cast as integer when values under 0 or beyond 127 are expected.

The "music font" is defined by the source code itself. The first few lines are not part of the font definition, as this memory space will modified by the program. (So as required by the rules, it is only a (memory) copy of the source code that is modified.)

As there is no memory available, output is directly to stdout, byte by byte, from the top left to the bottom right pixel.


LIMITATIONS
===========

The memory locations of argv are used for various purposes. Therefore, the program name (default "deckmyn") must be *at least 4 characters long*, including possibly the path. This, along with the ending '\0', gives minimum 5 bytes of useful memory space. Otherwise, the program may attempt to write outside the string. 

The code is quite sensitive. Errors in the input can lead to strange results. The code does not read beyond the end of the music input, but that is about the only error checking available. Any input that is not according to the rules in the MANUAL, may cause errors. 

The program has no special hardware limitations or requirements, other than 8bit char (signed or unsigned) and two's complement negatives. 

The limitations of using char as counters for e.g. the number of music staves are minor. 127 staves to a page is rather a lot.


Obfuscations
============

The code has no declared variables other than the command line variables. Not even pointers (we all know how messy code can get with too many pointers!). As more than one variable needs values beyond 127, parts of the command line memory are cast as integer using a macro.

- The formatting of the code is in fact necessary, as this is the definition of the music font. It is therefore not an obfuscation.
- The use of only argv/argc as memory locations is a matter of reducing the memory footprint. Again, it is not an obfuscation.
- Calling the only remaining variables, and the two defined macros, c and C, is merely a matter of conforming to the standard WYSIWYG paradigm common in commercial notation programs (What You C is What You Get). So once again it is not an obfuscation. Anyway, it's a C coding contest, right?
- Randomly using the numerical (ASCII) value for characters is compensated for by replacing some numbers by a character representation. On average, therefore, it is not an obfuscation.
- Randomly changing the way the elements of argv are addressed is a matter of maintaining a diversified code base. It is therefore not... Oh allright.
- The actual output of the music is done by one print command including a 800+ character nested conditional expression.
- printf is also used for its return value.


--------------------------------------------------------------------------------
<!--
(c) Copyright 1984-2015, [Leo Broukhis, Simon Cooper, Landon Curt Noll][judges] - All rights reserved
This work is licensed under a [Creative Commons Attribution-ShareAlike 3.0 Unported License][cc].

[judges]: http://www.ioccc.org/judges.html
[cc]: http://creativecommons.org/licenses/by-sa/3.0/
-->
# Best short program

Seonghoon Kang  
<kang.seonghoon@mearie.org>  


## Judges' comments:
### To build:

    make kang

### To run:

    echo "full spelling of an English cardinal numeral less than a quadrillion" | ./kang

### Try:

    echo Nineteen hundred and eighty-four | ./kang
    echo uno | ./kang
    echo trois | ./kang
    echo fier | ./kang
    echo "shest'" | ./kang

### Selected Judges Remarks:

The judges were able to appreciate the Indo-European language family
relation by making this entry successfully recognize *some* French,
German, Italian, Russian, and Spanish numerals.

Also worth mentioning is this entry's ability to understand the
colloquial year numbers of the last millennium.

We've added a linefeed to the print format for convenience.


## Author's comments:
## Synopsis

This short program reads a spelt number (e.g. `forty-two`) and writes a
corresponding decimal number (e.g. `42`). Too long for one-liners, alas,
but it still qualifies as a *short* program as it has less than 0x100 bytes.

It accepts a variety of spelt numbers:

* It correctly handles `zero`.
* Hyphen does not make a difference: `forty-two` and `forty two` are same.
  So does period or comma.
* Cases do not make a difference either: `TWO`, `Two`, `two` are same.
* `one` and `a` are interchangeable: `one hundred` and `a hundred` are same.
* `and` is optional: `one hundred twenty-three` and `one hundred and twenty-three`
  are same.
* It supports every non-negative integer less than 10<sup>15</sup>-1. It uses
  the small scale (i.e. American): `billion` is 10<sup>9</sup> and `trillion` is
  10<sup>12</sup>.

It does *not* accept some spelt numbers, which I found mostly irrelevant:

* A bare `hundred`, `thousand` etc. do not work.
* `one million million` does not work. Get used to `one trillion`!

## Requirements

This program is quite portable, only requiring the following:

* The signature `int main(int, int)` should be accepted by the linker.
* `char` should be at least 8 bits long (as dictated by the standard), `int`
  should be at least 32 bits long, `long long` should be at least 64 bits long.
* Both the compiler and execution environment should use an ASCII-compatible
  character set and two's complement representation.
* Overflow and underflow on `char` should wrap around, if your `char` is unsigned.
* [A trustworthy compiler][trustingtrust].

[trustingtrust]: http://cm.bell-labs.com/who/ken/trust.html

The design of the program explicitly allows for `EOF` which does not equal to -1
(it has to be negative per the standard) and both signed and unsigned `char`,
for example. Furthermore it is endian-independent.

## Obfuscations

Many obfuscations used are typical for standard IOCCC entries:

* Two arguments from `main` function are reused as normal variables.
* Every conditional has been replaced with `?:` ternary operator and `||`
  short-circuiting operator.
* It has exactly three nested `for` loops and nothing else.
* Common two's complement tricks: `~-a` instead of `a-1`,
  `~a?...:...` instead of `a!=-1?...:...`, etc.
* Comma operators (`,`) for multiple statements. The number of them is
  minimized, however, as it is too easy to (ab)use them.
* It lacks most parentheses around bitwise and arithmetic operators. It was
  originally written for shortness so parentheses were **EVIL**.
* `n["string"]` instead of `"string"[n]`. Both are fine for this program but
  I went to the former just for fun.
* Utter lack of any kind of layouts. (Oh, except for the first column.)

Other obfuscations are more subtle:

* The string `"1+DIY/.K430x9G(kC["` is 18 bytes long, but actually 19 bytes
  including the final null character are used.
* It internally represents numbers as hexadecimal. When the input is `two
  hundred and three`, it actually writes 0x203 as hexadecimal.
* Some variables (notably, `n`) have dual uses.
* The magic number [42][hhgg] makes an appearance.
* It has a long long numb-`main`-er within it!

[hhgg]: http://en.wikipedia.org/wiki/Answer_to_The_Ultimate_Question_of_Life,_the_Universe,_and_Everything

But the most important obfuscation is the clever construction of lookup table.
The program uses 11 different characters required for recognizing 22 lexemes:

	zero        one         tw-         th(i)r-     fo(u)r-     fi-         six-
	seven-      eigh-       nin-        ten         eleven      twelve
	hundred(s)  thousand(s) million(s)  billion(s)  trillion(s)
	a           and         -teen       -ty

So that they are internally represented as like:

	r        n        tw-      tr-      fr-      f-       s-
	sn-      g-       nn-      tn       ln       twl
	nr(s)    tsan(s)  lln(s)   blln(s)  trlln(s)
	a        an       -tn      -ty

The stemmer recognizes the longest matching prefix, so every lexeme can be
recognized by at most three characters (e.g. `trl` instead of `trlln`). This is
also handy for ignoring plurals. But that would make that the table does not fit
in the printable byte---11<sup>2</sup> is already almost 2<sup>7</sup>!

The trick is to use octal; three characters (`a`, `b` and `g`) are interpreted
as sequences of two characters (`ny`, `nn` and `nw` respectively). Asides from
a smaller lookup table, it has many good consequences:

* Both `a` and `and` share the common prefix, `ny`, and can be discarded
  altogether. Note that `ny` itself does not appear from other entries.
* `thousand` is interpreted as `tsan`, which is equivalent to `tfyn` in the
  octal scheme. As it is the only entry with `tf` prefix, it can be shorten by
  one character.

Having said this important trick, other details should be relatively easier to
follow. The order of lookup table, for example, is very important,
and the biggest constant 6177 is not arbitrarily chosen.

## Acknowledgement

[Removed for proper judgement: I'll fill this section if I do win.]

[Note: If you think you've seen this program elsewhere, you are probably right;
I'm submitting a program I have published years ago (and I have written myself,
of course). Neither rules nor guidelines disallow such a resubmission, so I guess
it's fine.]


--------------------------------------------------------------------------------
<!--
(c) Copyright 1984-2015, [Leo Broukhis, Simon Cooper, Landon Curt Noll][judges] - All rights reserved
This work is licensed under a [Creative Commons Attribution-ShareAlike 3.0 Unported License][cc].

[judges]: http://www.ioccc.org/judges.html
[cc]: http://creativecommons.org/licenses/by-sa/3.0/
-->
# Most complex ASCII fluid - Honorable mention

Yusuke Endoh  
<mame@ruby-lang.org>  
<https://github.com/mame/>  


## Judges' comments:
### To build:

    make endoh1

### To run:

    ./endoh1 < configuration.txt

### Try:

    ./endoh1 < endoh1.c

    ./endoh1 < pour-out.txt

    ./endoh1 < fountain.txt

### Selected Judges Remarks:

Let's play Jeopardy!

*   A: An obfuscated program that deals with complex numbers and produces animated ASCII graphics.
*   Q: What is a Mandelbrot simulator?

Bzzzt!

Such heavily squeezed fluid simulation (this is parsed uniquely
as fluids are not squeezable) has a few quirks that the judges were
happy to experiment with.

One configuration file was inspired by an [XKCD what if? entry](http://whatif.xkcd.com/6/).

## Author's comments:
### Synopsis

**DO NOT FORGET "-DG=1 -DP=4 -DV=8"** and make your terminal window larger
than 80 x 25.

    gcc endoh1.c -DG=1 -DP=4 -DV=8 -D_BSD_SOURCE -o endoh1 -lm
    ./endoh1 < endoh1.c
    ./endoh1 < logo.txt
    ./endoh1 < column.txt
    ./endoh1 < pour-out.txt
    ./endoh1 < tanada.txt


### What it is

    ,___. ,.       ,.    ,.   ,___. ,.              ,.       ,.
    |/--' ||       `'    ||   |/--' `'              ||       |\_.
    |\__. || ,. ,. ,. ,__/|   |\__. ,. ,____. ,. ,. ||  ,_.  |/-'  ,_.  ,__.
    |/--' || || || || |/-\|   `--\| || |/\/\| || || || ,/-\. ||   ,/-\. |/-\.
    ||    || `\_/| || |\_/|   ,__/| || |||||| `\_/| || `\_/\.`\_. `\_/' || `'
    `'    `'  `--' `' `---'   `---' `' `'`'`'  `--' `'  `-'`' `-'  `-'  `'


     ,.,.                      ,.,.
    ,/\/\. ,.       ,.    ,.  ,/\/\. ,.              ,.      ,__.
    |||#/' ||       `' ,_.||  |||#/' `',_.,__.       ||      ||\\.        ,.
    |||#\. || ,. ,. ,.,/#|||  |\//\. ,.|#||##| ,. ,. || ,.,. |\/-' ,.,. ,.|\.
    |\/--' ||,/\.|| |||#/\/|  `\#||| |||#||/\|,/\.|| ||,/'`\.|#|  ,/'`\.|\/-\.
    `\|    ||`\#||| |||#||\|  ,//\/| ||`\|||||`\#||| ||`\.,/\/\|,.`\.,/'`\| `'
     `'    `' `-'`' `'`-'`-'  `-'`-' `' `'`'`' `-'`' `' `'`--'`'`' `'`'  `'


    ,_.,_. ,.       ,.    ,.  ,_.,_. ,.              ,.      ,.
    |#||#| ||       `'    ||  |#||#| `'              ||      ||,_.
    ||\/#| ||,.  ,. ,.,_.,/|  |\||#| ,.,_.,__.,.  ,. || ,.,. |||#| ,.,. ,.,_.
    |||##| ||||  || |||#||#|  |#||#| |||#||##|||  || ||,/||\.||`-',/||\.|||#\.
    ||`--' ||`\_.|| |||\||#|  |#||#| ||||'||\|`\_.|| ||`\||#|`\.,.`\||/'||`--'
    `'     `' |#||| `'|#||#|  |#||#| `'`' `'`' |#||| `' |||/' |||| |||| `'
              `-'`'   `-'`-'  `-'`-'           `-'`'    `'`'  `'`' `'`'


This program is a fluid simulator using "Smoothed-particle hydrodynamics (SPH)"
method.

<http://en.wikipedia.org/wiki/Smoothed-particle_hydrodynamics>

The SPH particles represent the fluid flow.  Particles have information about
the position, density, and velocity.  In every simulation step, they are
changed by pressure force, viscosity force, and external force (i.e., gravity).

This program reads a text from standard input, and uses it as an initial
configuration of the particles.  The character `#` represents "wall particle" (a
particle with fixed position), and any other non-space characters represent
free particles.

The compilation options `-DG=1 -DP=4 -DV=8` represent, respectively, the factor
of gravity, pressure, and viscosity.  By changing their values, you can see
different fluid behavior.

"Marching square"-like algorithm is used to render the particles.

<http://en.wikipedia.org/wiki/Marching_squares>


### Portability

The program requires a C99 compiler; it uses `complex` types and one-line
comments.  It also uses `usleep`, which may require `-D_BSD_SOURCE` or somewhat
to build with no warning.  Under these conditions, it should be portable.
At least, recent compilers with `-std=c99 -Wall -W -Wextra -pedantic` says
nothing.

    gcc -DG=1 -DP=4 -DV=8 -D_BSD_SOURCE -std=c99 -Wall -W -Wextra -pedantic endoh1.c
    clang -DG=1 -DP=4 -DV=8 -D_BSD_SOURCE -std=c99 -Wall -W -Wextra -pedantic endoh1.c

I expect it to work in any Unix-like environment.  VTxxx/ANSI sequences are
used to clear screen and move cursor to home.

I've tested with gcc-4.6.3 and clang-3.0 on Linux (Ubuntu 12.04)
and gcc-4.5.3 and clang-3.1 on Cygwin.  On Cygwin, gcc and clang complain about
a usage of `I` (complex's imaginary unit), but I bet this is cygwin's issue;
it is surely a C99 feature.


### Obfuscation w/ Spoiler

First of all, the source code itself serves as an initial configuration.
Preprocessing directives (such as `#include`)'s `#` serve as walls.

This program uses `double complex` to represent any 2D vector.  But, note that
x-axis and y-axis is swapped (real axis = y-axis, imaginary axis = x-axis).
The purpose of swapping is not only obfuscation, but also short coding: for
example, to add gravity to total force, `force += G` suffices, rather than
`force += G*I`.
(Incidentally, you can exert horizontal gravity by using, such as, `-DG=I`)

Every five entries of `double complex a[]` contain information of one particle:
position, wall-flag, density, force, and velocity, in turn.

You can use `G`, `P`, and `V` as a guide to find the calculation code of
gravity, pressure, and viscosity forces.

Though some assignments may look meaningless, it is actually meaningful; it
extracts "integer part of real part" from a complex value by assigning (and
casting) it to an integer-type variable.


### Notes about Additional Files

"logo.txt" is a source of the logo in this remark file.

"column.txt" is a water column collapse, which is a popular demo of SPH.

"pour-out.txt" pours you a cup of tea.

"tanada.txt" simulates "Terrace farming".  ("Tanada" means a "terraced rice
fields" in Japanese.)

"clock.txt" is a "water" clock created by HAMANO Tsukasa.

Other \*.txt files are due to the judges.


"endoh1\_color.c" is a variant that shows the density by using terminal 256
colors.


### Acknowledgment

I would like to thank my wife @hirekoke for her teaching me the SPH method.

The judges <strike>ordered</strike> suggested creating a color version
after the judgment.

The judges and HAMANO Tsukasa (The silver medalist at this IOCCC) kindly
provided many configuration files.

--------------------------------------------------------------------------------
<!--
(c) Copyright 1984-2015, [Leo Broukhis, Simon Cooper, Landon Curt Noll][judges] - All rights reserved
This work is licensed under a [Creative Commons Attribution-ShareAlike 3.0 Unported License][cc].

[judges]: http://www.ioccc.org/judges.html
[cc]: http://creativecommons.org/licenses/by-sa/3.0/
-->
# Most useful obfuscation

Qiming Hou  
<hqm03ster@gmail.com>  
<http://www.houqiming.net>  


## Judges' comments:

### To build:

    make hou

### To run:

    ./hou syntax-file file-to-process

### Try (Unix):

The results are best viewed in a 80x25 console with ANSI colors.

    less hou.c

    ./hou ansi.txt hou.c | less -r

    ./hou chk.txt hou.c | wc

    ./hou markdown.txt remarks.markdown > remarks.htm
    your-browser remarks.htm

### Try (Windows):

    copy header.htm hou.htm /y
    hou html.txt hou.c >> hou.htm
    start hou.htm

### Selected Judges Remarks:

What a versatile entry! It can be used to check the size of IOCCC entries *and* to publish them as HTML.

For extra credit: what is the meaning of the number 2321237?


## Author's comments:

### Disclaimer

The reviewer may have already noticed that the 2nd page of this program is a dense blob, which is discouraged by the contest rules. We wish to point out that a majority of state-of-art programming editors support syntax highlighting, which should be enabled when reading this entry. Anticipating that the reviewer's preferred color setting may produce a suboptimal visual effect, a few syntax files are provided to highlight the source code under an author-provided setting, using the submitted program itself. Syntax highlighting would also visually improve the 3rd page.

The code may throw a few warnings due to formating constraints. The author did try to remove warnings under gcc and Visual Studio, though.

The author does not own the original anime series where the embedded ASCII arts come from. For comparison, original non-ASCII art depictions of the relevant characters and objects can be found by googling the embedded text messages.

### Syntax files

The syntax file consists of a number of rewriting rules. Each rule consists of a regular expression, a space, a format string, and a newline. All text matching the regular expression would be replaced by the format string. In case of a conflict, rules appearing earlier would take precedence. One can refer to the original text in the format string using "%s". Other "%" characters in the format string must be escaped with another "%". The space character can be used in the regular expression by escaping it with [] or "". 

The following regular expression operators are supported:

    () [] * + ? | ""

For example, one can use the following expression to match a certain declaration statement in hou.c:

    "char"[ *]*[a-zA-Z_][0-9a-zA-Z_]*[ ]*((=[0-9a-zA-Z_ ]+)|(\[[0-9a-zA-Z_ ]*\]))?[ ]*(,[ *]*[a-zA-Z_][0-9a-zA-Z_]*[ ]*((=[0-9a-zA-Z_ ]+)|(\[[0-9a-zA-Z_ ]*\]))?[ ]*)*;

The regex engine is also algorithmically efficient. To illustrate the point, ansi.txt contains a pathological expression [2] that guarantees a hang for the competing Perl engine while matching itself. Try to compare these two engines:

    ./hou ansi.txt ansi.txt
    perl patho.pl < ansi.txt

Finally, there are a few limitations...


- The only escape sequence supported is \n and it doesn't work in [].
- The maximum file/rule size is a linear function of the hard-coded constant M.
- Single-character matches at the end of file may be missed.
- The operator | doesn't obey precedence rules and some extra ()s may be required.
- Incorrect syntax files are not tolerated.
- The program relies on ASCII.

### Why obfuscated

The first layer of obfuscation comes from the challenge of embedding a large ASCII art in a dense blob. The entire art is composed using only keywords, strings and character constants. That results in a number of otherwise useless defines and quite a number of unconventionally written constants. While the preprocessor may remove the former, the later would remain regardless of beautification and preprocessing.

The second layer of obfuscation comes from the need to squeeze a reasonably powerful regex engine into the remaining area that isn't occupied by excessive keywords and useless constants. To achieve this, the regex compiler is written using the same threaded virtual machine [1] that parses the regex. Due to compiler limitations, the generated VM code also ends up obscured by a large amount of spaghetti branches and virtual thread creations. Finally, the VM in [1] is extended to track multiple expression matches for the actual formating.

As an extra tweak, the text message actually does something useful. Remove the "Make a contract with me" catch line and the program would cease to function.

### References

[1] [Russ Cox, Regular Expression Matching: the Virtual Machine Approach](http://swtch.com/~rsc/regexp/regexp2.html)

[2] [Regular Expression Matching Can Be Simple And Fast (but is slow in Java, Perl, PHP, Python, Ruby, ...)](http://swtch.com/~rsc/regexp/regexp1.html)

--------------------------------------------------------------------------------
<!--
(c) Copyright 1984-2015, [Leo Broukhis, Simon Cooper, Landon Curt Noll][judges] - All rights reserved
This work is licensed under a [Creative Commons Attribution-ShareAlike 3.0 Unported License][cc].

[judges]: http://www.ioccc.org/judges.html
[cc]: http://creativecommons.org/licenses/by-sa/3.0/
-->
# Most GIFted expressions

Philip Blakely  
Cambridge, UK  
<pmblakely@gmail.com>  


## Judges' comments:
### To build:

    make blakely

### To run:

    ./blakely "RPN formula" resolution > output.gif

### Try:

    ./blakely "xx*yy*+" 64 > paraboloid.gif

    ./blakely 9 32 > empty.gif

    time ./blakely 0 250 > flat.gif

### Selected Judges Remarks:

Several IOCCC themes (RPN calculator, animated GIF generator, ray tracing) in one package! Very impressive!

The checkerboard pattern in the output can be broken. Could you figure out how?

Larger GIF files confuse some image viewers.


## Author's comments:
Remarks
-------

This program renders a generic RPN expression in ray-traced animated GIF form.
The expression in spatial variables x and y is specified on the command-line with the required resolution,
and an animated GIF showing a fly-around of the resulting surface is output to stdout.

Usage
-----

The program should be run as:

    ./blakely xy* 32 > pic.gif
where the first parameter is a RPN expression, and the second is the width of the required GIF, up to a maximum of 250.

The expressions are written in Reverse Polish Notation with the following characters recognised:

* +,-,\*,/ - usual arithmetic operations
* ^ - Exponentiation - valid for constant exponent only
* s - sin
* c - cos
* 0-9 - single digit integers
* d - duplicate number on stack
* t - transpose top two elements on stack
* x - x coordinate value
* y - y coordinate value

NB all arithmetic is done in double precision, so 23/ is two-thirds, rather than 0

The surface plotted corresponds to -1 <= x,y <= 1 and for best results, the generated z value should lie between -1 and 1.

If there is a division by zero, square-root of a negative number, or similar operation, then the results are undefined.

Examples
--------

For test-runs, use a resolution of 32. For simple expressions, the GIF generation should take only
a few seconds with a modern processor and full optimization. Run-time scales as O(N^3) with resolution N,
and more complex expressions take longer to compute. For example, increasing the resolution of ripple.gif
to 250 took ~35 minutes to render on an i7 processor.

    ./blakely xy* 32 > saddle.gif

    ./blakely xx*yy*1++d5*ct/ 64 > ripple.gif

Algorithm
---------

A generic root-finding algorithm to find the point of intersection between a ray
and the surface is done using a simple forward search from the eye.
In order to make the rendering realistic, both the value of the expression, and its derivative with respect to x and y must be tracked.
This is done using an obvious stack-based approach.

Obfuscations
------------

Much of the obfuscation is achieved through the use of single-letter variables and #defines.
The characters output for the GIF format are generated in myriad and wonderful ways, making use
of XOR, return values from putchar, and odd expressions.
The layout is in the form of X Y Z.

Limitations
-----------
ASCII is assumed since many bytes for the GIF output are generated from characters given in the source code.
On compilation a few warnings about parentheses come up when using gcc 4.6.3, and one about no return value from main() (who uses exit codes anyway?),
but clang 3.1 emits no warnings.

Questions
---------

* Apart from their appearance when computing the RPN expression, sin and cos are not used.
  How do we then get the correct angles for rotation?
* Exactly how many times will the animation repeat?
* Why is there an upper limit of 250x250 for the resolution?
* What is the point of b[0]?
* Where are the words NETSCAPE and GIF hidden in the source?

(Note that the author may or may not be able to answer all of the above questions.)

--------------------------------------------------------------------------------
<!--
(c) Copyright 1984-2015, [Leo Broukhis, Simon Cooper, Landon Curt Noll][judges] - All rights reserved
This work is licensed under a [Creative Commons Attribution-ShareAlike 3.0 Unported License][cc].

[judges]: http://www.ioccc.org/judges.html
[cc]: http://creativecommons.org/licenses/by-sa/3.0/
-->
2012 marked the "The Twenty First International Obfuscated C Code Contest"
========================================================================

Copyright (C) 2012, Landon Curt Noll, Simon Cooper, and Leonid A.
Broukhis. All Rights Reserved. Permission for personal, educational
or non-profit use is granted provided this copyright and notice are
included in its entirety and remains unaltered.  All other uses
must receive prior permission from the contest judges.


Standard IOCCC stuff
--------------------

The IOCCC has a web site and now has a number of international mirrors.
The primary site can be found at,

>	<http://www.ioccc.org/>

Use make to compile entries.  It is possible that on non-Un\*x / non-Linux
systems the makefile needs to be changed.  See the Makefile for details.

Look at the source and try to figure out what the programs do, and run
them with various inputs.  If you want to, look at the hints files for
spoilers - this year we included most of the information included
by the submitter.

Read over the makefile for compile/build issues.  Your system may require
certain changes (add or remove a library, add or remove a #define).

Some ANSI C compilers are not quite as good as they should be.  If
yours is lacking, you may need to compile using gcc instead of your
local compiler.


Remarks on some of the entries
------------------------------

We believe you will be impressed with this year's winners.  We had
a very difficult time picking a single best from among the other winners
because the overall quality of the winners were so high.

This year we selected the top 4 entries for particularly high honors:

*   Gold award - Balanced use of obfuscation

    A very extremely subtle and twisted piece of source code!
    Even if you start with the zeitak_deobfucate.c source,
    you will still have a very challenging time to understand it!

*   Silver award - Most elementary use of C

    A fun program that could also have won "Best abuse of
    Ghostscript" because it managed to create some PDF files
    that Ghostscript could not read.

*   Bronze award - Best use of cocoa

    A picture within a picture is worth more than a
    thousand (4 byte) words. :-)

*   Honorable mention - Most complex ASCII fluid

    When you see this program in action, you too will
    very likely say [wow](http://bit.ly/R6ALpK) as we did!

But don't ignore the other winners!  There are games, utilities,
eye candy, calculators and graphical tools to explore.

This year, Yusuke Endoh won with two entries, one of which (endoh1)
won the special Honorable mention award.  Eight of the winning entries
were from people who won in previous years.

This year we had a number of winners from Asia.  We saw our second
winner from China and first from Korea.  We are pleased to see
outstanding entries from areas of the world that have not been
active in past contests.  Will we see an upswing of entries
from South America, Africa and Antarctica next year? :-)

Please note that judging is done completely anonymously.  Please
do NOT reveal your identity in your source code.  In the future we
may disqualify entries that reveal the identity of the submitter!

There were some outstanding entries that did not win.  Unfortunately
some very good entries lost because they:

+ would take years to execute

+ were way way oversize and didn't even attempt to justify their
  excess by a clever abuse of the rules

+ obfuscate themselves by simply invoking a complex
  state machine

+ depend on a single obfuscation trick

+ could only be run on a particular vendor's platform

+ were very similar to previous winners

+ were based on an overused theme such as yet another
  fractal display program

+ didn't work as documented

We hope the authors of some of those entries will fix and re-submit
them for the next IOCCC.

There is a risk in submitting an entry that is similar to a well
used theme by previous winners.  Previous winners set a very high
bar.  A new winner must not only compete against other submissions
form the current year, they must also excel over similar winners
in some particularly impressive way.

Final Comments
--------------

Please feel free to send us comments and suggestions about the
competition, this README or anything else that you would like to see in
future contests.

If you use, distribute or publish these entries in some way, please drop
us a line.  We enjoy seeing who, where and how the contest is used.

If you have problems with any of the entries, AND YOU HAVE A FIX, please
send us the fix (patch file or the entire changed file).

For the latest information on how to contact the IOCCC Judges please visit

>	<http://www.ioccc.org/contact.html>

For news of the next contest watch:

>	<http://www.ioccc.org/>


--------------------------------------------------------------------------------
<!--
(c) Copyright 1984-2012, [Leo Broukhis, Simon Cooper, Landon Curt Noll][judges] - All rights reserved
This work is licensed under a [Creative Commons Attribution-ShareAlike 3.0 Unported License][cc].

[judges]: http://www.ioccc.org/judges.html
[cc]: http://creativecommons.org/licenses/by-sa/3.0/
-->
# Best one liner

Taketo Konno  
Tokyo, Japan  
<inaniwa3@gmail.com>  


## Judges' comments:
### To build:

    make konno

### To run:

    ./konno N
    # where N is 0 to 255

### Try:

    ./konno 30

### Selected Judges Remarks:

This entry is a good one-liner to analyze completely.

For extra credit, what are the minimal changes to convert it to
64-bit integers so that it could print 32 lines?

## Author's comments:
### Remarks

This program outputs [elementary cellular automaton](http://mathworld.wolfram.com/ElementaryCellularAutomaton.html) patterns.

Try:

    ./konno 30
    ./konno 90
    ./konno 102
    ./konno 109
    ./konno 165

There are 256 (from 0 to 255) possible rules.

### Obfuscation

This program uses bit operations. I think

    7&O<<!o>>!o+29

is an intersting operation. This isn't equal to

    7&O>>29

operation. What is the operation doing?

### Limitation

This program assumes that the size of int is 4.

--------------------------------------------------------------------------------
<!--
(c) Copyright 1984-2015, [Leo Broukhis, Simon Cooper, Landon Curt Noll][judges] - All rights reserved
This work is licensed under a [Creative Commons Attribution-ShareAlike 3.0 Unported License][cc].

[judges]: http://www.ioccc.org/judges.html
[cc]: http://creativecommons.org/licenses/by-sa/3.0/
-->
# Most recyclable

Yusuke Endoh  
<mame@ruby-lang.org>  
<https://github.com/mame/>  


## Judges' comments:
### To build:

    make endoh2

### To run:

     make all   

You'll need to have Ruby installed to run all the automated check

    make check

### Try:

    cat jpeg.c
    
Look at jpeg.jpg in an image viewer program.

    
### Selected Judges Remarks:

This is a program which, when fed its own source, generates a program that almost is its whitespace inverse,
which, in its order, generates a JPEG file (speaking of file size abuse, that is about 16.4 times 
larger than a PBM file with the same image, but the source was also abusing the size counting program...)

Don't pay attention to the OCR ~~behind the ruby curtain~~ --- it's a straightforward bitmap comparison.

## Author's comments:
### Highlights

* LZ77-like compression for font and template data
* tiny JPEG encoder
  * Zig-zag space-filling curve
  * Discrete cosine transform
  * JPEG Huffman encoding (cheeting)

### Notes

I picked JPEG instead of PNG, GIF, or BMP
because it is the most difficult to generate.
I believe that the JPEG encoder is the world's smallest ever.
Nevertheless, the program was too big to meet the IOCCC's size rule.
So I created a smaller bootstrap program that generates the main program.
`prog.c` contains fragments of the main program *as a comment*
which `iocccsize -i` does *not* count.
I gratefully think the judges for spoiling the size rule this year.

I think the program will work on any major platforms and compilers.

### Legal

This program uses (a part of) Proggy Tiny Fonts
which is distributed in MIT License:

    Copyright (c) 2004, 2005 Tristan Grimmer

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the "Software"),
    to deal in the Software without restriction, including without limitation
    the rights to use, copy, modify, merge, publish, distribute, sublicense,
    and/or sell copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
    THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.

--------------------------------------------------------------------------------
<!--
(c) Copyright 1984-2015, [Leo Broukhis, Simon Cooper, Landon Curt Noll][judges] - All rights reserved
This work is licensed under a [Creative Commons Attribution-ShareAlike 3.0 Unported License][cc].

[judges]: http://www.ioccc.org/judges.html
[cc]: http://creativecommons.org/licenses/by-sa/3.0/
-->
# Most solid

Yusuke Endoh  
<mame@ruby-lang.org>  
<https://github.com/mame/>  


## Judges' comments:
### To build:

    make endoh4

### To run:

    ./endoh4

### Try:

NOTE: The author recommends the use of xterm.

    ./endoh4 < cube.txt

For example, if you are a soccer fan, try:

    make all
    ./endoh4 < solids/archimedian-solid/a11-truncated-icosahedron.txt

### Selected Judges Remarks:

This program is formatted as the net for a tetrahedron. (hint, try feeding the
program it's own source code).  When it runs there is an animation for the
computation to work out the convex hull.

## Author's comments:
### Spec

This is a convex polyhedron viewer, which:

1. reads three-dimentional vertices (3N float values) from stdin,
2. calculates a convex hull of them, and
3. renders it.

This simple spec involves many details.

* 3D convex hull calculation
  * recursive gift wrapping algorithm
  * automatical merging of (almost) co-planar faces
    (i.e., faces are not triangulated)
  * random perturbation for robustness
* 3D rendering
  * perspective projection
  * ASCII line drawing: `"',;;;,;'"`
  * camera in a spherical spiral orbit

(Note that this program does not use `math.h`.)

### Portability

I think it conforms with both C89 and C99.
I confirmed that it worked on gcc, clang, and tcc.
It should not be warned with -pedantic and -Wextra.

### Tips

You may want to use `tput` to hide a terminal cursor.

    tput civis
    ./endoh4 < cube.txt
    tput cnorm

### Bonuses

You can change the screen size.  Let the aspect ratio be about 3:1.

    gcc -DS=120,40 -o endoh4 endoh4.c

The shape of this code is the geometric net of a regular tetrahedron.
  So, try:

    ./endoh4 < endoh4.c

The solids.tbz2 file includes various solid data:
[Platonic solids](http://en.wikipedia.org/wiki/Platonic_solid),
[Archimedean solids](http://en.wikipedia.org/wiki/Archimedean_solid),
[Prisms](http://en.wikipedia.org/wiki/Prism_%28geometry%29),
[Antiprisms](http://en.wikipedia.org/wiki/Antiprism),
[Bipyramids](http://en.wikipedia.org/wiki/Bipyramid),
[Trapezohedrons](http://en.wikipedia.org/wiki/Trapezohedron), and
[Johnson solids](http://en.wikipedia.org/wiki/Johnson_solid).

I created the files by using the POV-Ray scripts
([1](http://en.wikipedia.org/wiki/File:Poly.pov) and
 [2](http://en.wikipedia.org/wiki/User:AndrewKepert/poly.pov))
in Wikipedia.
They are copyrighted in CC BY-SA 3.0
by "User:Cyp" and "User:AndrewKepert".

--------------------------------------------------------------------------------
<!--
(c) Copyright 1984-2015, [Leo Broukhis, Simon Cooper, Landon Curt Noll][judges] - All rights reserved
This work is licensed under a [Creative Commons Attribution-ShareAlike 3.0 Unported License][cc].

[judges]: http://www.ioccc.org/judges.html
[cc]: http://creativecommons.org/licenses/by-sa/3.0/
-->
# Most tweetable 1-liner

Yusuke Endoh  
<mame@ruby-lang.org>  
<https://github.com/mame/>  


## Judges' comments:
### To build:

    make endoh3

### To run:

    ./endoh3

### Try:

Trying this out will depend on how your system can play sounds. The author's
remarks include some options for different operating systems.

The simplest way is to create a .wav file and have your system play that.

    echo 'CDEFGABc' | ./endoh3 | ruby wavify.rb > cde.wav

There are also some other musical samples, twinkle.abc and menuet.abc.

### Selected Judges Remarks:

This program can tweet out a tune and is small enough to tweet.


## Author's comments:
### Remarks

This is a sound synthesizer for a subset of [ABC music notation](http://en.wikipedia.org/wiki/ABC_notation).

Try:

    gcc -o prog prog.c
    echo "CDEFGABc" | ./prog > /dev/dsp

If `/dev/dsp` is not available on your system, use an OSS sound wrapper such
as `padsp` or `aoss`:

    echo "CDEFGABc" | ./prog | padsp tee /dev/dsp > /dev/null

If you are using Mac OS X, try [sox](http://sox.sourceforge.net/):

    echo "CDEFGABc" | ./prog | sox -q -traw -r8000 -b8 -e unsigned-integer - -tcoreaudio

If they do not work, use the attached script to convert the output
into a wave file format:

    echo "CDEFGABc" | ./prog | ruby wavify.rb > cde.wav

and play `cde.wav`.

You can enjoy some music scores that I attached:

    cat twinkle.abc | ./prog > /dev/dsp
    cat menuet.abc | ./prog > /dev/dsp

### Obfuscation

The following sequence of questions may be helpful to understand the program.

- How does it convert ABC notes into the frequency?
- What is `89/84.`?  I found it by using Stern-Brocot tree.
- How does it generate a wave?  Hint: it generates a saw wave.

### Limitation

The following features are supported:

- Notes:
  - `C` `D` `E` `F` `G` `A` `B` (in low octave)
  - `c` `d` `e` `f` `g` `a` `b` (in high octave)
- Rests: `z`
- Note lengths:
  - `A` (an eighth note)
  - `A2` (a quarter note)
  - `A3` (a dotted quarter note)
  - `A4` (a half note)

The following features are *not* supported:

- Sharp and flat: `^C` `_C`
  - But it is possible to emit the half tones.  Do you see how?
- Shorter note lengths than 1: `C1/2`
  - But you can use `C0.5` instead.
- Higher and lower notes: `c'` `C,`
- Any meta fields: `T:title` `L:1/4`
- Bar line, repeat, ties and slurs, and everything else.

### Known Bugs

You can *not* write a note length immediately followed by a note `E`,
such as `C2E2`.
Can you know why?
You can work it around by inserting a whitespace: `C2 E2`.

### Portability

I tested it on:

* Ubuntu 13.10 with gcc 4.7.3, clang 3.2, and tcc 0.9.25.
* Mac OS X 10.6 with gcc 4.2.1 and clang 1.7.

### Legal

I believe that all the scores that I attached are out-of-copyright.

I did write a score of the Happy Birthday song too.
(It does not matter because the song is out-of-copyright in my country.)
But I do not attach it to protect you from W\*\*\*\*r.

For the same reason, do not play a score that contains only `z1092`.
You know, it is ["the famous song"](http://en.wikipedia.org/wiki/4%E2%80%B233%E2%80%B3).


### Spoiler (rot13)

Urer vf n zntvpny rkcerffvba juvpu V sbhaq ol oehgr-sbepr:

    (p % 32 + 5) * 9 / 5 % 13 + a / 32 * 12 - 22

Vagrerfgvatyl, vg pbairegf na NFPVV ahzore bs NOP abgrf
gb gur pbeerfcbaqvat gbar ahzore.

    'P' (NFPVV  67) =>  3
    'Q' (NFPVV  68) =>  5
    'R' (NFPVV  69) =>  7
    'S' (NFPVV  70) =>  9
    'T' (NFPVV  71) => 10
    'N' (NFPVV  65) => 12
    'O' (NFPVV  66) => 14
    'p' (NFPVV  99) => 15
    'q' (NFPVV 100) => 17
    'r' (NFPVV 101) => 19
    's' (NFPVV 102) => 20
    't' (NFPVV 103) => 22
    'n' (NFPVV  97) => 24
    'o' (NFPVV  98) => 26

Ol gur jnl, lbh pna jevgr n unys-gbar ol gur sbyybjvat punenpgref.

    'X' =>  4 (= P#)
    'Y' =>  6 (= Q#)
    'H' =>  8 (= S#)
    'I' => 11 (= T#)
    'C' => 13 (= N#)

Abgr gung gur gbar ahzoref fvzcyl rahzrengr gur frzv-gbar fgrcf.
Fb jr pna pnyphyngr gur serdhrapl rnfvyl: `cbj(2, a / 12.0)`.
Gura, ubj pna jr pnyphyngr `cbj` jvgubhg `zngu.u`?
`cbj(2, 1.0 / 12.0)` vf nccebkvzngrq ol `89/84.`.
(V sbhaq guvf nccebkvzngvba ol hfvat [Fgrea-Oebpbg gerr](uggc://ra.jvxvcrqvn.bet/jvxv/Fgrea%R2%80%93Oebpbg_gerr).)
Jr pna tnva gur serdhrapl ol zhygvcylvat gur inyhr `a` gvzrf.

Svanyyl, gur sbyybjvat pbqr trarengrf n fnj jnir:

    sbe(p = 0; p < yra; p++) chgpune(n = a * Q);

jurer `Q` vf n serdhrapl naq `n` vf n inevnoyr jubfr glcr vf pune.
Ol nffvtavat sybng gb pune inevnoyr, gur vzcyvpvg glcr pbairegvba vf cresbezrq sebz sybng gb pune (zbqhyb 256).
(Fgevpgyl fcrnxvat, guvf orunivbe vf haqrsvarq nppbeqvat gb 6.3.1.4 va P99;
lbh pna ercynpr vg jvgu `(ybat)(a*Q)` vs lbh ner crqnagvp.)

Nyy gung jnf yrsg jnf gb pbzovar naq pbaqrafr gur pbzcbaragf.
Gur xrl vf fdhnfuvat gurz vagb whfg bar sbe-ybbc.

--------------------------------------------------------------------------------
<!--
(c) Copyright 1984-2015, [Leo Broukhis, Simon Cooper, Landon Curt Noll][judges] - All rights reserved
This work is licensed under a [Creative Commons Attribution-ShareAlike 3.0 Unported License][cc].

[judges]: http://www.ioccc.org/judges.html
[cc]: http://creativecommons.org/licenses/by-sa/3.0/
-->
# Smallest large system simulator

Yves-Marie Morgan  
<yves-marie.morgan@parrot.com>  


## Judges' comments:
### To build:

    make morgan1

### To run:

    echo "2013/10/03" | ./morgan1

### Try:

    echo "1985/10/28" | ./morgan1

    echo "1996/12/31" | ./morgan1

Try pressing the arrow keys when your focus is in the window.

### Selected Judges Remarks:

To verify the output, try echoing the date of an evening with a clear sky.
Use binoculars and/or telescope as needed.  In some cases you may need
to wait for a better time of the evening.  In a few cases, such as
the South Pole in the summer, you may need to move to a different
observing site.

## Author's comments:
# Instructions

It displays the position of the 8 planets of the solar system around the sun.
The date given in the command line is in the format YYYY/MM/DD (year, month and
day). The direction keys can be used to move in time :
Left  : go back 1 day.
Right : go forward 1 day.
Down  : go back 20 days.
Up    : go forward 20 days.

It handles correctly all leap years and the switch between julian calendar and
gregorian calendar (10 days missing between 1582/10/04 and 1582/10/15).

The scale is logarithmic to be able to display the 8 planets without having
Mercury, Venus, Earth and Mars squizzed around the sun.

The size is not proportinal either.

# Bonus

It also displays the position of 2 famous comets during their last approach :
- The first one arround the third IOCCC.
- The second one between the thirteenth and fourteenth IOCCC.

# Limitations

* ASCII character set is assumed.
* a c99 compiler is required (for some math.h functions).
* The position should be correct for years between (-1000; +3000)
* The approximations done in the formula are OK for displaying the
  position around the sun but not for other applications like ephemeride or
  sky view from Earth (angles may be off by 1 or 2 degrees sometimes).

# Obfuscation

* Reuse of 1 letter variables.
* Only the main function with some for loops.
* Constants for orbital elements encoded in a string.
* Hexadecimal and decimal values used inconsitentely.
* Comparisons order are not consitent.
* A lot of stuff is done in the different parts of the for loop.

# Compilation warnings

with gcc 4.7.2 on Linux Ubuntu 12.10 :
* prog.c:38:3: warning: suggest parentheses around && within || [-Wparentheses]
* prog.c:40:34: warning: value computed is not used [-Wunused-value]
* prog.c:56:6: warning: suggest parentheses around && within || [-Wparentheses]
* prog.c:58:50: warning: value computed is not used [-Wunused-value]
* prog.c:61:5: warning: suggest parentheses around - inside >> [-Wparentheses]

with clang 3.1 on Linux Ubuntu 12.10 :
* prog.c:38:49: warning: '&&' within '||' [-Wlogical-op-parentheses]
* prog.c:38:27: warning: '&&' within '||' [-Wlogical-op-parentheses]
* prog.c:55:13: warning: '&&' within '||' [-Wlogical-op-parentheses]
* prog.c:56:14: warning: '&&' within '||' [-Wlogical-op-parentheses]

Due to most parentheses and braces removed when unecessary.

To verify the display, you can look at one of this programs :
* xephem : http://www.clearskyinstitute.com/xephem/
* homeplanet : http://www.fourmilab.ch/homeplanet/
* http://www.theplanetstoday.com/

--------------------------------------------------------------------------------
<!--
(c) Copyright 1984-2015, [Leo Broukhis, Simon Cooper, Landon Curt Noll][judges] - All rights reserved
This work is licensed under a [Creative Commons Attribution-ShareAlike 3.0 Unported License][cc].

[judges]: http://www.ioccc.org/judges.html
[cc]: http://creativecommons.org/licenses/by-sa/3.0/
-->
# Largest small system emulator

Adrian Cable  
<adrian.cable@gmail.com>  


## Judges' comments:
### To build:

    make cable3

### To run:

    ./cable3 bios-image-file floppy-image-file [harddisk-image-file]

### Try:

    ./runme

### Selected Judges Remarks:

This entry weighs in at a magical 4043 bytes (8086 nibbles, 28,301
bits). It manages to implement most of the hardware in a 1980's era
IBM-PC using a few hundred fewer bits than the total number of
transistors used to implement the original 8086 CPU.

If you are using OS X, the included sc-ioccc.terminal configuration file will
correctly display console applications that use ANSI graphics.

Update: This entry now has its own web page <http://www.megalith.co.uk/8086tiny>

## Author's comments:
A tiny but highly functional PC emulator/virtual machine
========================================================

The author hereby presents, for the delectation (?) of the judges, a portable PC emulator/VM written specifically for the IOCCC which runs DOS, Windows 3.0, Excel, MS Flight Simulator, AutoCAD, Lotus 1-2-3 ...

In just 4043 bytes of C source, you get a complete mid-late 1980s-era IBM-compatible PC, consisting of:

- Intel 8086/186 CPU
- 1MB RAM
- 8072A 3.5" floppy disk controller (1.44MB/720KB)
- Fixed disk controller (supports a single hard drive up to 528MB)
- Hercules graphics card with 720x348 2-color graphics (64KB video RAM), and CGA 80x25 16-color text mode support
- 8253 programmable interval timer (PIT)
- 8259 programmable interrupt controller (PIC)
- 8042 keyboard controller with 83-key XT-style keyboard
- MC146818 real-time clock
- PC speaker

The emulator uses the SDL graphics library for portability, and compiles for Windows, Mac OS X, Linux and probably most other 32-bit/64-bit systems too.

If you like living on the edge you can try building the emulator on a big endian machine, and you will get an emulation of a big endian 8086, a rather bizarre and somewhat useless beast. For everyone else, please run the emulator on a little endian machine.

*RULE 2 ABUSE DISCLAIMER*

- cable3.c is 4043 bytes in length (half an 8086)
- iocccsize -i < cable3.c returns 1977 (the year the 4.77 MHz 8086 CPU was announced)
- Therefore, any suspicions the judges may have regarding rule 2 non-compliance may be well-intentioned but are groundless.
- Nonetheless, the author would like to apologise to the judges for the one-big-block-of-code nature of this entry, which turned out to be unavoidable. Hopefully the joys of this entry will make up for its shortcomings.

*/RULE 2 ABUSE DISCLAIMER*

Why is this entry obfuscated/interesting?
-----------------------------------------

- First of all the 8086 is a nightmare processor to emulate. Instruction codings are complex and irregular in size and structure, with multiple addressing modes and no consistent memory placement for operands, very often multiple possible encodings for the same instruction, and the bizarre segment:offset memory model. In addition, the 8086 has a number of bugs (e.g. PUSH SP), undocumented behaviours and instructions (e.g. AAM/AAD + imm8, SALC, flag behaviour for MUL/DIV, etc. etc.), and archaic features (e.g. parity/auxiliary flags) which all need to be emulated properly. Here we emulate every feature of the CPU pretty exactly (in fact better than most commercial clones of the processor e.g. the NEC V30), with the exception of the trap flag which no real software uses except for debuggers (although support for the TF can be added if deemed important, without exceeding the IOCCC size limit).
- In addition to the CPU we also emulate all the standard PC peripheral hardware. Parts of it are somewhat complete, much is rather dysfunctional (like the 8253/8259) but enough to support most real software.
- Nonetheless the source, while large for the IOCCC, is rather tiny for a functional PC emulator - around 2% of the size of the source of other open-source 8086 PC emulators with comparable functionality.
- In fact, this entry is just like happy hour - at 4043 bytes long, you pay for half the 8086, but you get served the whole one.
- Getting the code down to <= 4096 characters to meet the IOCCC rule 2 overall size limit required a good deal of effort (and appreciable risk of divorce), with obfuscation being a pretty unavoidable consequence in most places ... for the rest, I use short circuit operators whenever possible, mix x[y] and y[x], don't use any flow control keywords except for for, use K&R-style declarations to honor the C language's rich cultural heritage (plus it saves a byte), and occasionally go overboard with nasty nested indexes to give things like this: --64[T=1[O=32[L=(X=*Y&7)&1,o=X/2&1,l]=0,t=(c=y)&7,a=c/8&7,Y]>>6,g=~-T?y:(n)y,d=BX=y,l]
- This entry highlights the importance of comments in C.
- This entry might result in an adjustment to the IOCCC size tool for the 2014 competition (see above).

Compiling on different platforms
--------------------------------

This entry has been tested on Windows (compiled with MS Visual Studio 2010 and 2013), Mac OS X (clang and gcc), and Linux (clang and gcc). The Makefile supplied is good for Mac OS X, Linux and probably other UNIXes. I have received reports that the emulator works on Raspberry Pi/Android/ARM (you will need to compile with -fsigned-char) and iOS. You will need to adjust the Makefile if your system lacks sdl-config to correctly point to the SDL libraries and header files.

On UNIX-based systems we can get raw keystrokes using stty. However Windows has no stty. Therefore the Makefile includes a -D entry to define a "keyboard driver" KB which as it stands is suitable for UNIXes, but maybe not non-UNIX platforms. For example, for Windows/MS Visual Studio, instead of the Makefile definition of KB, use something slightly different - add the following entry to the Preprocessor Definitions list in the Project Properties page:

	KB=(kb=H(8),kbhit())&&(r[1190]=getch(),H(7))

POSIX portability note
----------------------

The code as supplied uses implicit function declarations for POSIX file I/O and in doing so assumes that file offsets are the same bit width as your architecture. For some systems (e.g. 32-bit Mac OS X, which uses 64-bit file offsets) this is not the case, and to run successfully on these systems, you will need to explicitly declare these functions by adding the appropriate include to the top of the source:

    #include <unistd.h>

Usage
-----

	./cable3 bios-image-file floppy-image-file [harddisk-image-file]

PLEASE NOTE that under UNIXes the keyboard must be in raw mode for the emulator to work properly. Therefore the emulator is best run from a shell script that looks something like:

	stty cbreak raw -echo min 0
	./cable3 bios floppy.img harddisk.img
	stty cooked echo

To run the emulator - floppy mode only
--------------------------------------

The simplest use of the emulator is with a single floppy boot disk image, like the fd.img provided, which is a FreeDOS boot disk.

Before running the emulator on a Unix-type system, stty needs to be used to put the keyboard into raw mode (and afterwards it needs to be put back to cooked). So, run the emulator using something like this script (provided as "runme"):

	stty cbreak raw -echo min 0
	./cable3 bios fd.img
	stty cooked echo

To run the emulator - floppy + HD mode
--------------------------------------

Easiest to start with is to try a ready-made 40MB hard disk image containing a whole bunch of software:

<http://bitly.com/1bU8URK>

For the more adventurous, you can start off with (for example) a blank 40MB image file called hd.img made using e.g. mkfile. Then use:

	stty cbreak raw -echo min 0
	./cable3 bios fd.img hd.img
	stty cooked echo

Preparing the hard disk for use in the emulator is done just like a real PC. Boot the emulator, and use FDISK to partition the hard disk. When it's done FDISK will reboot the emulator. Then you can use FORMAT C: and you are done. The resulting disk image is in the right format to be mounted on a real Windows PC using e.g. OSFMount, on a Mac using hdiutil, or on Linux using mount, providing an easy way to copy files and programs to and from the disk image. Or, you can install programs from regular floppy disk images (see "Floppy disk support" below).

Keyboard emulation
------------------

The emulator simulates an XT-style keyboard controlled by an Intel 8042 chip on I/O port 0x60, generating IRQ1 and then interrupt 9 on each keypress. This is harder than it sounds because a real 8042 returns scan codes rather than the ASCII characters which the C standard I/O functions return. Rather than make the emulator less portable and use ioctl or platform-dependent equivalents to obtain real scan codes from the keyboard, the emulator BIOS does the reverse of a real PC BIOS and converts ASCII characters to scancodes, simulating press/release of the modifier keys (e.g. shift) as necessary to work like a "real" keyboard. The OS (DOS/Windows) then converts them back to ASCII characters and normally this process works seamlessly (although don't be surprised if there are issues, for example, with non-QWERTY e.g. international keyboards).

Most of the time you can just type normally, but there are special sequences to get Alt+xxx and Fxxx.

To send an Alt+XXX key combination, press Ctrl+A then the key, so for example to type Alt+F, press Ctrl+A then F.

To send an Fxx key, press Ctrl+F then a number key. For example, to get the F4 key, press Ctrl+F then 4. To get F10, press Ctrl+F then 0.

To send a Page Down key, press Ctrl+F then O. To send a Page Up key, press Ctrl+F then E. Other key combinations are left for the discovery of the user.

Text mode support
-----------------

The emulator supports both text output via the standard BIOS interrupt 0x10 interface, and also direct video memory access (one page, 4KB video RAM at segment B800) in 80x25 CGA 16-color text mode.

BIOS text output calls are converted to simple writes to stdout. Direct video memory accesses for the 80x25 CGA color text mode are converted to ANSI terminal escape sequences. If you are using a terminal which does not support ANSI (e.g. you are compiling the emulator with MS VC++ and running in a Windows console window) then PC applications that directly write to video memory in text mode may be unusable.

Most CGA I/O ports are not supported except for the CGA refresh register at 0x3DA, which some applications use for timing or synchronisation.

The regular PC character code page (437) includes various extended ASCII characters for things like line drawing. You might want to set the font in your terminal program to something that includes these (e.g. on Mac OS X there is a freeware font called Perfect DOS VGA 437 which does the trick).

Occasionally a DOS application on exit will leave the video hardware in an odd state which confuses the emulator, resulting in subsequent text output being invisible. If this happens, just use the DOS CLS command to clear the screen and all will be well again.

Graphics mode support
---------------------

Hercules 720x348 monochrome graphics mode emulation is implemented using SDL. Most Hercules features are supported via the normal I/O interface on ports 0x3B8 and 0x3BA including video memory bank switching (segments B000/B800), which some games use for double-buffered graphics. CGA graphics modes are not supported.

When an application enters graphics mode, the emulator will open an SDL window (which will be closed when the application goes back to text mode). Including code to redirect keystrokes from the SDL window to the main terminal window would have busted the IOCCC size limits, so you need to keep the main emulator terminal window in focus at all times even when you are doing graphics (sounds a little odd but you will get used to it).

On UNIXes, SDL will automatically output graphics via X11 if the DISPLAY environment variable is set up.

Dual graphics card support
--------------------------

Some applications (e.g. AutoCAD) support a PC configuration with a CGA card and a Hercules card, for simultaneous text and graphics output on different displays. The emulator simulates this configuration, too, using separate windows for the (terminal) text and (SDL) graphics displays.

BIOS
----

Like a real PC, the emulator needs a BIOS to do anything useful. Here we use a custom BIOS, written from scratch specifically for the emulator. Source code for the BIOS (written in 8086 assembly language) which compiles with the freely-available NASM x86 assembler is available from the author on request.

The BIOS implements the standard interrupt interfaces for video, disk, timer, clock and so on, much as a "real" PC BIOS does, and also a small timer-controlled video driver to convert video memory formatting into ANSI escape sequences when the emulator is in text mode.

CPU and memory emulation
------------------------

Memory map is largely as per a real PC, with interrupt vector table at 0:0, BIOS data area including keyboard buffer at 40:0, CGA text video memory at B800:0, Hercules dual-bank graphics memory at B000/B800:0, and BIOS at F000:100. Unlike a real PC, in the emulator the CPU registers are memory-mapped (at F000:0), which enables considerable optimisation of the emulator's instruction execution unit by permitting the unification of memory and register operations, while remaining invisible to the running software.

CPU supports the full 8086/186 instruction set. Due to the complexities of the 8086's arbitrary-length instruction decoding and flags, 8086 instructions are first converted to a simpler intermediate format before being executed. This conversion, along with instruction lengths and how each instruction modifies the flags, is assisted by some lookup tables which form part of the BIOS binary.

The CPU also implements some "special" two-byte opcodes to help the emulator talk with the outside world. These are:

	0F 00 - output character in register AL to terminal
	0F 01 - write real-time clock data (as returned by localtime) to memory location ES:BX
	0F 02 - read AX bytes from disk at offset 512*(16*SI+BP) into memory location ES:BX. Disk is specified in DL (0 = hard disk, 1 = floppy disk)
	0F 03 - write AX bytes at memory location ES:BX to disk at offset 512*(16*SI+BP). Disk is specified in DL as per 0F 02

Emulator exit is triggered if CS:IP == 0:0 (which would be nonsensical in real software since this is where the interrupt vector table lives). The supplied Dos6.22.img disk includes a small program QUITEMU.COM which contains a single JMP 0:0 instruction, to allow the user to easily quit the emulator without shutting down the terminal.

Floppy disk support
-------------------

Emulates a 3.5" high-density floppy drive. Can read, write and format 1.44MB disks (18 sectors per track, 2 heads) and 720KB disks (9 sectors per track, 2 heads).

If you want to install your own software from floppy images (downloaded from e.g. Vetusware), the easiest way to "change disks" is to copy each disk image in turn over the floppy image file you specify on the command line. Don't forget to put your original boot disk back at the end!

Hard disk support
-----------------

Supports up to 1023 cylinders, 63 sectors per track, 63 heads for disks up to 528MB.

Disk image format used is a subset of the standard "raw" format used by most disk image mount tools. In general, disk images prepared by the emulator will work with disk image tools and other emulators, but not the other way around.

The emulator uses a particularly dumb algorithm to derive a simulated cylinder/sector/head geometry from the disk image file's size. This algorithm often results in not all the space in the image file being available for disk partitions. For example, creating a 40,000,000 byte image file results in DOS FDISK seeing only 31.9MB as the volume size.

Note that unlike a real PC, the emulator cannot boot from a hard disk (image). Therefore, you will always need to use a bootable floppy image, even if after boot everything runs from the HD.

Mouse
-----

No mouse is emulated.

Real-time clock
---------------

Reading the RTC (both time and date) is emulated via the standard BIOS clock interface, pulling the time/date from the host computer. Setting the time or date is not supported.

Timers
------

A countdown timer on I/O port 0x40 is simulated in a broken way which is good enough for most software. On a real PC this has a default period of 55ms and is programmable. No programmability is supported in the emulator and the period may be about right or completely wrong depending on the actual speed of your computer.

On a real PC, IRQ0 and interrupt 8 are fired every 55ms. The emulator tries to do the same but again, the delay period is uncalibrated so you get what you get.

PC speaker
----------

Beeps only, through the console.

Software supported
------------------

The emulator will run practically any software a real PC (of the spec listed at the top of this file) can. The author has tested a number of OSes/GUIs (MS-DOS 6.22, FreeDOS 0.82pl3, Windows 3.0, DESQview 2.8), professional software (Lotus 1-2-3 2.4 and AsEasyAs 5.7 for DOS, Excel 2.1 for Windows, AutoCAD 2.5, WordStar 4), programming languages (QBASIC, GWBASIC, Turbo C++), games (Carrier Command, Police Quest, and a bunch of freeware Windows games), and diagnostic/benchmark software (Manifest, Microsoft MSD, InfoSpot, CheckIt) and all of them run well.

Screenshots of some of these applications running (on Mac OS X) are provided for the impatient.

Compiler warnings
-----------------

A lot of compiler warnings are produced by clang. Missing type specifiers, control reaching the end of functions without returning values, incompatible pointer type assignments, and some precedence warnings, all necessary to keep the source size down. Other compilers are likely to produce similar warnings.


--------------------------------------------------------------------------------
<!--
(c) Copyright 1984-2015, [Leo Broukhis, Simon Cooper, Landon Curt Noll][judges] - All rights reserved
This work is licensed under a [Creative Commons Attribution-ShareAlike 3.0 Unported License][cc].

[judges]: http://www.ioccc.org/judges.html
[cc]: http://creativecommons.org/licenses/by-sa/3.0/
-->
# Most catty

Don Yang  
<omoikane@uguu.org>  
<http://uguu.org/>  


## Judges' comments:
### To build:

    make misaka

This will build a bunch of versions of the code. See the author's details for information on all of these builds.

To understand the various intermediate source files that are built, try:

    make understanding

### To run:

    ./horizontal_cat [files...] > [output]
    ./vertical_cat [files...] > [output]

NOTE: Use - for standard input.  For example:

    ./vertical_cat - -

### Try:

    seq 1 12 | ./horizontal_cat - - -

    ./long_cat
    ./long_faat_cat
    ./long_fat_cat
    ./loong_cat
    ./loooong_cat
    ./loooooooong_cat

    seq -f '%.0f  ' 45 | ./horizontal_cat - misaka.c

### Selected Judges Remarks:

There is more to cat than [mere cats](http://cheezburger.com/1680494336).  
Be they tall, fat, long or squat, this source code is sure to amuse.

#### Slight diversion

While one of the judges was reviewing this entry on the stern of the 
[Island Sky](http://www.noble-caledonia.co.uk/information/detail.asp?id=2&spid=76)
in the middle of the Atlantic Ocean waiting the
[total solar eclipse of 2013](http://en.wikipedia.org/wiki/Solar_eclipse_of_November_3,_2013)
the judge was stuck by a
[flying fish](http://en.wikipedia.org/wiki/Flying_fish).
While result the impact was that the
[Port](http://en.wikipedia.org/wiki/Port_wine) from Portugal was lost, the
[Grog](http://www.travelforpassion.com/grog-factory-cape-verde-santo-antao-cape-verde-1602-photo) from Cape Verde
and the laptop containing this entry was saved.

While I'm sure most cats would have preferred otherwise,
the flying fish was returned to *em*swim with the fishes*em*. :-)
No cats were harmed in the process of judging this entry.

## Author's comments:
Overview
========
Misaka is a file concatenation utility, with at least two modes of
operation:

    gcc misaka.c -o horizontal_cat
    ./horizontal_cat [files...] > [output]

    ./horizontal_cat misaka.c misaka.c > misaka2.c
    gcc misaka2.c -o vertical_cat
    ./vertical_cat [files...] > [output]

Where [files...] are a list of text file names.  Use "-" to read from stdin.


Details
=======

Horizontal cat
--------------
One of my favorite unix utilities is *cat*.  The best thing about it was
that it was named "cat".  That, and it's useful for quickly showing contents
of a file.  Though it was primary meant for concatenating files, that
function only seem to work if I wanted to concatenate files vertically.

I thought the lack of horizontal concatenation must have been an oversight,
so I implemented this utility:

    gcc misaka.c -o horizontal_cat
    ./horizontal_cat files...

*horizontal_cat* concatenates files horizontally and write the output to
stdout.  Each input file is padded with spaces on the right so that the
original text alignments are preserved.

If "-" is specified as a file name, *horizontal_cat* will read from stdin.
Unlike *cat*, *horizontal_cat* loads all input to memory first.  Thus you
can specify "-" multiple times to get stdin multiplied horizontally.  For
example, if you have seq(1) in your shell, you can add line numbers to both
sides of misaka.c like this:

    seq -f '  %.0f  ' 45 | ./horizontal_cat - misaka.c -


Vertical cat
------------
Because *horizontal_cat* must know the maximum width of all files before
writing any output, all files must be processed at least twice.  To support
stdin, file must be buffered to memory.  This lead to the feature that
*horizontal_cat* can be used to duplicate stdin.

Seems like the stdin doubling feature might be useful even for concatenating
files vertically, so I included a vertical mode.  But supporting vertical
mode with command line options would be no fun.  Instead, vertical mode is
enabled by concatenating the source code horizontally:

    ./horizontal_cat misaka.c misaka.c > misaka2.c
    gcc misaka2.c -o vertical_cat
    ./vertical_cat files...

*vertical_cat* works more or less like *cat*, except you can use
*vertical_cat* to duplicate stdin:

    ./vertical_cat - -


Long cat
--------
After *horizontal_cat* and *vertical_cat*, I thought, maybe all I really
wanted was just more cats.  So I implemented one more mode, this one is
enabled by concatenating misaka.c vertically:

    ./vertical_cat misaka.c misaka.c > misaka3.c
    gcc misaka3.c -o long_cat
    ./long_cat

*long_cat* outputs ASCII art of a cat to stdout.  You can make this cat
exponentially longer by concatenating more files vertically (up to 31 levels
high, depending on sizeof(int) for your compiler):

    ./vertical_cat misaka.c misaka.c misaka.c > misaka4.c
    gcc misaka4.c -o loong_cat

    ./vertical_cat misaka.c misaka.c misaka.c misaka.c > misaka5.c
    gcc misaka5.c -o loooong_cat

    ./vertical_cat misaka.c misaka.c misaka.c misaka.c misaka.c > misaka6.c
    gcc misaka6.c -o loooooooong_cat

If your terminal has really thin fonts, you can also make this output fatter
by concatenating files horizontally:

    ./vertical_cat misaka.c misaka.c | ./horizontal_cat - - > misaka7.c
    gcc misaka7.c -o long_fat_cat

    ./vertical_cat misaka.c misaka.c | ./horizontal_cat - - - > misaka8.c
    gcc misaka8.c -o long_faat_cat

Output width is determined by the first level of stacked programs, so a
triangle like the following will not have horizontally expanded output:

    ./horizontal_cat misaka.c misaka.c | ./vertical_cat misaka.c - > misaka9.c
    gcc misaka9.c -o same_as_long_cat

Finally, if you lost track of how many misaka.c you have stacked together,
you can feed the source to a brainfuck interpreter to get a overview of how
the programs are stacked.  Example:

    perl bf.pl misaka9.c

This outputs:

    MISAKA
    MISAKA MISAKA


Return value
============
*horizontal_cat* and *vertical_cat* will exit with zero status on success.

If any input file fails to open, *horizontal_cat* and *vertical_cat* will
report the offending file name to stdout, and exit with nonzero status.

If *horizontal_cat* and *vertical_cat* ran out of memory, they will exit
with nonzero status without outputting anything.


Compatibility
=============
*horizontal_cat* makes the following assumptions about input files:

   * ASCII with LF end of line sequences.  If CR-LF sequences are used, CR
     characters will appear in the middle of output lines.
   * All characters are of equal width, even tab characters.

Misaka has been verified to work on these following compiler+OS
combinations:

   * gcc 4.6.3 on Linux 3.5.0-41
   * gcc 4.4.5 on Linux 2.6.32-5
   * gcc 4.3.5 on JS/Linux 2.6.20
   * gcc 4.8.1 on Windows (Cygwin and MingW)

Misaka requires a C99 compiler due to the use of single line comments.
Misaka does not depend on any other C99 features.


Obfuscation
===========
Main obfuscation is in having a C program that compiles when tiled
horizontally and vertically, while using single line comments in less than
half of the lines.  *And* maintaining a meaningful layout while doing that.

There are other challenges too, of course, like getting a Brainfuck program
to tile horizontally and vertically.  Really, tiling code of any sort
horizontally is an interesting exercise, I encourage everyone to try this
once.

Other features to look for:

   * Peculiar bits that switches horizontal cat to vertical cat.
   * Run-length encoded long cat.
   * Symmetric and recycled variable names.
   * CRC of the source code in the source code.

"gcc -Wall" should provide a hint to where the mode switch happens, it
does not output any irrelevant other warnings (verified on 4.6.3).


Extra files
===========
Extra files included in my submission are informational only, they are not
needed for the program to work.

   * bf.pl = a brainfuck interpreter, in case if you don't have one handy.
   * spoiler.html = making of this program.


About Misaka
============
The name, layout, and functionality of Misaka is inspired by a particular
stackable figure:

   * [Google images](http://google.co.jp/search?q=%E3%83%9F%E3%82%B5%E3%82%AB%E7%9B%9B%E3%82%8A&tbm=isch)
   * [Kotobukiya](http://main.kotobukiya.co.jp/figure/tsubucole_tmi_misakamori/)

--------------------------------------------------------------------------------
<!--
(c) Copyright 1984-2015, [Leo Broukhis, Simon Cooper, Landon Curt Noll][judges] - All rights reserved
This work is licensed under a [Creative Commons Attribution-ShareAlike 3.0 Unported License][cc].

[judges]: http://www.ioccc.org/judges.html
[cc]: http://creativecommons.org/licenses/by-sa/3.0/
-->
# Best of show

Adrian Cable  
<adrian.cable@gmail.com>  


## Judges' comments:
### To build:

    make cable2

### To run:

    ./cable2 file.bmp [color]

### Try:

Extract example-images.tbz2:

    make data

Here is an OCR example that shows all 94 supported ASCII characters:

    ./cable2 ascii.bmp

Here is an example of colored ASCII:

    ./cable2 multi_color.bmp color

Here is an example using different character sizes and different
positions in the same file:

    ./cable2 mixed_sizes.bmp

How about about hand-written C code:

    ./cable2 hello_world.bmp | gcc -xc -o hello -
    ./hello

Sometimes typeset text will work, if the typeset has characters that
are enough to the supported handwritten shapes.  For example,
Menlo, 160 pt:

    ./cable2 typeset.bmp

And as an added IOCCC bonus: :-)

    ./cable2 bonus.bmp

### Selected Judges Remarks:

We can confirm that this is the first time the IOCCC has been used
to peer-review a new research. We had quite a bit of fun with a sharpie and a
scanner.

## Author's comments:
OCR - Obfuscated Character Recognition of Handwritten Text
==========================================================

This entry takes a BMP image file of hand-drawn (mouse-drawn?) text, specified as the first command-line parameter, and converts it to an ASCII text document. Magic!

BMP files created by most paint programs should work. The author recommends Paint.NET.

Features
--------

- Every printable ASCII character is recognized (94 characters plus space), plus a special bonus character.
- Input images can be any size (limited only by memory), containing any number of lines of text.
- BMP is really a mess of different formats, but the program supports most of them from Windows 3.1 and later.
- Hand-drawn characters in the input image can be variably spaced and positioned and be of any width or height, but the bigger the better for accurate recognition (300 pixels tall or more is recommended). Characters must be drawn with a stroke width of around 9 pixels, and separated from adjacent characters. (In Paint.NET a brush of width 9 works well, with anti-aliasing turned off.)
- You can use any colors you like for the text and background, even different colors for different text characters.
- If "color" is specified as the second command line parameter, the program's output will also be in color, on ANSI/VTxxx terminals.

Why is this entry obfuscated/interesting?
-----------------------------------------

- The source is presented as a beautiful moonlit scene, in which a quick brown fox jumps over a lazy dog. Far too often in software development is aesthetic nuance lost in the name of serious-sounding conventions like "GNU style", but not here.
- Newcomers to C find it hard to learn all those different ways to control flow: for, while, if, do, goto, continue, break and heaven knows what else! So, in this program we only use for, so absolute beginners can get into the code straight away.
- To teach newcomers all the important features of C, we demonstrate the importance of the liberal use of short circuits, sequence points, the ternary operator, using x^y or x-y instead of x!=y, using ~x in place of x!=-1 for conciseness, mixing x[y] and y[x] for variety, educational #define's, and so on.
- main is the most useful function in all of C - so it is a mystery to the author why most programs use it only once. Here we use it over and over for maximum benefit.
- The number 42 is featured in the source to provide an answer to the judges' deeper questions.
- How are character colors converted from RGB in the input image to ANSI escape sequences? Clue: the weird macro P does the interesting part of it, but how?
- The program prints a string when the bonus character is detected. How does it do this? Clue: the string to print is defined in the macro $, but how can a string defined in that way ever get printed?

Other notes
-----------

- The novel character recognition algorithm used has not been previously published and was developed by the author specifically for the contest. Should this entry win the IOCCC, it will be the first time (to the author's knowledge) that the IOCCC has been used for peer review/publication of original research.
- OCR in general is a hard problem. Here, we only recognise one possible form for each character. You can see what the supported character shapes look like by looking at the examples in ascii.bmp. If you copy the shape of the character forms you find in there, recognition accuracy should be very good (95%+). A more "useful" version would extend the character stroke table to support multiple different commonly-used forms for each character.
- Despite being the largest possible IOCCC entry at 4096 bytes, it is also probably the smallest general-purpose OCR program ever written (including the character stroke data), maybe by several orders of magnitude.
- The author used an interesting compression algorithm (suggested by Gareth McCaughan - thank you!) to squeeze the character stroke table (containing around 2000 strokes for the whole ASCII character set) into a string constant of just 472 characters.

Bugs/features
-------------

- The width of input images must be a multiple of 4.
- Input images can be 8-bit grayscale, 24-bit color or 32-bit color only. 8-bit color and 16-bit color are not supported. If you use the "color" command-line feature, do not use a grayscale input file!
- Normal Windows BMP files are stored "upside-down", i.e. the bottom line in the image is written first. Some (old) graphics programs actually write BMP files "top-to-bottom" and the program does not support such files.
- Using antialiased brush strokes to draw your letters is fine, however, antialiasing interferes with color detection in "color" mode.
- Only runs on little endian machines (since the BMP format is little endian, and endianness conversion would make the source too large for IOCCC rule 2).

Compiler warnings
-----------------

clang warns about unused expression results, missing type specifiers, and incompatible pointer conversions - all just a fun consequence of the obfuscations.

--------------------------------------------------------------------------------
<!--
(c) Copyright 1984-2015, [Leo Broukhis, Simon Cooper, Landon Curt Noll][judges] - All rights reserved
This work is licensed under a [Creative Commons Attribution-ShareAlike 3.0 Unported License][cc].

[judges]: http://www.ioccc.org/judges.html
[cc]: http://creativecommons.org/licenses/by-sa/3.0/
-->
# Best sparkling utility

J. David Lowe  
434 Tenney Drive  
Rogue River, OR  
97537  
<j.david.lowe@gmail.com>  
<http://www.pootpoot.net/>  


## Judges' comments:
### To build:

    make dlowe

### To run:

    ./dlowe [numbers...]

### Try:

    ./dlowe 0 1 2 3 4 5 6 7
    ./dlowe 16 32 64 128

    echo sparkline of file sizes: `wc -c * | awk '{print $1}' | xargs ./dlowe`

    ./dlowe 0 


### Selected Judges Remarks:

We liked how this entry used Unicode, specifically UTF-8, in a somewhat obfuscated way. 

Also, why doesn't it crash, and produces a correct output when called with one argument
or when all arguments are equal?

For extra fun, compile and run

    #include <stdio.h>
    int main() {
        printf("%d %d %d\n", (int)(-1.0/0.0), (int)(0.0/0.0), (int)(1.0/0.0));
    }

with gcc and clang. 

With GCC (4.7.2), we get 

    -2147483648 -2147483648 -2147483648

and with clang (3.3), we get

    -2147483648 0 2147483647

Which one is correct? :)


## Author's comments:
# sparkl

A tiny implementation of command-line 'sparkline' data visualization.

## Synopsis

    $ sparkl 0 1 2 3 4 5 6 7
    

    $ echo sparkline of file lengths: `wc -c * | awk '{print $1}' | xargs sparkl`
    sparkline of file sizes: 

## Description

This is a handy little tool for visualizing numeric series from the
command-line, using 'sparklines'. Pass it a numeric series as arguments, and
sparkl will display a sparkline graph, which you can use to very quickly get a
sense of the shape of your data.

## Limitations

* Crashes with 0 arguments. It'd be trivial to fix, but adds a few bytes to the
  code.
* Produces bogus graphs when given > about 5000 arguments.
* Only works if your terminal is utf-8 and your font supports the 8 glyphs
  used.
* Produces a few harmless compiler warnings.

## Obfuscation

The code is very terse. I was torn between submitting this version, and a
one-line version compressed using a couple more -D flags.

Hand-rolled utf-8 sequence, magic numbers (what's that 7 for?), meaningless
variable names, reused variables, and so on.

## Acknowledgements

Edward Tufte invented sparklines (among other things.) Brilliant.

Zach Holman's ['spark' utility](https://github.com/holman/spark) was absolutely
an inspiration.

As I was writing up this description, I discovered I'm not the first person to
write an obfuscated C sparkline utility! Vicent Mart created
[this one](https://gist.github.com/vmg/1368661) years (!) ago. (My
implementation is completely independent.)

--------------------------------------------------------------------------------
<!--
(c) Copyright 1984-2015, [Leo Broukhis, Simon Cooper, Landon Curt Noll][judges] - All rights reserved
This work is licensed under a [Creative Commons Attribution-ShareAlike 3.0 Unported License][cc].

[judges]: http://www.ioccc.org/judges.html
[cc]: http://creativecommons.org/licenses/by-sa/3.0/
-->
# Most timely rendered

Christopher Mills  
<mrxo@sonic.net>  


## Judges' comments:
### To build:

    make mills

### To run:

    ./mills

### Try:

    ./mills &

While that is running, point your favorite browser at: [http://localhost:8224](http://localhost:8224)

### Selected Judges Remarks:

Who will be the first to post an image rendered during a leap-second?

## Author's comments:

The Program
===========

This program is a handy graphical clock.  Simply run the program, click *OK* to
any annoying security dialogs that pop up (aren't those annoying?), then fire
up your web browser and type in the following URL:

>  <http://localhost:8224>

You will soon be presented with a lovely dynamically rendered 3D scene that
also convienently tells you the current time!

Usage Notes
-----------

The program will continue to give you the time of day as it changes by
reloading the page as often as it can render.  If you grow tired of watching
your life slip by, hit `Control-C` in the original window.  Note that if you
want to restart the program again, you should wait a minute or two before
doing so.  For details as to why this is necessary, feel free to Google
`TIME_WAIT`.  And while you are there, click on an ad.  They could use the
money.

It would be possible to fix this by adding

    n=1,setsockopt(s,SOL_SOCKET,SO_REUSEADDR,&n,sizeof n),

at an appropriate spot in the code (an exercise left to the reader).  However,
as this limitation is documented, it is not techinally a bug.

Details of Operation
--------------------

The program wears many hats (not literally).  It is

 - a web server
 - a PNG encoder
 - a ray tracer
 - a clock

It replies to web requests with a PNG image that uses the
[Adam7](http://en.wikipedia.org/wiki/Adam7_algorithm)
encoding to return data progressively.  Since the data is returned in Adam7
format, the scene is displayed initally at a lower resolution and allowed to
be progressively refined as time goes on.  The ray tracer is integrally tied
to the PNG encoder, casting rays in the Adam7 order.  The web server uses
PNG primarily because of PNG's ability to return data progressively, and not
as you might think because the PNG standard is so obfuscated as to require
both little- and big-endian encodings at different spec layers.

Since ray-tracing was an obvious choice to return to a web server, I needed
something to ray-trace.  A static scene would be uninteresting.  I took
inspiration (as I often do) from the IOCCC remarks file which says

>  At least one judge prefers to maintain the use of the leap-second
>  as part of the world's time standard.

Then it was obvious; The code should display the time.  It is believed (but
not confirmed) that the code will, in fact, display leap seconds correctly.

To display the time, of course we would need a font.  This font is encoded
as a string, using only the C whitespace characters.  Clearly, the judges
intended this use of whitespace for data compression, since their tool
doesn't count whitepsace in strings differently than whitespace outside of
them.

User-modifyable Features
------------------------

The code can be user-modified simply by changing the build command line.
The following symbols are defined in the build file:

  * `-DLT=x1,y1,z1,x2,y2,z2,...`

    Defines the coordinates of the lights in the scene.  It should be a
    comma-separated list of coordinates (x, y, z), three per light.

  * `-DNL=n`

    Defines the number of lights.  Should be equal to the length of the list
    above (three times the number of lights).

  * `-DEY=x,y,z`

    Defines the position of the viewer (the eyepoint) for the scene.  The eye
    is looking at the origin (0, 0, 0).

Other Build Flags
-----------------

The original program bound the server to `INADDR_ANY` to allow everyone to
experience the server's output.  The Judges suggested that I instead restrict
the bind to `INADDR_LOOPBACK` to reduce security alarms.  As a compliant veteran
of innumerable post-ship late feature additions, I have modified the `Makefile`
to inject the new code without destroying the beautiful spherical symmetry of
the source code.  In addition, I have altered the word `sin_port` to the more
family-friendly version `win_port` to protect against curious impressionable
youth trying to learn about sockets on Internet.


--------------------------------------------------------------------------------
<!--
(c) Copyright 1984-2015, [Leo Broukhis, Simon Cooper, Landon Curt Noll][judges] - All rights reserved
This work is licensed under a [Creative Commons Attribution-ShareAlike 3.0 Unported License][cc].

[judges]: http://www.ioccc.org/judges.html
[cc]: http://creativecommons.org/licenses/by-sa/3.0/
-->
# Most lazy SKIer

Yusuke Endoh  
<mame@ruby-lang.org>  
<https://github.com/mame/>  


## Judges' comments:
### To build:

    make 

This builds endoh1, echo, hello, and tac.
### To run:

    ./endoh1 [file.lazy]

### Try:

    ./endoh1 hello.lazy
    ./hello
    echo Hello | ./echo 
    ./tac < endoh1.c

Be patient with the last one.

### Selected Judges Remarks:

We liked this entry because it can serve as a standalone program as well as an include file; and, as usual,
because its input data is at least as obfuscated as the program itself.

This entry can be considered an abuse of the GCC's optimizer; it takes GCC about 4x longer to compile it
with -O3 than without, compared to clang's 2x.



## Author's comments:
### Remarks

    $ less prog.c
    $ gcc -o prog prog.c
    $ ./prog

... Isn't there any more to it?

Yes, of course.

This is a tool *for C programmers* to play the [SKI combinator calculus][1],
especially, [Lazy K][2].

This program will shine when it is used as a library.
For example, `hello.lazy` is a "Hello world" program written in Lazy K.

    $ lazy hello.lazy
    Hello, world!

where `lazy` is [a reference implementation of Lazy K][3].
At the same time, `hello.lazy` is *a valid C program* that uses `prog.c` as a library.

    $ gcc -o hello -xc hello.lazy
    $ ./hello
    Hello, world!

In other words, this program is a kind of [polyglot][4].

The usage is simple:
you just have to wrap Lazy K program with `#include "prog.c"`.
Note that `#` is a comment in Lazy K.

[1]: http://en.wikipedia.org/wiki/SKI_combinator_calculus
[2]: redacted
[3]: redacted
[4]: http://en.wikipedia.org/wiki/Polyglot_%28computing%29


### Obfuscation

... is inherent in SKI combinator calculus :-)

In addition, it uses various hacks to parse SKI code as C,
and to satisfy IOCCC's size rule.

* Abuse of function pointers
* Code duplication by macros
* Short coding

These led to the good obfuscation.
See Spoiler section in detail, if you need.


### Limitation

This program supports only "Combinator-calculus style notation" of Lazy K.
"Unlambda style" and "Iota and Jot" style are not supported.
Also, it requires a space between identifiers.
In short, use `(S K)` instead of `(SK)`, "\`sk", `**i*i*i*ii*i*i*ii`,
or `11111100011100`.

Huge memory may be required to compile the program
(about 300 MB on my machine).

In addition, there are some limitations (and workarounds)
mentioned in Spoiler section.
But I think it wouldn't matter only when you run the attached programs.


### Portability

I confirmed that the program successfully worked
with the following compilers.

  * gcc 4.6.3 [Linux, Mac OS X]
  * clang 3.0 [Linux, Mac OS X]
  * tcc 0.9.26 [Linux]
    * N.B. tcc 0.9.25 seems to have a bug and fails to run it.

Recent compilers with `-Wall -W -Wextra -pedantic` say nothing.

    gcc -Wall -W -Wextra -pedantic prog.c
    clang -Wall -W -Wextra -pedantic prog.c
    tcc -Wall -W -Wextra -pedantic prog.c

I think it will work on almost all platforms.  I confirmed:

  * Ubuntu Linux
  * Mac OS X
  * Raspberry PI

To check whether the program is specified on the command line
or included from another source file,
the program uses a predefined macro `__INCLUDE_LEVEL__`.
It is a gcc extention, and also supported by clang.
If your compiler does not support it,
you cannot use the program as a library.
But you can compile and run it as a standalone program, at least.
In fact, tcc does not support the macro, but does work.


### Spoiler (rot13)

Gur jubyr cebtenz vf vagrecergrq ol znpeb rkcnafvba.
Sbe rknzcyr, `F (X V)` vf genafyngrq gb n abezny P pbqr, `(f)((x)(v))`,
be fvzcyl `f(x(v))`.
Guvf rkcerffvba ergheaf na nofgenpg flagnk gerr,
naq `cebt.p` rinyhngrf vg.
Guvf cebtenz hfrf irel fvzcyr "grez erjevgvat" nccebnpu
sbe rinyhngvat FXV pbzovangbe pnyphyhf.
Gur erjevgvat ehyrf ner fubja va gur funcr bs gur pbqr.

#### Nohfr bs shapgvba cbvagref

Pbafvqre n frdhrapr bs shapgvba nccyvpngvbaf va P:

    f(k)(k)(k)(k)...

Jung glcr fubhyq `f` unir?
Hasbeghangryl, P qbrf *abg* cebivqr n "erphefvir glcr",
fhpu nf `glcrqrs s (*s)();`.
Fb, V hfrq n urniyl arfgrq shapgvba cbvagre glcr:

    glcrqrs ibvq *(*(*(*...(*(s))()...)())())

Guvf yvzvgf ubj znal nethzragf bar shapgvba pna or pbafrphgviryl nccyvrq gb.
Ohg lbh pna vapernfr gur ahzore ol gjrnxvat gur qrsvavgvba bs znpeb `c`.


#### Pbqr qhcyvpngvba ol znpebf

Arkg, jr arrq gb rapbqr "pybfherf".
N pybfher vf n shapgvba gbtrgure jvgu na raivebazrag
juvpu vf n ersrerapr gb aba-ybpny inevnoyr.

Va guvf pnfr, jr arrq fbzrguvat gung:

  * vf pnyynoyr vgfrys,
  * vagreanyyl cbffrffrf n ersrerapr gb nabgure pybfher nf n aba-ybpny inevnoyr, naq
  * nccyvrf gur vagreany pybfher gb na nethzrag jura vg vf pnyyrq.

Ubjrire, ab glcr va P vf pnyynoyr naq unf n ersrerapr ng gur fnzr gvzr.
(Vg vf srnfvoyr ol qlanzvp pbqr trarengvba, ohg vg vf sne sebz cbegnoyr.)

Fb, V nqqerffrq guvf vffhr ol trarengvat znal shapgvba qrsvavgvbaf
fgngvpnyyl ol (no)hfvat znpebf:

    ibvq *k1; ibvq s1(ibvq *l) { erghea nccyl(k1, l); }
    ibvq *k2; ibvq s2(ibvq *l) { erghea nccyl(k2, l); }
    ibvq *k3; ibvq s3(ibvq *l) { erghea nccyl(k3, l); }
    ...
    ibvq *(u[]) = { s1, s2, s3, ... }

naq ol nyybgvat rnpu bs gurz jura n pybfher vf arrqrq.

Guvf yrnqf gb nabgure yvzvgngvba:
gur ahzore bs cer-qrsvarq pybfherf yvzvgf
ubj znal vaqragvsvref (`F` `X` `V`) bar cebtenz pna hfr.
Ohg lbh pna vapernfr guvf ahzore
ol gjrnxvat gur qrsvavgvba bs znpeb `N` `O` `P` naq `Q`.
(Abgr gung pybfherf ner nyybggrq bayl jura cnefvat;
nsgre gur rinyhngvba fgnegf, "bhg bs pybfher" pnaabg bpphe.)


#### Fubeg pbeqvat

Guvf znetva vf gbb aneebj gb pbagnva n qrgnvyrq rkcynangvba.
Vafgrnq, V whfg nfx lbh bar dhrfgvba.
Pna lbh gryy jung `i f[]={0,0,f+6,f+2,f+4,f,f+3,f+5,f+1};` vf?
V sbhaq guvf ol hfvat FZG fbyire.

--------------------------------------------------------------------------------
<!--
(c) Copyright 1984-2015, [Leo Broukhis, Simon Cooper, Landon Curt Noll][judges] - All rights reserved
This work is licensed under a [Creative Commons Attribution-ShareAlike 3.0 Unported License][cc].

[judges]: http://www.ioccc.org/judges.html
[cc]: http://creativecommons.org/licenses/by-sa/3.0/
-->
# Best use of 1 Infinite Loop

Qiming Hou  
<hqm03ster@gmail.com>  
<http://www.houqiming.net>  


## Judges' comments:
### To build:

    make hou

### To run:

    ./hou [scene-file-name] [options]

    Follow the instructions in stdout, preferably with an auto-refreshing PPM image viewer ready.
    Refresh the image every time the output refreshes, all effects should be more or less recognizable when you see 16.

### Try:

    ./hou BIG
    ./hou old_default.scene BIG
    ./hou otherroom.scene
    ./hou otherroom.scene NAIVE

### Selected Judges Remarks:

You could consider that this program violates the source code size
limit. This is because the first compliation of this program is
really just a decompressor to generate the real source code of the
program.

This program will loop infinitely while progressivly refining a
raytraced image.

## Author's comments:
### Using hou

This program is a programmable rendering engine with a built-in default scene. The standard command line is:

    ./hou [scene-file-name] [options]

As hou runs, it writes a progressively refining image to a ppm file specified in the scene. The initialization may take a while, but once it's done, a rough preview should be available in seconds. Leave hou running for the night, and you get a high quality result like the attached *.jpg files. Kill hou manually after you're satisfied with the image quality.

To save time and energy for the judges, rendered images for all provided scenes are provided as attached files.

### Features

  * Fully programmable: Almost every stage of the renderer is programmable with a shader, i.e., a short script that does something rendering-related. In particular, each scene consists of one or more geometry shaders, a camera shader, and one or more material shaders. Shaders are written in an interpreted language that supports basic arithmetic, a few math functions, variables and procedural call in the CPS (Continuation Passing Style).

  * Fast preview: This renderer isn't just a naive path tracer, it actually uses a modern global illumination algorithm which is robust against challenging scene configurations. You can mostly place light sources and specify surface properties as you please without worrying too much about the convergence speed -- you always get a nice fast preview within one or two minutes. As proof, there is a comparison: "./hou otherroom.scene" gives a rough idea about the overall illumination at 16 samples per pixel (i.e., when the program prints 16), whereas the naive approach "./hou otherroom.scene NAIVE" only produces a mess of white dots.

  * Rich visual effects: The algorithm samples all light path types so most physically based effects can be produced. The default scene demonstrates quite a few of them: reflection, area light, soft shadows, color bleeding, caustics, and depth-of-field blur. Of course, one can also get programmable-shading effects like procedural texturing and approximated Fresnel terms.

  * Accelerated ray tracing: The ray tracing part uses an algorithm better than the brute-force intersection of everything. The renderer even builds an acceleration data structure! Despite the double precision and the single-threaded-ness, it still runs at about 0.5 million rays per second on the author's machine.

  * Pause and resume: Can't run ./hou overnight? No problem! You can kill and resume a rendering session whenever you want. The renderer automatically saves the progress every 16 samples and resumes where it's left off when restarted. Also, each scene/parameter combination gets a different saved session so you don't have to worry about conflicts.

### Abuse of the rules

  * hou.c uses compression to get around the size limit. The compression fully complies with the rules and the guidelines (at least the portion that shows up in grep "size limit"). Please see the "Self-imposed restrictions" section below for more details.

  * hou does not terminate (as suggested by the second line of rule 6).

### Self-imposed restrictions

  * The building process does not involve any OS tool beyond cc and make. No gzip compression! a.c.gz doesn't fit in 2053 bytes, anyway.
  
  * Neither hou.c nor a.c (the *real* decompressed source) uses #define (or cc -D) at all. 

  * The source code is not required at runtime.
  
  * a.c does not drop optional features to reduce size. There are pure optimization code that can be dropped without affecting the converged output (only affecting the ray tracing speed / convergence rate). All files are properly fopened with "rb" / "wb" for Windows compatibility. The PPM header has a comment line for non-standard-compliant viewers (specifically, my old HDRShop 1.0). And there is a nice text message saying "please wait...".

  * Despite the messy look, a.c and hou.c compiles warning-free (hou.c even wastes 18 bytes on #include<stdio.h> just for putchar). a.c compiles mostly clean in the C99/ANSI modes of clang and gcc (with -Wall --pedantic). The only warning generated is a pedantic one: "string constant too long".

### Comments and why obfuscated

  * Both the compression and the rendering use mathematically involved algorithms. Understanding the C doesn't help much if one isn't familiar with the math.

  * Modern renderers provide shader access to just about any internal state. This one follows suit and reuses the same shader-accessible array for all important internal states.

  * Infinity and not-a-number are used during normal course of execution.

  * Previous image-generating entries may take care to hide the "IOCCC" string in the code, but they leave the text clear in the *result*. This entry takes it further and obfuscates the output image as well. Can you find the text in the image? Hint: look up.

  * a.c leaves all shaders in plain text, but the plain text shader code can't be taken for its face value -- the arithmetic rules subtly diverge from our common sense.

  * a.c is less portable than hou.c itself. hou.c only depends on ASCII and should run just fine on 16-bit, small memory, or float-incapable machines. a.c, while still reasonably portable, is quite memory consuming, requires IEEE754-compliant double, and assumes int to be 32-bit.

  * Though technically endian-dependent, a.c remains portable providing that one doesn't copy saved sessions across endians.

### Spoiler

     3225  3225  3225  9  9    3225  3225
     1     1  1  1  1  1  1    1     1  1  
     4225  1226  1  1  1  1    1222  1226  
        1  1     1  1  1  1    1     1 1   
     4226  1     4226  8  4222 4226  1  1

  The program consists of a recursive-descend interpreter, a 3DDDA (3D Discrete Differential Analysis) ray tracer, a PSSMLT (Primary Sample Space Metropolis Light Transport) light path sampler, all squeezed into the size limit using a PPM compressor (Prediction by Partial Matching, and yes, the output format is chosen for the pun). 

  PSSMLT uses the Metropolis-Hasting algorithm to sample a 32D unit hypercube. Each point in the hypercube is interpreted as a sequence of random numbers, and is sent to a path tracer to generate a light path. The point's Metropolis-Hasting energy is then defined as the corresponding path's contribution value to the final image. Since each path is sampled with a probability proportional to its energy, the sample distribution directly corresponds to the final image, which can then be produced as a simple per-pixel histogram of all generated paths. The robustness comes from a state mutation strategy that actively tries to explore the neighborhood of high energy peaks (e.g. paths that happen to hit the light source in otherroom.scene). In addition, a rudimentary form of lens path stratification is added to balance the attention each pixel receives. The Metropolis-Hasting process completely avoids the tell-tale pixel sampling loop required in most other image generation methods.

  The 3DDDA tracer is chosen for scalability: its performance doesn't get much worse as scene complexity increases. Another benefit is that with the DDA code in place one can naturally use hierarchical grids as an acceleration structure. The downside, of course, is that the setup involves quite a few divisions, which naturally turns into division-by-zeros. Fortunately, the IEEE754 standard has a nice set of rules just for this purpose and the arithmetics are organized in a specific way to take advantage of this. The shader interpreter component is relatively straightforward, just an expression evaluator stripped to the bare minimum -- it doesn't even support numerical constants natively. A final little bit is a just-good-enough PRNG (Pseudo Random Number Generator) to replace the low precision Windows rand() and the non-C99 Unix drand48(). An overnight session would run through its short period many times, but that doesn't necessarily map to the same set of paths in PSSMLT. After all, Metropolis et al. used an even worse PRNG in their 1953 paper.

  The PPM compressor uses statically weighted fixed order contexts with an arithmetic encoder tweaked for iocccsize. The encoder emits octet-space pairs where each octet encodes ~6.5 bits of information and each space encodes 2 bits (thanks to the generous definition of "space" in iocccsize.c). The compressor actively shuffles the variable names around until the compressed string happens to contain enough "{}; " to pass the final iocccsize test. There are a few other tweaks:
  
  * The PPM model uses mostly whitespace characters for weights.
  
  * The encoder never emits '"' and '\\'.

  * The decoder uses an O(n^2) algorithm to avoid the gigabytes-sized hash table frequently found in other PPM implementations.

--------------------------------------------------------------------------------
<!--
(c) Copyright 1984-2015, [Leo Broukhis, Simon Cooper, Landon Curt Noll][judges] - All rights reserved
This work is licensed under a [Creative Commons Attribution-ShareAlike 3.0 Unported License][cc].

[judges]: http://www.ioccc.org/judges.html
[cc]: http://creativecommons.org/licenses/by-sa/3.0/
-->
# Most poetic use of strings

Arch D. Robison  
<arch.d.robison@gmail.com>  


## Judges' comments:
### To build:

    make robison

### To run:

    ./robison

### Try:

    echo '1*2*3*4*5*6*7*8*9%1000' | ./robison
    echo '100000000000000000000*(20*(1+(99477941840441*50)))/31664812345028528' | ./robison

### Selected Judges Remarks:

Of integers this prog does a lot,
plus minus, div times (and what not).

And modulus if remainders the needing,
on standard input percent be feeding.

More than one line can thru give input,
when interactive one values more than thruput.

With cut and paste and some time,
one can compute M(23209).

## Author's comments:
Oh, The Strings You Can C!
--------------------------

I love the C language; its tersness is tops.  
But the thing I abhor is numerical ops!  

No shifting, division, remainder, or times.  
No increment, decrement, or subscripting blech,  
No addition, subtraction, or bitwise bool glop.  
As for pointer arithmetic -- totally yech!  

But I do have a pref'rence, for pointer deref'rence.  
I find NOTS are a bang, and relations a ball.  
I like calling routines, and recursions in essence.   
But the thing I like MOST is a string dot h CALL!   

With mem copy I copy, and mem set I clear.   
Take string len of this, and string copy that.  
From my keyboard I pause, to hear subroutines dear:   
The bark of string chrr, and the purr of string CAT!  

One tiny detail that could lead to defeat.  
From where an arg points: string calls only go forth,  
So how to go back, to be Turing complete?  
From standard dot H, to the rescue, q SORT!  

My fixation might hint at a textual bent.          
Does my program compose a tatoo for your shin?     
Play crosswords or translate from Urdu to Tzouby?  
To give it a whirl, just punch 2 + 2 in.  

You can add, do division, and multiply too.  
Take unary minus and also subtract.  
Summing hairs of a walrus?  No longer a fuss.  
Parenthetical grouping -- no pushing a stack!  

Try dividing a googol by one forty three,    
Subtract an octillion - it's simply divine.  
To compute a remainder, inscribe a percent.  
For the sign of the answer, see C ninety nine!    

A hundred and twenty five digits or so,  
Are the lengthiest figures the program can gnash.  
Go over that limit, by even a digit:     
Risk incorrect answers, or witness a crash!  

Say, say, does it have octal or binary zen?  
What about duodecimal, ternary, hex?         
Try the base as an option (of course in base ten)  
Any base two to twenty -- for that is the specs.   

Use lowercase in trans-decimal radix,               
Divide *babbage* (in base seventeen) by *cafe* --   
a nice *fad*, but avoid a division by nix:          
No errant result, but you could wait all day!       

To grok the internals, ask Queen Cleopatra,  
or King Tutankhamun; for him it's a romp.    
Addition by cats, and if given two figures,  
to tell which is bigger, sort down and string CMP!  

Unlawful subtraction, a grade school infraction,   
starts at the left and works to the right.    
Yet more innovation: like Henry Ford's cars,  
With a pound and define, mass production of vars!  

The moral is clear, for programmers out there:   
With the C lib for strings, you can hack with a flair.  


--------------------------------------------------------------------------------
<!--
(c) Copyright 1984-2015, [Leo Broukhis, Simon Cooper, Landon Curt Noll][judges] - All rights reserved
This work is licensed under a [Creative Commons Attribution-ShareAlike 3.0 Unported License][cc].

[judges]: http://www.ioccc.org/judges.html
[cc]: http://creativecommons.org/licenses/by-sa/3.0/
-->
# Most playfully versatile

Yves-Marie Morgan  
<yves-marie.morgan@parrot.com>  


## Judges' comments:
### To build:

        make morgan2

### To run:

    ./morgan2

For the console version (ncurses)

or

    ./morgan2 X

For the graphical version (X11)

### Selected Judges Remarks:

The judges enjoyed playing the game almost to completion; if we remember correctly, 
we managed to place 59 or 60 dominos. We wonder, what would be faster: to play the game to completion
or to write an unobfuscated version of it?



## Author's comments:

This program is a domino game. The goal is to place dominos on the 8x8 grid.
Each domino is made of 6 squares of the color red or green. To place a domino,
at least one of it side shall match the other side of another domino.

# How to play

## Start of the game

At the start of the game, the first domino is placed randomly on the grid. You
get another domino to place by selecting one empty position in the stack on the
right. You can have to 8 dominos pending at any time.

## Moving in the stack

Use `Up` and `Down` key to move the cursor in the stack. Press `Enter` to either

* reveal a new domino if the position was empty.
* select the domino to try to place it if the position was not empty.

The currently selected domino is indicated on the top right.

## Placing a domino

Once a domino has been selected, the cursor moves to the grid. Use `Up`, `Down`,
`Left` and `Right` keys to move in the grid. Press `Enter` on an empty position
to place the domino.

To go back to selection mode, press `Enter` on an occupied position.

The domino can be place in an empty position if all its neighbour have matching
sides and the domino has at least one neighbour.

## Scoring

First, depending on the number of dominos pending in the stack, a bonus is
accorded :
* 1 domino in the stack : 8 points.
* 2 dominos in the stack : 4 points.
* 3 or 4 dominos in the stack : 2 points.
* 5 or more dominos in the stack : 0 point.

Then the bonus is multiplied by the number of matching neighbor the placed domino
has (1, 2, 3 or 4). This is added to the score.

Finally, the total score is divided by the number of dominos placed (1 - 64).

The 3 numbers on display represent : the total score, the fill count and the
final score (total score divided by fill count).

## End of the game

The game is finished when no more domino can be placed and you either :
* filled the complete grid.
* have 8 pending dominos in the stack.
* no more domino can be revealed in the stack (more than 56 dominos placed on
  the grid).

**Note** There is no real end of game detection implemented in the program,
simply press `q` when you have finished...

## Strategy

* Try to minimize the number of dominos revealed in the stack. The lower the number,
the higher the bonus.
* Each domino is unique and all combination of colors exists, so keep track
  of what is already place and what is left.
* Make sure you don't render dead some positions by preventing a future placement
  If the corner of domino does not match another corner in diagonal, the move
  is valid but will prevent some future moves.

# Limitations

* ASCII character set is assumed.
* Requires both ncurses and X11 at compilation and runtime, but selection could
  be done at compilation with some extra code (mainly empty stubs).

# Obfuscation

* 1 letter identifier, reused when possible.
* 1 algorithm, 2 different kind of display (ncurses and X11) mixed.
* No parameters to functions, all variables are global and shared.
* Some variables are not initialized if they have a known value at the time of use.

# Compilation warnings

with gcc 4.7.2 on Linux Ubuntu 12.10 :
* prog.c:46:65: warning: value computed is not used [-Wunused-value]

with clang 3.1 on Linux Ubuntu 12.10 :
* prog.c:23:24: warning: adding 'int' to a string does not append to the string [-Wstring-plus-int]


**!!!!! HAVE FUN !!!!!**


--------------------------------------------------------------------------------
<!--
(c) Copyright 1984-2015, [Leo Broukhis, Simon Cooper, Landon Curt Noll][judges] - All rights reserved
This work is licensed under a [Creative Commons Attribution-ShareAlike 3.0 Unported License][cc].

[judges]: http://www.ioccc.org/judges.html
[cc]: http://creativecommons.org/licenses/by-sa/3.0/
-->
# Most partisan 1-liner

Adrian Cable  
<adrian.cable@gmail.com>  


## Judges' comments:
### To build:

    make cable1

### To run:

    ./cable1 name group1 group2

### Try:

    ./cable1 obama republican democrat
    ./cable1 nixon republican democrat
    ./cable1 bush republican democrat
    ./cable1 kennedy republican democrat
    ./cable1 lincoln republican democrat

### Selected Judges Remarks:

Partisan may be defined as a strong supporter of a cause, party or person.
We need not limit ourselves to the two major political parties in the US today.

Let us consider:

    ./cable1 Cooper Mac PC

Simon works for Apple, so would would expect Mac.  :-)
Landon is a long time Mac user:

    ./cable1 Noll Mac PC

That works too!.  Now Leo brings PCs to the IOCCC judging for cross-platform
testing:

    ./cable1 Broukhis Mac PC

We can test other people.  The late Steve Jobs:

    ./cable1 Jobs Mac PC

That works!  How about Bill?

    ./cable1 Gates Mac PC

A PC guy as expected.  What about that other Steve?

    ./cable1 Ballmer Mac PC

Humm .. maybe there is a hidden reason he is leaving the late Micro$oft? :-)
Why late?  See [this tweet](https://twitter.com/landonnoll/status/401582967123742720).

So how does a one line C source know so much?  Hint: it doesn't.

## Author's comments:
Presidents of the United States of America!
===========================================

Politics is full of memorable one-liners. Without wishing to misunderestimate the taste of the judges, nor prejudge the past, the author hopes you enjoy this contribution to the genre.

This one-line C program accepts as a first command-line argument the last name of any of the last 31 US Presidents (from Franklin Pierce onwards), in lower case, and prints out their political affiliation.

Use "republican" as the 2nd command-line argument, and "democrat" as the 3rd (or equivalent strings of your choice).

Why is this entry obfuscated/interesting?
-----------------------------------------

- The program looks up the name supplied on the command line against a list of Presidents' names, and matches names to political affiliations using a look-up table. But where in the source is the list of names, and where is the look-up table?

Notes
-----

- For Theodore Roosevelt, use: ./cable1 roosevelt republican democrat
- But, for Franklin D Roosevelt, use: ./cable1 fdr republican democrat
- This program needs a little endian CPU to work properly.

Compiler warnings
-----------------

clang warns about a missing type specifier for main, and that implicit function declarations are invalid in C99 (but still accepts them).

--------------------------------------------------------------------------------
<!--
(c) Copyright 1984-2015, [Leo Broukhis, Simon Cooper, Landon Curt Noll][judges] - All rights reserved
This work is licensed under a [Creative Commons Attribution-ShareAlike 3.0 Unported License][cc].

[judges]: http://www.ioccc.org/judges.html
[cc]: http://creativecommons.org/licenses/by-sa/3.0/
-->
2013 marked the "The Twenty Second International Obfuscated C Code Contest"
===========================================================================

Copyright (C) 2013, Landon Curt Noll, Simon Cooper, and Leonid A.
Broukhis. All Rights Reserved. Permission for personal, educational
or non-profit use is granted provided this copyright and notice are
included in its entirety and remains unaltered.  All other uses
must receive prior permission from the contest judges.


Standard IOCCC stuff
--------------------

The IOCCC has a web site and now has a number of international mirrors.
The primary site can be found at,

>	<http://www.ioccc.org/>

Use make to compile entries.  It is possible that on non-Un\*x / non-Linux
systems the makefile needs to be changed.  See the Makefile for details.

Look at the source and try to figure out what the programs do, and run
them with various inputs.  If you want to, look at the hints files for
spoilers - this year we included most of the information included
by the submitter.

Read over the makefile for compile/build issues.  Your system may require
certain changes (add or remove a library, add or remove a #define).

Some ANSI C compilers are not quite as good as they should be.  If
yours is lacking, you may need to compile using gcc instead of your
local compiler.


Remarks on some of the entries
------------------------------

We believe you will again be impressed with this year's winners. 

This year, several 8 people won 9 people won 15 awards.  For the
first time in the history of the contest, one person, Yusuke Endoh,
won 4 times while Adrian Cable won 3 times!  It is also worth noting
that Chris Mills previous win was in 1993.  Welcome back Chris!

We, the judges, were very surprised by this as many of the multiple
winners submitted very different styles of entries.

This year was the first time the IOCCC size tool was used.  Entries
had to print a value 2053 or less when the -i flag was used.

Several people discovered an undocumented feature in that
certain comments such as:

	///*

or:

	*\
	/

were not correctly parsed by the tool.  The guidelines stated:

    In cases where the above summary and the algorithm implemented by
    the IOCCC size tool source code conflict, the algorithm implemented
    by the IOCCC size tool source code is preferred by the judges.

so this abuse was allowed (and encouraged).  The judges hope that
the IOCCC size tool author will patch the tool to block this kind
of size abuse in future contests.

There were some outstanding entries that did not win.  Unfortunately
some very good entries lost because they:

+ were way way oversize and didn't even attempt to justify their
  excess by a clever abuse of the rules

+ depend on a single obfuscation trick

+ could only be run on a particular vendor's platform

+ were very similar to previous winners

+ didn't work as documented

We hope the authors of some of those entries will fix and re-submit
them for the next IOCCC.

There is a risk in submitting an entry that is similar to a well
used theme by previous winners.  Previous winners set a very high
bar.  A new winner must not only compete against other submissions
from the current year, they must also excel over similar winners
in some particularly impressive way.

Final Comments
--------------

Please feel free to send us comments and suggestions about the
competition, this README or anything else that you would like to see in
future contests.

If you use, distribute or publish these entries in some way, please drop
us a line.  We enjoy seeing who, where and how the contest is used.

If you have problems with any of the entries, AND YOU HAVE A FIX, please
send us the fix (patch file or the entire changed file).

For the latest information on how to contact the IOCCC Judges please visit

>	<http://www.ioccc.org/contact.html>

For news of the next contest watch:

>	<http://www.ioccc.org/>


--------------------------------------------------------------------------------
<!--
(c) Copyright 1984-2013, [Leo Broukhis, Simon Cooper, Landon Curt Noll][judges] - All rights reserved
This work is licensed under a [Creative Commons Attribution-ShareAlike 3.0 Unported License][cc].

[judges]: http://www.ioccc.org/judges.html
[cc]: http://creativecommons.org/licenses/by-sa/3.0/
-->
# Best painting tool

Michael Birken  
<o__1@hotmail.com>  
<http://www.meatfighter.com/>  


## Judges' comments:
### To build:

    make birken

### To run:

    ./birken < 17_columns_wide_paint_by_numbers_file

### Try:

    ./birken < examples/ioccc.txt

    perl -e 'map{map{print int(rand()*8);}(0..16);print chr(10);}(0..30);' | tr '[0-4]' ' '| ./birken 

### Selected Judges Remarks:

This program also wins the "Most amusing abuse of the iocccsize tool" award; although not the
absolute best: it is possible to achieve 0 by writing

    /* *\
    /....

The game of Tetris had been used in many endeavors, from studying [algorithmic complexity](http://arxiv.org/abs/cs/0210020) to [treating PTSD](http://www.livescience.com/19894-tetris-treat-ptsd-flashbacks.html).
Using it for painting by numbers looks like a novel idea.


## Author's comments:
### About This Document

This document is best viewed as an HTML file in a browser that supports animated gifs.  Extract `examples.tbz2` for the sample input files.

    tar -xjvf examples.tbz2

### Abstract

By rotating, positioning and dropping a predetermined sequence of pieces, this program exploits the mechanics of Tetris to generate arbitrary images.

### Algorithm Overview

The algorithm converts pixels from a source image into squares in the Tetris playfield, one row at a time from the bottom up.  To generate an individual square, the algorithm assembles a structure consisting of a rectangular region fully supported by a single square protruding from the bottom.  When the rectangular region is completed, its rows are cleared, leaving behind the protruding square.  Three examples of the process appear below.

![](pen0.gif)

![](pen1.gif)

![](pen2.gif)

During construction of a row, all of the squares produced by this method must be supported.  In the images above, the generated squares are supported by the floor of the playfield.  However, if an arbitrary row contains holes, it may not provide the support necessary for the construction of the row above it.  The algorithm solves this problem by constructing a flat platform on top of the row with holes.  In the animation below, a platform is built above a row comprising of a single red square.  The platform is a temporary structure and inserting the final piece removes it.

![](platform0.gif)

Below, a row containing 5 red squares is deposited above a row containing 3 red squares.  This is accomplished by building a flat platform on top of the lower row.  The platform provides the support necessary to generate the 5 red squares.  Finally, the platform is removed by inserting its final piece and the new row drops into place.  Note, if the algorithm needed to generate the rows in the opposite order (a row of 3 red squares above a row of 5 red squares), a platform would not be necessary.

![](platform1.gif)

### Single Square Emitters

For reference, the names of the 7 Tetriminos (the game pieces) appear in the table below.

![](names.png)

This algorithm was tailored specifically to render sprites from early video games.  Those games packed graphics into 8&times;8 tiles where 2 bits were dedicated to each pixel.  Consequentially, sprites usually contained only 3 colors plus transparent regions and they were typically sized either 16&times;16 or 16&times;32 pixels.

The animation below depicts all the patterns used to emit single squares.  J, T and L Tetriminos are used interchangeably within each pattern to produce the protruding square at the bottom.  The algorithm assigns those Tetriminos to the 3 colors present in the sprite.  The remaining Tetriminos are assigned arbitrary colors.  And, all the colors remain constant during gameplay.

![](pen4.gif)

It is not possible to emit a square of all 3 colors in the first 2 and the last 2 columns due to the shapes of the 3 Tetriminos.  As a result, the minimal width of a playfield to accommodate a 16 pixel wide sprite is 2 + 16 + 2 = 20 squares.  However, it turns out that 20 is too small.

As illustrated below, the region above the protruding square cannot exclusively consist of a single row because the only pieces that could fit, the I Tetriminos, are unsupported.

![](pen5.gif)

With 2 rows, the only means of spanning the full playfield width in a way that remains supported is to use S and Z Tetriminos.  But, that will always leave holes in the upper row.

![](pen6.gif)

The minimal number of rows required above the protruding square is 3 and as shown repeatedly above, such patterns do exist.  20 squares is the minimal width required to fit a 16 pixel wide sprite.  But, 20 &times; 3 + 1 = 61, which is not divisible by 4 and hence not constructible out of Tetriminos.  However, a width of 21 yields 21 &times; 3 + 1 = 64, which can be built with 16 Tetriminos.  That width actually enables the algorithm to render sprites up to 17 pixels wide.

The original Tetris playfield is 10&times;20 squares, a 1:2 ratio.  The program maintains that ratio by using a playfield of 21&times;42 squares.

Since J, T and L Tetriminos are used interchangeably to produce the emitted square and 3 squares of those Tetriminos contribute to the row above it, there are 21 &#8722; 3 + 1 = 19 single square emitting patterns.  However, due to mirror symmetry, there are really only 10 patterns.  Clearing 3 rows works for the majority of them.  But, an exhaustive computer search revealed that 2 of the patterns require more.  The next possible option is 7 rows since 21 &times; 7 + 1 = 148, requiring 37 Tetriminos.  As the images below show, those patterns do exist.

![](pen7.gif)

![](pen8.gif)

### Platforms

Before a row is constructed, the algorithm inspects the row below it.  If the row below fails to provide support for all of the squares to be deposited above it, then a temporary platform is required.  When that platform is removed, the new row will drop, leaving some of the squares apparently floating above empty space due to the way that gravity works in the original Tetris.
        
The illustration below depicts the 10 platform patterns (really only 5 considering mirror symmetry).  The construction of a platform begins by dropping a T Tetrimino on top one of the squares of the last generated row.  The remaining Tetriminos support each other down to that first T.  Meaning, as long as the previously generated row contains at least 1 square, like the red square below, then it is possible to construct a flat platform above it for the generation of the next row.

![](platform2.gif)

In the middle of platform construction, the bottom row gets completed and cleared, leaving 3 rows above it.  The final J or L Tetrimino that will remove those rows is not inserted until the square emitters are done generating the next row of the sprite on top of the platform.  That final piece precludes square emission in the first and last 2 columns.  But, as discussed above, the square emitters are limited to the 17 inner columns due to the geometry of the J, T and L Tetriminos used in the process.

Also, of the 19 possible ways to start constructing a platform on top of a T Tetrimino, only the 10 patterns shown above exist.
    
### Program Input

The input sprite is represented textually.  Digit characters `0` to `7` correspond to pixels with colors from the palette below.

![ANSI color palette](palette.png)

As discussed above, sprites are limited to a maximum of 3 colors from this palette.
  
All other characters are interpreted as transparent pixels. 

The maximum permissible size of the input text is 32 rows by 17 columns. Row length can vary as long as no single row exceeds 17 characters. 

Every row must contain at least one palette digit character.

The `examples` directory contains several sprites in this textual format that can be fed into standard input.  Several examples take advantage of the Tetris playfield background color.  Instead of using character `0`, internal regions marked as transparent are effectively rendered as black.

###Program Output

The program conceptually uses Tetris as an output device similar to a line printer.  It restricts itself to those operations that can be performed on the Tetris playfield: spawning, rotating, positioning and dropping Tetriminos.  This process is visually represented using ANSI escape sequences.

### ANSImation

The rate at which the program plays Tetris is completely determined by the rate in which the terminal application receives and displays the ANSI escape sequences.

To slowdown the output programmatically, introduce a delay immediately after the call to `fflush`.

### IOCCC Size Tool Bug

This program demonstrates how to exploit a bug in IOCCC size tool version 2013-07-30-v17.  The first line of the program is reproduced below.

    char*_ = "'""/*";

If that line is added to the top of any program, the tool will report a size of 8.

    ./iocccsize -i < prog.c
    8


When that line is deleted from this program, the tool properly reports the secondary size limit of the program as 2048.

    ./iocccsize -i < prog.c
    2048

Although this bug provides an easy means of circumventing contest rule 2, as demonstrated from the size value, this entry is not necessarily striving for a 'worst abuse of the rules' award.

###Obfuscations

This program is almost, but not quite, entirely unlike a demonstration of good programming practices.    Contrary to other programs, an inspection of this one will certainly reveal that it possesses tea, not to mention an affinity for the constant 42.

Variables are named and ordered to spell out, "Tetris", "ELORG", "DVK" and the aforementioned "Tea".  ELORG is the abbreviation for Elektronorgtechnica, the former Soviet state owned computer organization that handled the worldwide Tetris intellectual property rights.  DVK is the line of Soviet PDP-11-compatible personal computers capable of running Alexey Pajitnov's original 1984 Tetris prototype.

Carefully selected variable names also yielded wonderful expressions like `l=0`, `O=0`, `O=1` and `while(O)`.  "Tetris" also makes a second appearance of sorts:

    [T][e][t]--; while(R+i) { s

The source is formatted to resemble the Tetris playfield midgame.  It is also an homage to all the past IOCCC entries formatted as a compact block of text; the T, orientated appropriately to reflect its name and the first letter in the title of the game, is just a moment away from producing such a text block.

Three tables are encoded as separate strings within the program: 
 
The first string stores the coordinates of the squares of the 19 distinct rotations of Tetriminos (see below).  Since a Tetrimino is a chain of 4 squares, all Tetriminos fit within a 4&times;4 matrix.  To determine the coordinates of the squares, the Tetrimino is pushed to the upper-left of the matrix.  Each coordinate value requires 2 bits of storage.  Consequentially, the four x-coordinates and the four y-coordinates were packed into separate octets.  To convert the octets into valid ASCII characters, the squares were sorted such that the least significant bits stored the largest coordinate values.  The results were offset by 35, the `#` character, which is 1 beyond the ASCII value of `"`, making it easier to pack into a string.  None of the resultant values are beyond ASCII 127.  The coordinates for all 19 rotations fit in a string of length 38.

![](rotations.png)

The second string stores the single square emitter patterns and the platform patterns.  Each pattern is a sequence of pairs, { Tetrimino index, drop x-coordinate }.  As mentioned, there are 19 distinct rotations, requiring 5 bits of storage for the Tetrimino index.  Another 5 bits is required for the drop x-coordinate since there are 21 columns in the playfield.  Necessarily, the pair is stored as 2 separate characters.  By offsetting them by 40, the `(` character, the resultant string almost resembles a long and complex mathematical expression.  The program takes advantage of mirror symmetry by only storing 10 single square emitter patterns and 5 platform patterns.  The pattern lengths are not encoded within the string.  Rather, they are embedded within the string decoding logic.

The third string conceptually stores the default colors of the 19 rotations.  A 3-bit value is assigned to each, covering the 7 possible colors.  In addition, when a mirrored pattern is executed, J exchanges with L and S exchanges with Z, necessitating a second list of 3-bit color values.  Pairs of color values (6 bits) fit comfortably into a character that is offset by `#`.  The result is a string of length 19.

The program is full of subtle obfuscations:

* The unary decrement operator is used in conjunction with global variable automatic zero initialization to set variables to `-1`.  

* The boolean expression of the form, `x + 1`, is used multiple times to determine if a value is not `-1`.  Similarly, expressions of the form `x - y` are used to determine if `x != y`.

* Several arrays store unrelated data in segments throughout the array to reduce named variables.

* The `x["..."]` trick appears once.

* Variable `i` is less than necessary.

* A cursorily glance at the expressions `4&&L` and `m&&e==m` suggests that they always evaluate to true. 

* The varying single square emitter pattern lengths are resolved during string decoding using the clever expression, `(i & 3) - 3`, which identifies pattern 3 and 7 as longer.

* The file size of `prog.c` is a prime number.  Deleting the first line also produces a prime-sized program.  These properties do not qualify the program as a prime number generator.

### Beyond Obfuscation

Due to the contest code size constraint, some optimizations reluctantly had to be omitted.  For example, multi-square emitters are possible:

![](multi2.gif)

![](multi3.gif)

![](multi4.gif)

![](multi5.gif)

In fact, using dynamic programming and creative heuristics, real-time search is possible, enabling patterns like this:

![](triple0.gif)

And, even this:

![](triple1.gif)

In addition, it is possible to extend the algorithm to 6 colors instead of just 3.  This is achieved using I, S and Z to produce the protruding square.  A series of rectangular regions are constructed above those Tetriminos to erode them down to a single emitted square.

The details of these enhancements are left as an exercise to the reader.

### Example Files

The following example files were created by the program author.  They can be freely used and distributed.

* `format.txt` - The layout of the program
* `helloworld.txt` - Hello World, Tetris-style
* `hilbert.txt` - A graphic based on the Hilbert curve
* `ioccc.txt` - IOCCC
* `landon.txt` - Portrait of a man with glasses
* `leo.txt` - Portrait of a man without glasses
* `rhino.txt` - A purple rhinoceros
* `simon.txt` - Portrait of a man without hair

The following files are based on graphics from non-free, copyrighted video games.  The use of a limited number of textual representations of the graphics for the demonstration of this program qualifies as fair use as such files do not significantly impede the right of the copyright holder to sell the copyrighted material and it is not being used to generate profit in this context.  The origin of each file is detailed below (character, game, company, year).

* `belmont.txt` - Simon Belmont, Castlevania, Konami, 1986
* `bloober.txt` - Bloober, Super Mario Brothers, Nintendo, 1985
* `bomberman.txt` - Bomberman, Bomberman, Hudson, 1983
* `boo.txt` - Boo, Super Mario Brothers 3, Nintendo, 1988
* `bub.txt` - Bub, Bubble Bobble, Taito, 1986
* `cheepcheep.txt` - Cheep Cheep, Super Mario Brothers, Nintendo, 1985
* `gurin.txt` - Gurin, Binary Land, Hudson, 1983
* `koopaparatroopa.txt` - Koopa Paratroopa, Super Mario Brothers, Nintendo, 1985
* `lakitu.txt` - Lakitu, Super Mario Brothers, Nintendo, 1985
* `mario.txt` - Fire Mario, Super Mario Brothers, Nintendo, 1985
* `mspacman.txt` - Ms. Pac-Man and Ghost, Ms. Pac-Man, Midway, 1982
* `paranaplant.txt` - Piranha Plant, Super Mario Brothers, Nintendo, 1985
* `samus.txt` - Samus Aran, Metroid, Nintendo/Intelligent Systems, 1986
* `toad.txt` - Toad, Super Mario Brothers 2, Nintendo, 1987

The origin of the remaining files are described below:

* `happyface.txt` - Based on a smiley; rights unknown
* `snoo.txt` - 8-bit version of Snoo, Reddit's alien mascot



--------------------------------------------------------------------------------
<!--
(c) Copyright 1984-2015, [Leo Broukhis, Simon Cooper, Landon Curt Noll][judges] - All rights reserved
This work is licensed under a [Creative Commons Attribution-ShareAlike 3.0 Unported License][cc].

[judges]: http://www.ioccc.org/judges.html
[cc]: http://creativecommons.org/licenses/by-sa/3.0/
-->
# Most tweetable entry

Sandro Maffiodo  
<smaffer@gmail.com>  
<http://www.assezeta.com/sandromaffiodo>  


## Judges' comments:
### To build:

    make

### To run:

    ./prog arg

### Try:

    cat image.rgb | ./prog '  .,:;!$#@'

### Selected Judges Remarks:

On the face of it :-) given what this program one might wonder what makes this winner special.
But when you realize the source is small enough to tweet on twitter you understand.

Who will be the first to tweet this source?  How many re-tweets will such tweet get?
And how many people will really understand the tweet?

## Author's comments:
### Remarks

This program convert an image to an ASCII ART. The program reads a raw RGB image from **stdin** and print the ASCII ART to **stdout**.

The build process will raise some warnings about:

- declaration specifier missing, defaulting to 'int'
- implicitly declaring library function

The program crash if run without parameters.

### Screen size

If you have a terminal geometry than if different from the common 80x25 you can modify the *output width* by changing the value of the first variable:

	d=80

### Something to try

Type this:

	cat image.rgb | ./prog "  .:;Y0"

You can use your own image. Convert the image to a raw RGB image, using imagemagick it's very simple:

	convert -geometry 80x source.jpg image.rgb

This program require one parameter, or crash. The parameter of the program is the *convertion ramp*. You can use different ramps or create your own (for ex. using some letters of your name).
These are some ramps you can try:

	./prog " :1"
	./prog "  .:;Y0"
	./prog " .:-=+*#%@"
	./prog "   .,:!-iots&8%#@$"
	./prog "$@B%8&WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft/\|()1{}[]?-_+~<>i!lI;:,"^`'. "

### 121 byte version

An alternative version of this program is only 121bytes long:

	d=80,e,j;g(){j+=getchar();}main(){for(;;){j=0;g();if(j<0)break;g(g());putchar(" .:#@"[j/3*5>>8]);if(!(++e%d))puts("");}}

This alternative version have a **fixed ramp**. It's smaller but it's not so fun to use...

--------------------------------------------------------------------------------
<!--
(c) Copyright 1984-2015, [Leo Broukhis, Simon Cooper, Landon Curt Noll][judges] - All rights reserved
This work is licensed under a [Creative Commons Attribution-ShareAlike 3.0 Unported License][cc].

[judges]: http://www.ioccc.org/judges.html
[cc]: http://creativecommons.org/licenses/by-sa/3.0/
-->
# Best use of bioinformatics

Yusuke Endoh  
<mame@ruby-lang.org>  
<https://github.com/mame/>  


## Judges' comments:
### To build:

    make

### To run:

    ./prog < input > output

### Try:

    echo Hello | ./prog

    echo Hello | ./prog > hello.c
    make hello
    ./hello

### Selected Judges Remarks:

If you look closely at the source, you will see code that appears
to puts C code that includes itself.  How and why?  Perhaps it is
in the DNA code of the code? Perhaps there are 23 reasons? :-)

## Author's comments:
### Remarks

This chromosome program synthesizes a double helix.
The helix can also be compiled as a C program.

Enjoy DNA programming!

### For more information / backgroud reading:

* This program was inspired by Acme::DoubleHelix:
  http://search.cpan.org/~xern/Acme-DoubleHelix-0.01/

* The synthesized helix just includes the original program at the head.
  Do you see how `prog.c` determines whether it was invoked as a standalone program or included as a header file?
  Note that it does not use any gcc extension such as `__INCLUDE_LEVEL__`.

* The synthesized helix of course follows the base-pairing rules for DNA:
  A is bonding only to T, and C is bonding only to G.

--------------------------------------------------------------------------------
<!--
(c) Copyright 1984-2015, [Leo Broukhis, Simon Cooper, Landon Curt Noll][judges] - All rights reserved
This work is licensed under a [Creative Commons Attribution-ShareAlike 3.0 Unported License][cc].

[judges]: http://www.ioccc.org/judges.html
[cc]: http://creativecommons.org/licenses/by-sa/3.0/
-->
# Most underscored argument

Ferenc Deak  
<fritzone@gmail.com>  


## Judges' comments:
### To build:

    make deak

### To run:

    ./prog

### Try:

    Changing bounding box coordinates in the source to explore
    various regions of the fractal.

### Selected Judges Remarks:

We consider this entry a tribute to all "Abuse of the C preprocessor"
and Mandelbrot fractal drawing entries we've seen over the years.

We liked the use of unary notation facilitated by variadic macros.

## Author's comments:
### Portability

The application was written on a standard Ubuntu 14.04 and tested with
gcc 4.9.1 and clang 3.5 on 64 bit system (though this should not matter).
The application makes no assumption regarding any system specific settings,
and it only needs a console to run. The provided Makefile is just to have
an easy compilation. I don't see any problems porting it to different
compiler/system as long as it supports the C99 standard.

### The application

The purpose of the application is mainly to illustrate the weird possibilities
of the C preprocessor, than to be a full featured console mode Mandelbrot
drawer. There are tools much better suited for drawing fractals.

The usage of recognizable elements from the C programming language in the
application source code is intentionally kept to a bare minimum. If this phrase
would not be true, the application would be the following:

            double                                 _[]={-2
            ,1,-1.3                ,1.3,  0,         0,0,0
            ,0               ,0,50, 80,     0,0,0     ,255
            ,               8,0};    int      main       (
                           int j) {if (j==  1 ){ if(
                   _[12]      >_[10]  )_[17]=1 ;}  if
               (_[13] >_[11     ] ||_[17]==1)  return
             ;_[6]   =  _ [13] / _[11]*(_[1]-_[   0])
            +_[  0];  _ [7]=_[12]/_[10]*(_[3]-_[2] )+_
            [2];_[8]=_[9]=_[14]=0;l2:_[4]=_[8] * _ [8]
            ;_[  5]=  _ [9]*_[9];_[9]=2*_[8]*_[9]+ _[7
             ];_[8   ]  = _ [ 4 ]-_[5]+_[6];_[14   ]++
               ;if((_ [14]<     _ [15])&&(_[4]+ _[ 5]
                   <_[16      ])) goto l2;  putchar(
                           " #@*+   "[( int)  _[14]%
            5             ]);_ [13   ] ++ ;   main       (
            0)               ;_[12]++;      _[13]       =0
            ;if(_                [17]    !=1)      putchar
            (0xa);                               main(1);}

The application expects no parameters, the only way you can change the behaviour
is to modify the source code at the indicated location: the line
`/* <-- Configure here: X1, X2, Y1, Y2 */` is intentionally not obfuscated so
that the adventurous programmer can manually modify the coordinates of the
fractal to be drawn on the screen.

### Compiler warnings

Yes, unfortunately there are compiler warnings of the kind "initialization makes
integer from pointer without a cast" the provided Makefile automatically
disables them.

--------------------------------------------------------------------------------
<!--
(c) Copyright 1984-2015, [Leo Broukhis, Simon Cooper, Landon Curt Noll][judges] - All rights reserved
This work is licensed under a [Creative Commons Attribution-ShareAlike 3.0 Unported License][cc].

[judges]: http://www.ioccc.org/judges.html
[cc]: http://creativecommons.org/licenses/by-sa/3.0/
-->
# Best handling of beeps

Daniel Vik  
<daniel@vik.cc>  
<http://danielvik.com/>  


## Judges' comments:
### To build:

    make

### To run:

    ./prog > foo.c

### Try:

    echo 'Want to hear me beep?' | ./prog  > audio_file.raw

    echo 'No. I want chocolate!' | ./prog | mplayer -demuxer rawaudio -

### Selected Judges Remarks:

This program sets a new tone for obfuscation.  But do you understand
what it says about obfuscation?  Perhaps:

    ./prog < prog.c > prog.raw

might speak to your coding style?  If not, then perhaps:

    ./prog < remarks.markdown | mplayer -demuxer rawaudio -

might help? :-)

## Author's comments:
### Remarks

This program converts ascii text to morse audio file and vice versa. As far as
I can tell, there are at least six chocolate references in this program.

This program can convert text to morse to a raw 44.1kHz stereo audio file.
Via streaming to mplayer, you can listen to the morse audio.

Don't forget the last '-' as it makes mplayer read from stdin.)

## Convert audio file with morse signals to text

    $ ./prog e < audio_file.raw

or alternatively pass a .wav file as input.

The preferred input format 44.1kHz stereo,   but it does  a decent job on mono
input and different frequencies  as well.

### Portability

The program is portable to most platforms. The only system  dependency is that
the program relies on writing binary data to stdout.

Microsoft compilers adds a carriage  return to  newlines,   and to compile the
program with this platform,   the following line  can be added  after the main
declaration in order for the program to run correctly:

    _setmode(_fileno(stdout), 0x8000);

### Known Issues

The program uses a quite simple algorithm for detecting tone on and off events
in the morse signal.   Hence the program  does not work well  with noisy input
signals. I have tested it with several samples of man made morse recordings as
well as computer generated ones.

Generally, any recording from ham  radio transmissions  does not decode due to
noise and echoes.   Other man made recordings may decode,  but some characters
can be  incorrect  due to too big  variation  in length  of tones  and pauses.
However I found some man made recordings on that decode reasonable well.

If a recording don't decode,   you could try to  pre-process the input  with a
narrow bandpass filter on the frequency of the transmission.

--------------------------------------------------------------------------------
<!--
(c) Copyright 1984-2015, [Leo Broukhis, Simon Cooper, Landon Curt Noll][judges] - All rights reserved
This work is licensed under a [Creative Commons Attribution-ShareAlike 3.0 Unported License][cc].

[judges]: http://www.ioccc.org/judges.html
[cc]: http://creativecommons.org/licenses/by-sa/3.0/
-->
# Best choice of optimization

Don Yang  
<omoikane@uguu.org>  
<http://uguu.org/>  


## Judges' comments:
### To build:

    make sinon

### To run:

    cp sinon.c run.c

Then keep running ./glock.sh or ./hecate.sh within a minute with
slight pauses between invocations.

### Try:

    cp sinon.c run.c; ./hecate.sh; ./glock.sh; sleep 3; ./glock.sh; sleep 1; ./hecate.sh

### Selected Judges Remarks:

Try to figure out how this entry determines the optimization level with
which it had been compiled. Is this an example of undefined behavior
or unspecified behavior?

## Author's comments:
### Summary

Sinon is a game of timing, the goal is to eliminate all enemies in
under one minute.

To start, compile and run the program.  To resume, compile and run the
output repeatedly until you have won/lost the game.  For example:

    cp sinon.c run.c
    gcc -O0 run.c -o run && ./run | tee run.c
    gcc -O2 run.c -o run && ./run | tee run.c
    ...


### Details

Sinon is played by compiling and running the output repeatedly.  Two
factors determine what actions are taken:

+ Time since last compilation.
+ Whether compiler optimizations are enabled or not.

If you fire too quickly, the weapon will jam.  If you fire too slowly,
you will not be able to eliminate all the enemies in time.  Thus the
primary objective of the game is to time your compilations just right.

Sinon has two weapons that are selected based on compiler optimization
level:

+ "gcc -O2" or "clang -O2" will fire Hecate II, a powerful rifle that
  requires longer time to cool off.

+ "gcc -O0" or "clang -O0" will fire Glock 18C, a less powerful pistol
  that requires less time to cool off.

Because the weapons cool off independently, the best strategy is to
alternate between the two weapons.  It is fairly easy to win the game
with this strategy even with occasional jams.

If your compiler does not have the right optimizations, only Glock 18C
would be available.  It is still possible to win, but your timing will
need to be more precise.  This is effectively playing the game on
"hard" mode.  It is worth trying this mode even if you have the right
compilers.


### Compatibility

Sinon has been tested and verified to work on these platforms:

+ gcc 4.4.3 on Linux.
+ gcc 4.4.5 on Linux.
+ gcc 4.8.2 on Linux.
+ gcc 4.8.3 on Cygwin/MingW.
+ clang 3.4-1 on Linux.
+ clang 3.4.2 on Cygwin.
+ gcc 4.3.5 on JS/Linux (playable but likely unwinnable, because it
  takes too long to compile).
+ tcc 0.9.25 on JS/Linux (no optimization, so only "hard" mode is
  available).

Sinon is intended to be played in a 80x25 terminal.


### Miscellaneous features

Sinon might be the first game that uses compiler optimization level as
a primary input.

Sinon has a demo mode that plays the game automatically.  Make sure
that there are no files named "run" and "run.c" in current directory
(they will be overwritten) and run:

    perl sinon.c | bash

File size and CRC32 of sinon.c are embedded in line 7.

Process for making Sinon is included in spoiler.html.

Layout of this code is based on Asada Shino, also known as "Sinon",
from Sword Art Online.

--------------------------------------------------------------------------------
<!--
(c) Copyright 1984-2015, [Leo Broukhis, Simon Cooper, Landon Curt Noll][judges] - All rights reserved
This work is licensed under a [Creative Commons Attribution-ShareAlike 3.0 Unported License][cc].

[judges]: http://www.ioccc.org/judges.html
[cc]: http://creativecommons.org/licenses/by-sa/3.0/
-->
# Most dynamic

Cel Skeggs  
<ioccc@celskeggs.com>  
<http://www.celskeggs.com>  


## Judges' comments:
### To build:

    make

### To run:

    ./prog

### Try:

    ./prog

HINT: Try pressing the left and right arrow keys as needed.
Also try pressing space/enter to select options.
Pressing Q or Escape may end the fun before you are ready. :-)

### Selected Judges Remarks:

When the code looks like lemons, it is probably because the LEMONPEOPLE,
or at least the LEMONLORD was involved. :-)

Look at some of the C pre-processor macros in the source code.
Ask yourself why C source is being passed as arguments to some
of those macros.

Now you may observe, while it is running, that some C source code
is being written to a file and then compiled.  And yet that compiled
code is somehow executed from main.  But how?  How is main able to
call code that was written and compiled just in time for execution?

## Author's comments:
### TABLE OF CONTENTS

 * Backstory
 * Known compiler warnings
 * Obfuscation
 * Troubleshooting guide (IMPORTANT!)
 * Q&A

### BACKSTORY

It was ten yours ago when THE LEMONPEOPLE invaded, juicing all in their path.

Attempting to free the Earth from their tyranny, you have endured pulpy and
sour battles.

This has now culminated in you reaching the throne room of THE LEMONLORD.

Armed with your right-facing curly brace, you charge into battle.

(Use left and right arrow keys and space/enter to select options. Press Q or
Escape to quit.)

### KNOWN COMPILER WARNINGS

Unfortunately, it became very difficult to get this entry to fit within the
size requirements. It's currently at 2052 according to iocccsize, and 3994
according to wc -c.

The current size is a third to a half of the original size before compression.

Due to this, it does LOTS of things that subtly annoy compilers!

 * (10) data argument not used by format string

   This occurs because some of the fprintf invocations don't use all their
   parameters. The program should still work fine!

 * (1) using the result of an assignment as a condition without parentheses

   Somewhere, I needed to set a variable and then branch on the result. The
   shortest way was to combine them. Some self-proclaimed "EXPERTS" think this
   is a bad programming practice, but what do they know? :P

 * (1) implicit declaration of function 'time' is invalid in C99

   An `#include` statement is expensive, and I'm broke.

 * (1) control may reach end of non-void function

   Turns out that sometimes, a return statement is too much. This will never
   actually occur, but some C compilers think they know more about my program
   than I do! :P

 * (?) Under some systems, `-fPIC` is irrelevant for shared libraries. If so,
   you should remove it from the Makefile.

## OBFUSCATION? WHAT OBFUSCATION? THIS IS A PERFECTLY NORMAL C PROGRAM!

# THE COOL PART

Take a close look at how it works. Notice that it's passing C code to certain
macros...

Guess what? It's a very simple kind of JIT compiler, though not used as deeply
as would be cool.

Essentially, it generates C code at runtime, dumps it to a file, and then runs
a C compiler on that file, telling the C compiler to generate a shared library.
Then it loads the shared library with dlopen, and...

Ignores the result?

That can't be right.

Well, it is. Instead of using dlsym like a normal programmer, I mark one of the
generated functions with `__attribute__((constructor))`. This means that it
gets called immediately on load, so it can make its functions available.

But wait - how can it link into the main program, either? It has no way to
reference anything in the main executable!

But it does: I'm injecting certain addresses into the generated code, which it
then casts to pointers and accesses! It uses this to make certain functions
available to the main program, so the main program's generated code will then
enter itself where it's needed.

# THE NOT-SO-COOL PART

There are also lots of `#defines`.

No, these are not obfuscation. These are compression.

There is a little bit of obfuscation gained from using the stringification
operator. (I can never remember what it's actually called, but it's the #
operator in a preprocessor macro) - this allows me to pass C code in arguments
to the macros, meaning that it gets interpreted as C code instead of a string
by the iocccsize tool, so it gets counted as smaller! :D

# A SLIGHTLY COOL PART

As part of the JIT compiling, the program hides the fact that it needs ncurses:
it just links ncurses with one of the generated shared libraries, and then can
access the contents of the ncurses library!

# WAIT WHAT

Also, note where functions start and end...

I've messed with the syntax so that it's not actually formatted properly. It
almost looks like it is, but it isn't.

This isn't significant obfuscation as long as you run it through a C source
code beautifier.

But wait... if you aren't careful, running it through a C source code
beautifier won't work. Remember how I'm interlacing generated C code with
actual C code? Note that this WRECKS some beautifiers. I hope you have a good
one!

(There's an obvious way around this but I'm not going to spell it out for you.
That'd be too easy!)

### MISCELLANEOUS STUFF

Do note that there are some other miscellaneous obfuscations, but they should
be easy to understand once you figure out the ones above.

### TROUBLESHOOTING GUIDE

This program is a very easy program to cause to fail!

Some things to check

 * On line 16, where it says `%cinclude "prog.c"`, is `prog.c` the name of the
   original source code file?
 * Do you have ncurses installed?
 * Does your system have `ncurses.h` (like a nice system) or
   `ncurses/ncurses.h` (like a rude system) ?

   If it's the latter (or some other path), you'll need to update line 97.

   (I had to do this under Cygwin.)
 * Does your system need `-fPIC` (or other arcane invocations) to compile a
   shared library? If so, make sure that you include it in the -DCC argument in
   the build script.
 * Does your system have a vague dislike for `-fPIC`? (Like Cygwin.) You might
   need to remove it from the build script.
 * Does your system support `__attribute__((constructor))`? It needs to.
 * Check the file `err`. Maybe it will help you figure out why a runtime-
   generated program failed. The failing program should be found in `t.c`.
 * Can't run a beautifier on the source code? I'm not going to help you there.

I've tested it on the following platforms, in case you need to try it on one:

 * 64-bit Windows 7 32-bit Cygwin with gcc 4.8.2 and standards c89, c90, c99,
   and c11. Note that the program ran as 32-bit due to the version of cygwin.
 * 64-bit Arch Linux with gcc 4.9.1 and standards c89, c90, c99, c11.
 * 64-bit Arch Linux with clang 3.5.0 and standards c89 and c11.

I ran out of time to test it on more systems.

### Q&A

 * Who am I?

   Yes.

 * Why doesn't your program require a pet fish license?

   THE LEMONLORD's pet LEMONFISH was not rendered in the game, and so does not
   require a pet fish license.

 * Was this inspired by anything?

   Yes, this was inspired by a minigame from an open-source codebase of Space
   Station 13. I didn't, however, look at the minigame at all during the
   development of this entry.

 * What's the length of this REMARKS file according to the iocccsize tool?

   `$ ./iocccsize -i <REMARKS.MD`

   `5092`

--------------------------------------------------------------------------------
<!--
(c) Copyright 1984-2015, [Leo Broukhis, Simon Cooper, Landon Curt Noll][judges] - All rights reserved
This work is licensed under a [Creative Commons Attribution-ShareAlike 3.0 Unported License][cc].

[judges]: http://www.ioccc.org/judges.html
[cc]: http://creativecommons.org/licenses/by-sa/3.0/
-->
# Homage to a classic game

Sandro Maffiodo  
<smaffer@gmail.com>  
<http://www.assezeta.com/sandromaffiodo>  


## Judges' comments:
### To build:

    make

### To run:

    cat mario.level | ./prog 320 200 800 300 128 144 mario.rgba mario8.wav 10343679

### Try:

    cat giana.level | ./prog 320 200 1000 300 192 168 giana.rgba giana8.wav 5459393

    cat mario.level | ./prog 320 200 800 300 128 144 mario.rgba mario8.wav 10343679 && telnet towel.blinkenlights.nl

### Selected Judges Remarks:

A classic for a particular generation. Like all good programs, being data
driven means you can do fun things in small spaces.

## Author's comments:
### Remarks

Use tabsize=4 to see the magic

	./expand -t 4 < prog.c

The program returns 0 if the user win or *not-zero* if loose so you can test it and make something useful (or not), like that:

	cat mario.level | ./prog 320 200 800 300 128 144 mario.rgba mario8.wav 10343679 && telnet towel.blinkenlights.nl

This is an engine for **Platform Games**. It can be used to create games like the legendary [Super Mario Bros](http://en.wikipedia.org/wiki/Super_Mario_Bros.).
With this simple and clear sourcecode you can create all the games you want, for free!

In my two tests i tried to create one level of [Super Mario Bros](http://en.wikipedia.org/wiki/Super_Mario_Bros.) and one of [The Great Giana The Sisters](http://en.wikipedia.org/wiki/The_Great_Giana_Sisters).
Both games are classic *platform games* and both share the same fundamental rules:

- there is a player
- there is a powerup that can change the look of the player and/or give to him/her more power!
- there are walls, floors and ceilings. the player can move and jump over these type of obstacles but cannot walk through them
- there are enemies and, if the player collides with an enemy, the player dies or loses its powers

### Regards running under Mac OS X

The color of the sky is wrong on MacOS. You need to flip some bytes from the last parameter of the program:

	MARIO LAST PARAMETER: 4292124159

	GIANA LAST PARAMETER: 3243070463

### Regarding how to compile

The code requires libSDL1.X.

The build process will generate some warnings  (60~ on clang) about:

- **incompatible pointer types**: because all pointers are declared to *int* or *char*, to save tokens
- **type specifier missing, defaults to 'int'**: because i need to save tokens
- **using the result of an assignment as a condition without parentheses**: because while(c=getchar()) is not evil

### How it works

## Parameters

1. Window width
2. Window height
3. Level width
4. Level height
5. Sprites image width
6. Sprites image height
7. Filename of the sprites image (raw RGBA image)
8. Filename of the music (WAVE 8000 Hz 8bit Mono)
9. Sky color. This number depends on the system where you run the program. See **NOTE on MacOS**

## Sprites

The program read a single image that contains all the game sprites. The image must be a grid of 8xN sprites. The size of a single sprite must be square. The program calculates the size in this way:

	sprite_size = image_width / 8

Each sprite is identified by its position inside the grid, counting line by line, from left to right (for example sprite 0 is the top left sprite in the grid, sprite 8 is the first sprite of the second row of the grid).

Some positions of the grid have a predefined purpose:

Position          | Description
:-----------------|:--------------
0                 | Player stand right
1                 | Player walk right frame 0
2                 | Player walk right frame 1
3                 | Player jump right
4                 | Player stand left
5                 | Player walk left frame 0
6                 | Player walk left frame 1
7                 | Player jump left
8 *(second row)*  | Super player stand right
9                 | Super player walk right frame 0
10                | Super player walk right frame 1
11                | Super player jump right
12                | Super player stand left
13                | Super player walk left frame 0
14                | Super player walk left frame 1
15                | Super player jump left
24                | Player dead
32                | Player win
40                | Super player win

All the others sprites can be used as you want, depending on the game you want to create.

## Levels

The program reads the level description from **stdin**.

The level description is a sequence of rows where each row describe an object. You can input as many objects as you want but the maximum number of objects handled by the program is 333. You can modify this value by editing the source here:

	C[333*7],d=333;

Each row have six columns:

1. Screen X: x position of the object in the level
2. Screen Y: y position of the object in the level
3. Sprite: id of the sprite to be used for the object
4. CLASSFLAGS: a bitmask that describe how the object behaves
5. CLASSPARAM0: a parameter that depends on CLASSFLAGS
6. CLASSPARAM1: a parameter that depends on CLASSFLAGS

CLASSFLAGS must be a combination (bitwise or) of some of these constants:

NAME       | CONSTANT  | CLASS
:----------|:----------|:---------
ENEMY      | 1         | An enemy. CLASSPARAM0 can be 0 if the enemy don't move, 1 if the initial move direction is right, -1 if direction is left. All enemies that walk will change its direction after 20 pixels. The sprite of an enemy must have 2 others adjacent sprites: SPRITE-1, used when the enemy die, and SPRITE+1, used when it walks
BLOCK      | 2         | A wall. Player can walk over the object but can not pass through it
GIFT BLOCK | 4         | When the player hits the object from below, a new object is created. CLASSFLAGS of the new object is defined in CLASSPARAM0. The sprite used for the new object is defined in CLASSPARAM1. The sprite of the gift object must have an adjacent sprite: SPRITE+1, used when the block is hit
POWERUP    | 8         | This is the classic Mario's mushroom. When the player hit the powerup object, the player become  *Super player*. If CLASSFLAGS has the bit ZOOM, the player height will be doubled.<br>The *Super player* can hit the enemies without die, but when this happens, the *Super player* goes back to being normal
END         | 16       | When the player hits this object the level ends. Player win
ZOOM        | 32       | This flag can be used with POWERUP to indicate a powerup that will doubles the size of the player (like Mario's mushroom)
DESTROY     | 64       | When the player hits the object the object disappear. This is the classic Mario's coin, but the engine does not counts the points, so, from the user point of view, this object is useless
DESTROYUP   | 128      | This object is like a BLOCK but when the player hits the object from below, the object disappear

If CLASSFLAGS is zero the object has only an aesthetic function.

The last row of the level descriptor must have all its columns set equal to -1.

### Limitations

Some classical features are missing: throw objects, shoot, multiple lives, points counter. You can add those features if you want!

The program allow to run one level only. It's easy to add a menu and multiple levels but the size of the engine will grow too much.

When the *Super player* become bigger (ZOOM flag), the player can collide with blocks and get stuck inside them. This is a KNOWN BUG. When your player become bigger, stay away from blocks!

There is one audio track only (game effects are missing).

### Credits

Some of the sprites used in the examples are identical to those of the original games, others were designed by me.

The music used in the examples have been resampled, starting from the original versions for the [Commodore Amiga](http://en.wikipedia.org/wiki/Amiga) and [Nintendo NES](http://en.wikipedia.org/wiki/Nintendo_Entertainment_System).

[Super Mario Bros](http://en.wikipedia.org/wiki/Super_Mario_Bros.) is a game created by Nintendo Entertainment, my use of the sprites does not intend to infringe the intellectual property of Nintendo but only demonstrate the operation of the program. From my point of view this is a tribute to the legendary game [Super Mario Bros](http://en.wikipedia.org/wiki/Super_Mario_Bros.)!

[The Great Giana The Sisters](http://en.wikipedia.org/wiki/The_Great_Giana_Sisters) is the game created by Time Warp Productions and also for this game worth my previous notes. Long live [The Great Giana The Sisters](http://en.wikipedia.org/wiki/The_Great_Giana_Sisters) !! :)

--------------------------------------------------------------------------------
<!--
(c) Copyright 1984-2015, [Leo Broukhis, Simon Cooper, Landon Curt Noll][judges] - All rights reserved
This work is licensed under a [Creative Commons Attribution-ShareAlike 3.0 Unported License][cc].

[judges]: http://www.ioccc.org/judges.html
[cc]: http://creativecommons.org/licenses/by-sa/3.0/
-->
# Most square (YODA award)

Yusuke Endoh  
<mame@ruby-lang.org>  
<https://github.com/mame/>  


## Judges' comments:
### To build:

    make

### To run:

    ./prog > foo.c

### Try:

    ./prog > main.c

    make main
    ./main Hello

### Selected Judges Remarks:

Big terminals with tiny fonts have their uses in certain cases.
One of them is:

    ./prog < prog.c > treacle.c
    make treacle
    # or instead of make: cc -Wno-empty-body -funsigned-char treacle.c -o treacle
    ./treacle

When using a smart phone to read the output, you may need to
step back to see the bigger picture because that picture is worth
more than 1000 words.

## Author's comments:
### Remarks

You may want to use a large display with a very small-font terminal.

### Spoiler

Decompress `src.zip` if you need explanation.

--------------------------------------------------------------------------------
<!--
(c) Copyright 1984-2015, [Leo Broukhis, Simon Cooper, Landon Curt Noll][judges] - All rights reserved
This work is licensed under a [Creative Commons Attribution-ShareAlike 3.0 Unported License][cc].

[judges]: http://www.ioccc.org/judges.html
[cc]: http://creativecommons.org/licenses/by-sa/3.0/
-->
# Most functional

Freek Wiedijk  
<freek@cs.ru.nl>  


## Judges' comments:
### To build:

    make wiedijk

### To run:

    ./prog

### Try:

    gcc -E prog.c | indent | sed '1,/5.*prog/d'

### Selected Judges Remarks:

C11 features definitely help this entry to be as concise as it is.

The judges would like to think that they had almost understood how this entry works.

If you win a bet by demonstrating this entry, please let us know.

## Author's comments:
### Remarks

- computes the factorial function
- no loops, no explicit recursion
- untyped C without any casts, using a `w` word datatype
- varargs not essential, `w(*)(w,w*)` works just as well
- conforming ISO C
- no warnings when compiled with `-std=c99 -Wall -Wextra -pedantic`
- comments in the code explain what this really is about
- C as a functional programming language:
  untyped lambda calculus compiled to executable C functions
- untagged closures (just a function pointer followed by some values)
- recursion implemented through Curry's paradoxical combinator `Y`
- the readable implementation of `Y` is on lines 29-30:

	W_f = \x.f(xx)
	Y = \f.W_f W_f

- a mixture of strict and lazy evaluation, with a `_` force function
  (John Tromp notes that if Turing's fixed-point combinator
  `(\xy.y\z.xxyz)(\xy.y\z.xxyz)` had been used,
  all applications could have been strict)
- uses `Y` to implement factorial on native `int`s
- 10! seconds = 6 weeks
- answers the ultimate question of life, the universe and everything

--------------------------------------------------------------------------------
<!--
(c) Copyright 1984-2015, [Leo Broukhis, Simon Cooper, Landon Curt Noll][judges] - All rights reserved
This work is licensed under a [Creative Commons Attribution-ShareAlike 3.0 Unported License][cc].

[judges]: http://www.ioccc.org/judges.html
[cc]: http://creativecommons.org/licenses/by-sa/3.0/
-->
# Most likely to succeed

Yves-Marie Morgan  
<yves-marie.morgan@parrot.com>  


## Judges' comments:
### To build:

    make

### To run:

    ./prog [arg ..]

### Try:

    make
    cp -f prog morgan
    ./morgan clobber
    ls

    ./morgan all install
    ls

    ./prog love haste waste supernova
    ls

    make
    ./prog magic
    ls

### Selected Judges Remarks:

Think of this as a Maker Faire's make.  :-)

It works reasomably well.  While not super ultra-featured, it does fair well with the Makefile we supplied.
Not only that, it helped uncover a bug we had in our special Makefile rules.

## Author's comments:
### Remarks

This program is a tiny `make` clone.

It is able to parse a subset of the `make` syntax and will execute rules for
goals given in arguments if they need to (based on timestamp of dependencies
of rule targets).

## Supported features

* Variable assignments (only recursive ones). Variable references with recursion.
* Environment variables are available.
* It is possible to specify variables in command line: `name=value`.
* Variables given in command line will have precedence over variables defined
  in makefile, which will have precedence over environment variables.
* If no goal given in command line, the first target defined will be used.
* Comments, escaped comments, escaped new lines.

It should be able to build programs of previous years with the provided `Makefile`
found in previous contest archives. Simply use this program instead of `make`.
It will recursively use itself for submake (the `MAKE=` assignment inside
`Makefile` will be ignored to continue using itself).

## Limitations / Known issues

* There is a lot of memory leak (not a single free).
* The opened file is not closed.
* The input file shall be named `Makefile`.
* No diagnostic message, but the exit status is non zero to indicates failure
  (failed command in a rule or missing target).
* Only `$<` and `$@` are supported for automatic variables in commands.
* No parallel execution (`-j` option).
* No `:=` `+=` `?=` syntax for variable assignment.
* No built-in function available.
* No pattern targets.
* No pattern substitution variables.
* No built-in rules.
* No built-in variables (except the one from environment).
* No conditional directives.

### Compilation warnings

with gcc 4.8.2 on Linux Ubuntu 14.04 64-bit :
* prog.c:22:15: warning: return makes integer from pointer without a cast [enabled by default]
* prog.c:23:72: warning: signed and unsigned type in conditional expression [-Wsign-compare]
* prog.c:12:11: warning: suggest parentheses around && within || [-Wparentheses]


--------------------------------------------------------------------------------
<!--
(c) Copyright 1984-2015, [Leo Broukhis, Simon Cooper, Landon Curt Noll][judges] - All rights reserved
This work is licensed under a [Creative Commons Attribution-ShareAlike 3.0 Unported License][cc].

[judges]: http://www.ioccc.org/judges.html
[cc]: http://creativecommons.org/licenses/by-sa/3.0/
-->
# Best use of port 1701

Michael Birken  
<o__1@hotmail.com>  
<http://www.meatfighter.com/>  

Alexander Prishchepov  
<https://github.com/sans17/>  


## Judges' comments:
### To build:

    make

### To run:

    ./prog < some_secret_or_something

    ./prog http://host[:port]

### Try:

    ./prog.c

    ./prog http://127.0.0.1:1701

### Selected Judges Remarks:

Port 1701?  Well this is not the l2f registered TCP/1701 protocol.
Sniff the traffic to/from that port.  You will see HTTP client
and server traffic.  The HTML content you may see is static and
immutable.  Nothing funny with the HTTP status codes.  Even the
timestamp cookie, once set, remains static throughout the
session.  The data appears to not be transmitted within the
binary content communicated between client and server.

So how does this program do it?  A trek though the cloak of
obfuscation awaits the reader of the source!

## Author's comments:
### Abstract

When launched in web server mode, this application appears to deliver nothing more than a static HTML page.  But, in actuality, it provides covert file transfer over the Internet.  This is demonstrated by starting the application as a client-side downloader.  The hidden transmitted data cannot be reconstructed or even detected from the binary content of the traffic between the client and the server.

### To run web server

    ./prog < secret_file_to_be_downloaded

Try using the program's source code as the secret file:

    ./prog < prog.c

### To run client-side downloader

    ./prog http://host[:port]

The optional port defaults to 1701.  If the web server instance is started on the same box, try:

    ./prog http://127.0.0.1:1701

It will incrementally display the contents of the hidden file at a rate of approximately 1 baud.

The client-side downloader will automatically terminate if the web server is bounced.

### HTML content

Plug the URL into a browser to view a static HTML page containing ASCII artwork.

### Exploration

Studying the network traffic will reveal that the HTML content is static and immutable, the HTTP request and response fields do not contain anything remarkable, HTTP status and error codes are not exploited, no unusual or deprecated features of HTTP are used, and while the cookie is based on a timestamp, its value also remains unchanged throughout the session.  As mentioned in the abstract, the data is not transmitted within the binary content communicated between the client and the server.  A full explanation of the protocol appears below, but feel free to explore before reading further.

### Inspiration

The inspiration for this program comes from _Star Trek VI: The Undiscovered Country_, specifically the final confrontation between the _Enterprise_ and the enhanced prototype Klingon Bird of Prey.  The definitive feature of the prototype was its ability to fire while cloaked.  But, perhaps even more impressive was its able to keep an open communication channel with the _Enterprise_ throughout the battle, enabling the antagonist Chang to taunt Captain Kirk with Shakespearian quotes while he slowly pelted his ship with torpedoes.  Normally, cloaked vessels must maintain silent running to avoid detection.

The battle is commemorated in the form of ASCII artwork depicting the ships faced head-to-head in the page delivered by the web server.  Plus, the program source code is formatted in the shape of a Klingon Bird of Prey.  The code itself includes a number of Star Trek references: the registry number of the _Enterprise_ (NCC-1701) is defined as a constant; variable names spell out Cpt. James T. Kirk and Odo (the Deep Space 9 character was played by Ren Auberjonois who also appeared as Colonel West in _Star Trek VI_); the STARDATE constant makes timing configurable; and, the constant k stands for Khan (in the final engagement in _Star Trek II: The Wrath of Khan_, the damaged _Enterprise_ managed to disable the USS _Reliant_s shield generator by accessing its prefix code: 16309).

### Secondary size limit

As obligated by a program that employs 23rd century cloaking technology, when the source is fed as input to IOCCC size tool version 2014-09-23-v19, and the -i command line option is used, the value printed is 0.

### Transmission protocol revealed

The client-side downloader relies on the response time of the web server rather than the binary content of the response.  The server transmits 1 nibble at a time by counting to the nibble value via a sequence of rapid responses terminated by a long response.  For instance, the value 5 would be transmitted by making a series of requests that result in 5 near instantaneous responses followed by a half-second delayed response.  The long delay is skipped in the case of 15, the maximal nibble value.  With the aid of an ASCII table, it is actually possible to read the nibbles by repeatedly pressing the refresh button within a browser and observing the page refresh delay.

Nibble Count Coding (file transfer protocol NCC-1701) is faster than transmitting each individual bit as a short or long delay because it sends each byte with 2 long delays whereas communicating individual bits requires 8 long delays in the worst case scenario.  In fact, Nibble Count Coding is faster than applying Huffman Coding since that is designed to produce compact codes under the assumption that the bit value does not affect transmission time.

The server relies on the cookie to identify each client uniquely, enabling it to transfer the sequence independently to each client.

### Configuration

As with all network communication, accurate transmission of data relies on the nature of hardware revealed through statistics and timeouts set accordingly.  The long delay is arbitrarily set to 0.5 seconds.  This is microsecond tunable via the STARDATE constant defined at the top of the source code.  Increase the value in the event of transmission errors.  Decrease the value to download faster and less reliably.

The NCC constant is the web server port number.

### Obfuscations

* The ASCII artwork is compressed using run-length encoding.
* One long string stores a series of strings concatenated together and referenced via pointers.
* The long string is shift encrypted.
* Short and meaningless identifiers are used throughout.
* Reversed array indexing was applied immoderately.
* Minus is used in place of not-equals.
* O and l were selected for their resemblance to 0 and 1 respectively.
* Standard constants and ASCII characters were replaced with their respective numerical values.

### Compiler warnings

For space considerations, the following include statements were dropped resulting in compiler warnings:

    #include <asm/byteorder.h>
    #include <ctype.h>
    #include <netinet/in.h>
    #include <stdlib.h>
    #include <string.h>
    #include <sys/select.h>
    #include <sys/socket.h>
    #include <sys/types.h>
    #include <sys/unistd.h>

It may be necessary to restore some of these under certain environments.

--------------------------------------------------------------------------------
<!--
(c) Copyright 1984-2015, [Leo Broukhis, Simon Cooper, Landon Curt Noll][judges] - All rights reserved
This work is licensed under a [Creative Commons Attribution-ShareAlike 3.0 Unported License][cc].

[judges]: http://www.ioccc.org/judges.html
[cc]: http://creativecommons.org/licenses/by-sa/3.0/
-->
# Most Overlooked Obfuscation

Yusuke Endoh  
<https://github.com/mame/>  
Twitter: @mametter  


## Judges' comments:
### To use:

    make

    ./prog

### Try:

    cat prog.c

    ./prog | diff - prog.c

### Selected Judges Remarks:

At this point you might be wondering, [WTF](http://acronyms.thefreedictionary.com/WTF)?\*

    * What The Freak (polite form)

    * What's This For? (you may be wondering)

    * What the Fish (python form)

How is this code obfuscated?  Well look again:

    less prog.c

    more prog.c

Where did those underscores come from?  Well [RTFS](http://acronyms.thefreedictionary.com/RTFS)!\*\*

    ** Read the Freaking Source (polite form)
    ** Read The Freakin' Screen (polite form)

If you are still puzzled, look at prog.c with your favorite text editor.

## Author's comments:
**Follow this instruction literally!**

    cat prog.c
    gcc -w -o prog prog.c
    ./prog

You will do a double take.


Hint 1: Do `less prog.c`.  You will see an **emphasized** string if your terminal supports bold.

Hint 2: Do `wc -c prog.c`.  This is very long one-liner.

Spoiler: Open the source with an editor like `vim` or `emacs`.

--------------------------------------------------------------------------------
<!--
(c) Copyright 1984-2016, [Leo Broukhis, Simon Cooper, Landon Curt Noll][judges] - All rights reserved
This work is licensed under a [Creative Commons Attribution-ShareAlike 3.0 Unported License][cc].

[judges]: http://www.ioccc.org/judges.html
[cc]: http://creativecommons.org/licenses/by-sa/3.0/
-->
# Best One-liner

Yusuke Endoh  
<https://github.com/mame/>  
Twitter: @mametter  


## Judges' comments:
### To use:

    make

    ./prog <a number of arguments>

### Try:

    ./prog @ @ @ @ @ @

    ./prog @ @ @ @ @ @ @ @ @ @ @ @

    ./prog $(perl -e 'print "@ " x (2*3*5*7);')

    ./prog $(< Makefile)

### Selected Judges Remarks:

For this one liner it is best to avoid prime numbers. The output groups
factors in the x-y dimensions. How many factors can be represented before you
run out of command line argument space? How could you modify the program to
experiment with numbers that have more or larger factors?


## Author's comments:
Visual factorization 1-liner.  Try:

    gcc -o prog prog.c
    ./prog @
    ./prog @ @
    ./prog @ @ @
    ./prog @ @ @ @
    ./prog @ @ @ @ @ @
    ./prog @ @ @ @ @ @ @ @
    ./prog @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @

Inspired by [Animated Factorization Diagrams](http://www.datapointed.net/visualizations/math/factorization/animated-diagrams/).


EDIT: `prog.orig.c` is the original version that I submitted.  Gil Dogon kindly improved it during the review.  Thank you!

--------------------------------------------------------------------------------
<!--
(c) Copyright 1984-2016, [Leo Broukhis, Simon Cooper, Landon Curt Noll][judges] - All rights reserved
This work is licensed under a [Creative Commons Attribution-ShareAlike 3.0 Unported License][cc].

[judges]: http://www.ioccc.org/judges.html
[cc]: http://creativecommons.org/licenses/by-sa/3.0/
-->
# Back to the Future Award

Yusuke Endoh  
<https://github.com/mame/>  
Twitter: @mametter  


## Judges' comments:
### To use:

    make 
    
    ./prog

### Try:

    make -B BACK_TO=ioccc.c
    
    ./prog

### Selected Judges Remarks:

Like Marty and Doc, something nostalgic from 1984 appears live in October of 2015! 
The author of this gem is a true Delorean!

A question for inquisitive readers: is the implemented subset of PDP-11 instructions Turing-complete?
(For a clue, see the end of the author's remarks.)
If in doubt, use [APOUT](http://www.tuhs.org/Archive/PDP-11/Emulators/Apout/).

## Author's comments:
### Hint / Compatibility

* A little-endian system is required due to an external factor.
* Strictly speaking, this program does not comply with any C specification for the same reason.  But I believe it is reasonably portable.
* It uses a GCC extension but works on clang.
* This is a kind of emulator.  You may find its architecture name if you look at the source code from all angles.
* Find main() function.


### Spoiler

This program is a joke PDP-11 emulator.  ("ll-dpd" is embedded in the code.  Read it upside down.)

You got it?  This program is supposed to be used in this way:

    $ wget http://ioccc.org/1984/mullender.c
    $ clang -o prog prog.c mullender.c
    $ ./prog

You can enjoy the legendary winner of the first IOCCC, again.


### Internal

This program uses `__attribute__((constructor))`, which is a GCC extension, to hijack the main function call.  And then it interprets main as an instruction sequence.

It supports the minimal subset of instructions and addressing modes which are needed for mullender.c to work:

* Instructions
  * BR: branch
  * MOV: move
  * SOB: subtract one and branch
  * SUB: subtract
  * TRAP 4: write syscall
  * TST: test (no flag is supported, though)

* Addressing modes
  * 0: Register
  * 1: Register deferred
  * 2: Autoincrement
  * 4: Autodecrement deferred
  * 6: Index (incomplete)


### Limitation

Non-trivial combination of instruction and addressing mode may cause undefined behavior (unsequenced modification), such as attempting to autoincrement a destination register.  Index addressing mode works well only for R7 (PC register).


### One more thing

Note: the program writes a binary to stdout.

    short main[]={5568,1,-30460,12,2782,0,-29921,2056,-4864,6873,770,30054,11886,
    24948,114,21716,-28851,14043,-8944,32691,-16187,-12247,22692,-9781,-20403,
    -11771,16546,18710,17873,9233,31304,-32215,-24382,-28247,-25916,10466,24988,
    -3404,-4177,-28528,-531,-3016,17300,-28552,-7708,-26180,-4297,-367,-2312,
    -25611,28535,-8533,24004,25421,-1224,-5354,-20807,-21589,-6761,-5203,-1055,
    -6715,-26673,-1433,-17732,-24198,14681,-3714,-6660,-14891,-25575,20349,-7701,
    -8336,31433,16695,-14773,26819,3096,-12584,-28808,17825,-21200,-32399,15877,
    -28890,-3728,-27126,21375,-32630,-7615,32004,-29230,-6611,-5508,-28921,12418,
    27204,-5725,9643,3520,26836,-29347,2101,-29311,9320,29287,-29990,-6593,29825,
    -29114,16232,25641,20672,-23501,-32127,-6546,-956,10474,-29647,1070,5516,13760,
    -27814,-32488,-28006,-17968,-3146,10963,19234,22132,23988,7142,5523,9639,-6888,
    -11428,7964,23099,-16822,16518,31109,-12958,10351,2434,3091,3625,2244,27512,
    -28559,-10724,-19377,23625,30056,11478,-21176,27660,26517,-29037,-9390,12297,
    -11903,5980,-21927,-7483,6671,11249,29638,-23827,-26358,-6856,-1063,-5303,
    26636,25797,31818,26798,-4243,-18772,-13266,27472,-12005,-10642,-22524,24373,
    -13111,-9062,6274,-20002,24150,22189,-14965,-31249,-13934,-6341,-18384,-32054,
    -29246,10622,-9260,19428,-15485,2724,23810,16447,11627,18604,2739,27812,30295,
    -21538,-31786,11355,-11308,-9006,-4987,25363,-18927,-21130,-31213,-27411,17231,
    -19608,20232,27754,16476,11213,-19803,-24048,30918,-25329,21233,-10160,13519,
    11828,26653,-6703,10893,6871,-12417,24471,20310,-12137,-19677,4457,-19530,
    10147,17724,533,-10055,27076,10264,11274,-10511,4809,25208,16065,-5105,-19953,
    3772,-12124,13475,-27559,-9955,26446,15133,15207,-23640,6425,-11010,28688,
    -20064,26353,-889,-25008,10380,-14449,-6894,18920,-23900,16902,-31018,16093,
    20875,-19576,4585,13126,18589,24789,19424,31274,-5059,-14538,-3125,-16527,
    -25070,-9013,26628,15756,-7652,30841,-1283,17707,25717,-18315,-6342,6880,
    -19176,6995,5672,2853,-9044,-3409,-14421,-7522,13108,20582,-25317,1376,-5648,
    13821,17300,1220,-29437,-25832,-8332,-15575,-9744,28297,31995,-1217,23852,
    14382,31059,9160,-3296,20287,-28357,24449,-10323,-21992,-4655,-32548,13237,
    -15083,-25226,-21121,2015,-8996,-20247,-27551,-14771,-16089,-6920,-9645,21578,
    7142,-5613,14029,24730,-29253,13931,-3862,-16634,-7388,16951,15771,31302,
    -22186,-6716,18416,1698,-26200,-16231,9821,-10886,-4994,-30527,-9448,-16923,
    29549,-11207,-14909,-3643,-27548,17865,28859,29753,17616,16874,-17733,9424,
    21435,-31715,24544,8666,30844,25075,-18267,12027,-5346,2717,19615,-4548,-21763,
    28514,11691,22268,-2338,1406,-27379,-23568,-24525,13633,11295,-14715,7877,
    -27669,3475,20345,7779,-17849,2184,7132,4079,-24937,11585,22740,5810,-10855,
    16203,-6371,23235,-7,-24828,-11205,-11006,-10,-17812,-14274,11504,-27517,463,
    4498,-32180,-9775,-3190,-22435,-18662,-30146,-31834,-26449,-19374,-12616,
    -10596,14341,-10089,-18449,-16535,21439,21191,-1651,7695,-30009,-23339,-8675,
    -20774,21588,-2793,8218,-14337,-10866,14060,-15343,31712,25247,-8539,18074,
    -28683,-7363,-7663,-3563,-30718,17771,28687,-30495,30584,14022,-28053,5292,
    -31576,-32486,-15470,-1330,23551,-2185,-10829,-13216,-4825,-2964,-14668,24559,
    -4930,23731,-1152,-11493,-2321,15987,-27073,-20305,-24065,-25048,32750,-27440,
    -1169,-25633,-4356,-24993,30439,-17165,-4580,8662,22655,-4588,-6162,-3122,
    31986,-2569,20371,-12320,-25613,-16133,-25644,23677,12254,5855,26325,-13425,
    -15903,-1930,-28488,31222,31153,17607,-2758,7594,-8868,30434,-2518,27956,
    -19424,7370,6199,-17602,17347,-14358,25588,11611,-25209,-23701,-27444,-29788,
    2680,-27406,9318,22483,-28356,28482,4577,-14891,17323,-30152,2507,2977,5004,
    -11696,-31623,-15149,13357,28938,-14048,19490,-19860,-26050,10842,-24922,
    -20986,8847,-31184,28519,-29168,32195,10516,25713,-3493,670,31283,-12769,
    -17461,11357,13180,26133,15944,18051,-32167,-27990,16813,17676,21787,-17578,
    11173,19093,2836,656,-15239,4632,23937,4106,-21655,-7494,-21575,-17647,-18465,
    -14654,-29990,-10707,-12440,21465,5822,26164,-1404,-14303,-26635,-6900,-23611,
    11998,-18551,971,27579,13325,4579,23059,29281,22291,29880,-17546,25664,-14990,
    -526,-35,28218,-3214,11965,11263,6633,30719,32400,-29,-3733,24383,32678,-27542,
    -4444,6196,5975,-19722,11902,16840,-11680,11146,-26391,-8980,21573,-9043,2349,
    -12887,5916,-2996,10410,-23374,26338,11867,-14518,18281,14450,-5815,13842,359,
    25450,27043,3355,13423,-20880,-26311,-30720,-2503,-6046,-18156,-18558,-14774,
    -15664,-29001,3365,-12689,10233,23608,24692,12039,15445,18411,-27469,3764,
    -10841,22672,23844,2282,-12443,2851,-27163,13651,13738,17201,-29819,27414,
    -29764,-5308,-16171,-32427,-26312,-7460,-27376,-6004,25717,29254,-15015,8754,
    15493,22232,-28513,-23355,23676,7736,10571,-8120,-16677,7696,32549,-2646,25538,
    3498,30960,-28459,24716,12655,-10496,402,26209,482,-16661,-20350,-3403,14015,
    32299,11262,-25886,4092,-7843,-100,-1975,-58,-3729,-19269,-23583,-6929,20000,
    -6089,17780,-3250,29830,19954,-29277,27896,10330,9277,-25358,31279,-14454,
    24203,-30170,12872,-21973,-25773,-10502,-6647,-26143,6394,-13479,-24559,23007,
    -21844,1505,24702,-23187,-24364,-20470,20765,-7107,15674,9404,17408,17964,
    19820,18952,2154,-26052,30056,-3227,17770,-8557,-31018,-27700,-25974,9003,
    18218,22730,-19981,6737,3532,1562,-23626,14990,28472,-5270,17358,-32204,-29197,
    -3647,4296,8588,25302,-23906,30328,-29119,-24392,8992,-16557,31530,-31216,
    14107,13041,-6976,7529,-8296,17865,-1462,8181,-21588,-131,-10177,-25931,-14627,
    8301,3708,-32097,20808,13892,-21179,1192,20853,3249,-8774,20843,3520,24954,
    -14215,-25170,-16170,2390,25964,-23923,-17464,-7177,-27568,-9880,-4647,-7323,
    15388,2113,-12338,-7737,26255,26818,-22156,-19610,-911,-17057,-556,29935,27647,
    31806,23676,-18132,-19234,-10869,-3715,24983,-10900,-29564,19856,-16392,-31860,
    -25826,24077,12080,15383,-29852,-2266,-27217,31931,-3183,17385,-14211,19050,
    -2449,-468,-2871,-11466,973,2866,649,1367,-8688,-24069,20992,25139,-25850,1184,
    15851,785,16951,12160,22337,-21851,1849,-18801,14247,-429,-12682,30881,-11273,
    -24819,-9794,8389,-27287,7525,16633,1328,-26650,32607,-8217,31912,7774,-16188,
    -3546,-6550,-16279,-32696,1940,2577,-23723,-6484,2009,-424,27833,-21763,-13902,
    7044,27360,-18450,27889,23987,3137,-7669,-5784,-7490,24946,32302,26464,-15513,
    28898,2493,-17645,-4615,-13434,-20884,-4058,-29951,-22281,24784,21083,-8536,
    22147,-11261,-15069,20659,2993,19029,21909,6748,-3263,1401,30960,11000,-16871,
    -30566,-14959,-26356,-2885,21526,-26531,31063,12857,4992,-5067,3130,-17602,
    -1732,-6593,30200,24679,3267,310,20733,24863,-15669,7875,-4577,-13821,-22325,
    15548,29744,3733,-14547,21459,22122,3854,-2572,30197,-24770,-21263,8793,-8316,
    1571,28191,-16143,-6446,31524,-26496,-17349,-29097,2806,11281,-7041,-683,14149,
    19689,-22094,-1657,-30904,183,-15226,-6358,25461,461,1495,28345,-10554,-4004,
    27119,13484,-21600,-12272,-7272,-14064,-299,10697,11280,19066,-9841,-7265,
    -18002,19906,-17247,21482,-10939,-5897,-22300,-13978,27575,-8684,-6222,-19041,
    5788,-30863,-10134,15142,2895,14705,-17713,12940,-21535,-11619,29416,18417,
    -24973,24867,-26462,-24910,-32556,-26705,-7187,-7750,-758,-14809,20289,9260,
    13778,-1422,30301,-1922,30646,27662,-15465,-912,29340,13846,-1263,28887,-20019,
    32421,-29411,-27632,-7495,-8368,29230,-6386,-19536,-5235,2054,1854,23563,12348,
    -15165,-2936,-28063,-15760,20126,-25531,4963,-5739,23182,16895,-17258,-10470,
    -3969,-7742,-140,4475,-24014,-31961,19231,27153,-18551,20157,26443,11530,
    -22214,2284,-24238,-31051,-26422,9088,29868,18458,8488,-9515,6799,-12507,54,
    -19441,-32665,12561,23560,4725,-28617,-14800,-10224,-13503,-17636,-16823,
    -24072,18735,-29798,-23658,-670,-21769,7489,-6468,-8961,-14785,22255,11582,
    -29831,16303,-19652,2922,-4362,22966,16173,-18446,-6148,27381,-8493,-32289,
    24005,-3027,-18665,-16472,-17793,-27027,-7443,17854,31365,-17726,-2510,-17546,
    14893,21773,-23634,21117,32533,6637,-1106,-8152,-3672,-113,-2149,-34,-22700,
    -4102,-28533,-14104,-10086,4378,13695,-15320,-28258,2246,7595,30021,13281,
    -11968,-29983,14274,27152,26713,19434,17058,1142,-3043,-16496,18630,-11976,
    29168,-3634,32746,27287,-268,16711,-8712,-471,12895,17406,-22548,-3969,-10733,
    13128,10530,-31667,7929,-32277,30926,-1983,8401,-7705,6790,4532,1442,26728,
    29600,-15358,21622,9744,11406,15989,-30741,-15044,29913,24534,6774,-3755,17623,
    19647,18762,10042,9653,-5889,2408,-32579,-6285,-28559,-30655,6294,-21175,4390,
    1668,25437,2821,21066,-13680,5274,-27253,-5248,-26307,29744,-26428,25358,17196,
    15199,-29784,-4604,25653,-8048,-23131,-28995,31340,-9558,26186,11268,27916,
    9646,-7389,-11384,-29116,-4100,160,18394,7856,738,-25920,12148,24713,-31664,
    8203,-25556,13494,30352,29161,30898,1432,-5991,25411,1344,-4019,22299,15685,
    -16401,-23136,-28110,11874,-18945,1879,2,0,-32256,-20996,-18169,29220,12,0,0,0,
    335,-27277,-30776,20480,0};

--------------------------------------------------------------------------------
<!--
(c) Copyright 1984-2016, [Leo Broukhis, Simon Cooper, Landon Curt Noll][judges] - All rights reserved
This work is licensed under a [Creative Commons Attribution-ShareAlike 3.0 Unported License][cc].

[judges]: http://www.ioccc.org/judges.html
[cc]: http://creativecommons.org/licenses/by-sa/3.0/
-->
# Most Pointed Reaction

Don Yang  
<http://uguu.org/>  


## Judges' comments:
### To use:

    make
    echo Some text | ./prog 
    

### Try:

    echo IOCCC 2015 | ./prog | tee output.c
    make output
    ./output

    echo IOCCC 2015 | ./prog_c11 | tee output.c
    make output
    ./output

    echo IOCCC 2015 | ./prog_c++98 | tee output.c
    make output
    ./output

### Selected Judges Remarks:

Before analysing the code in detail we were able to guess two out of four tests
this entry uses to tell the 5 languages/flavors apart. Can you find all four?

The way the text is encoded in the output doesn't cease to amaze. Can you tell
why an array of 512 elements is needed?

## Author's comments:
Fuuko is a sea star generator.  Feed her some input through stdin to
get lots of sea star patterns in stdout.

    gcc -O3 -std=c90 fuuko.c -lm -o fuuko_c90
    echo IOCCC | ./fuuko_c90 > output_c90.c

If you compile with a C99 compiler instead of C90, the sea stars will
have eyes.

    gcc -O3 -std=c99 fuuko.c -lm -o fuuko_c99
    echo IOCCC | ./fuuko_c99 > output_c99.c

Don't like sea stars?  Use a C++98 compiler to get dango instead.

    g++ -O3 -std=c++98 fuuko.c -lm -o fuuko_cpp98
    echo IOCCC | ./fuuko_cpp98 > output_cpp98.c

Don't like dango either?  Use a C++11 compiler to get just circles (or
swiss cheese, if you prefer that).

    g++ -O3 -std=c++11 fuuko.c -lm -o fuuko_cpp11
    echo IOCCC | ./fuuko_cpp11 > output_cpp11.c

Don't like any of these patterns?  Use a C11 compiler and there will be
no extra patterns.

    gcc -O3 -std=c11 fuuko.c -lm -o fuuko_c11
    echo IOCCC | ./fuuko_c11 > output_c11.c

Regardless of which of these C/C++ dialects you choose, the output
will all be valid C90 code that reproduces original input on stdout,
filled with pointer dereferences (C stars).

Next time people ask you for a few pointers on C, you can run their
question through Fuuko and give them pointers all day long.


### Compatibility

Fuuko has been tested under these environments:

- gcc 4.9.3 on Cygwin
- gcc 4.9.2 on Linux
- gcc 4.8.4 on Linux
- gcc 4.6.3 on Linux (doesn't support C11 nor C++11)
- gcc 4.3.5 on JS/Linux
- clang 3.5.2 on Cygwin (doesn't work with optimization enabled,
  probably cygwin bug)
- clang 3.5.0 on Linux
- clang 3.4.1 on Linux
- tcc 0.9.25 on JS/Linux (C99 only)


### Features

The most obscure parts are in detecting the subtle differences in
different dialects.  The standard committees put a lot of effort into
avoiding "quiet changes", but Fuuko is still able exploit a few of
those.  It should be an interesting exercise for the reader to figure
how she did it.

Output patterns are usually random (except for C11).  The built-in
random number generator is seeded using ASLR.  On systems where ASLR
is not so random (such as cygwin), you can introduce randomness by
changing number of command line arguments to Fuuko.

Output is somewhat robust: corruption on most of the lines will
usually result in a compiler warning.  This is because the output is
vastly redundant: For ~1K of input, expect output to be on the order
of ~1MB, and take ~500MB of RAM to compile.

CRC32 of source code is embedded in the source code itself.

Process of writing this program is included in spoiler.html

Code layout is inspired by Ibuki Fuuko, for her love of sea stars.

--------------------------------------------------------------------------------
<!--
(c) Copyright 1984-2016, [Leo Broukhis, Simon Cooper, Landon Curt Noll][judges] - All rights reserved
This work is licensed under a [Creative Commons Attribution-ShareAlike 3.0 Unported License][cc].

[judges]: http://www.ioccc.org/judges.html
[cc]: http://creativecommons.org/licenses/by-sa/3.0/
-->
# Best Handwriting

Etienne Duble <etienne.duble@imag.fr>  
<http://lig-membres.imag.fr/duble>  


## Judges' comments:
### To use:

    make
    
    echo Some text | ./prog

### Try:

    echo Hello, world | ./prog

    DRAFT=1 ./prog < prog.c

    ./prog
    > [type]
    (...observe...) 

    ./prog < prog.c

### Selected Judges Remarks:

Beautiful penmanship! However, your fonts may vary.

How does this entry compress the font it uses? What's the purpose of lrand48()?
Why does the program dump core, when it does :) ?

## Author's comments:

### Introduction

This program **prints text in your terminal with an interesting
hand-writing effect**.

It uses the *braille patterns* range of the unicode standard: this
allows to consider each terminal character as a tiny 2x4 bitmap.

Turning the Braille code into something visual might be considered
blasphemous. When I was fighting to make this program work, I started
wondering if it was not the reason for its very erratic behaviour.

### prog.c vs prog.orig.c

The file `prog.orig.c` is the one I submitted.

Gil Dogon noted a few unsafe statements (statements whose behaviour is
undefined in the C standard and, as such, could cause issues with other
compilers or optimization levels). These have been fixed in `prog.c`.
After this fix, in order to remain rule-2-compliant, a variable name has
also been shortened in this file.

### How to build

If you have `clang`:

    $ CC=clang make -e

Otherwise (gcc):

    $ make

(You will get a few warnings in this case.)

### How to use it

You need a terminal configured to handle an *UTF-8* encoding and a
font including *braille patterns*.
This is the default on most modern GNU/Linux operating systems.
The default terminal application (gnome-terminal) or even a simple
xterm should render things properly.
I tested this on several Debian and Ubuntu systems, 32 and 64bits (no configuration was needed).
I also tested it on FreeBSD 9.3 32bits (font and encoding configuration
was needed in this case). 

Basic mode:

    $ echo 'I am testing this thing.' | ./prog
    [... rendering ...]

    $ ./prog < lorem-ipsum.txt
    [... rendering ...]

Interactive mode:

    $ ./prog
    > hello world!!!
    [... rendering ...]
    >

### Obfuscation

This entry is obfuscated in various ways:

*   The structure is hidden by avoiding loops, 'if' statements, ternary
    conditionals, and jump-related instructions. Instead, recursivity is
    heavily used.
*   Merging all functions into one added even more recursivity. ;)
*   The provided code does not contain the same number of opening and closing
    parenthesis.
*   Preprocessing the code inflates it and adds lots of indents. Removing some
    of the tricks involved without breaking the program will be challenging.
*   The program 'plays' with standard input & output streams, which causes
    unusual side effects.
*   Some variables are re-used for unrelated processings.
*   Crucial data may be hidden in unexpected places (e.g. as the size of
    a temporary buffer).
*   Some parts of the code may have no effect (but may have an effect in a
    specific context, who knows?), and classical libc functions may not act
    as usual.
*   And of course variable names are hard to read (or distracting).

On the other hand, the following may help:

*   The code layout should help to identify which part of the code is
    obfuscated. ;)
*   File 'codes.txt' shows how each character is drawn. This data is
    encoded in macro O_o at the top of the source file. 


### Limitations

#### Charset

In order to comply with the size rule, I encoded only a part of the visible ASCII
chars:

    a-z, A-Z, '.' ':' ',' ';' '!' and '?'.

Uppercase and lowercase chars are rendered the same.
The program also understand the space and the linefeed (\n).
Other chars are simply ignored (most of the time ;)

#### Stack size

This limitation is due to the heavy use of recursivity. After having processed
a large number of characters, the process may exceed the stack size and crash.
(However I did not experience this myself. The top-level recursion might be
removed by the compiler as part of its optimizations.)

#### Line rendering

The program does its best to avoid cutting words at the end of lines, but
it could still happen in case of long words.

### Subtleties and extra features

#### Handling more than text docs?

Given the limited set of characters handled, the program is mostly limited
to simple text documents. 
Thus, if you try for example:

    $ ./prog < prog.c 

You will not get something that looks like C code. (but you can still try,
if you are curious. :)

#### A 'draft' mode

Defining an environment variable called DRAFT will enable the 'draft-mode'.
Try for example:

    $ echo 'testing the draft mode' | DRAFT=1 ./prog

The program will run much faster but the rendering will be less precise.

#### The subtle interactive mode

I saved the best for last: usually, programs that handle an "interactive
mode" have to check whether their standard input is a terminal or not (by
using isatty()). Did you notice that this program does not perform any such
detection, but still behaves (or seems to behave) appropriately?


--------------------------------------------------------------------------------
<!--
(c) Copyright 1984-2016, [Leo Broukhis, Simon Cooper, Landon Curt Noll][judges] - All rights reserved
This work is licensed under a [Creative Commons Attribution-ShareAlike 3.0 Unported License][cc].

[judges]: http://www.ioccc.org/judges.html
[cc]: http://creativecommons.org/licenses/by-sa/3.0/
-->
# Most Compact

Chris Mills  
Twitter: @MisterXopher  


## Judges' comments:
### To use:

    make
    
    ./prog compressed_file.Z

### Try:

    printf '000I\236\f\31H\260\240\301\203' > ioccc.Z
    ./prog ioccc.Z 

    dd bs=1k count=4096 < /dev/urandom > test1
    compress < test1 > test1.Z
    time ./prog test1.Z | cmp - test1

    dd bs=1k count=4096 < /dev/zero > test2
    compress < test2 > test2.Z
    time ./prog test2.Z | cmp - test2

### Selected Judges Remarks:

Without ASCII art, the source code of this entry would have been exactly 256 bytes.
Compared to [1990/jaw](http://ioccc.org/years.html#1990_jaw), it is very impressive,
even taking into account the missing atob functionality. Now we wish for a compress(1)-like compressor
using a similar idea.

Why is the sad smiley on line 12 in that particular place?

## Author's comments:
The Program
===========

This program is in implementation of the unix `zcat(1)` command for printing
compressed files that have been created by the `compress(1)` command.

The adaptive [LZW](https://en.wikipedia.org/wiki/LempelZivWelch) compression
employed by `compress` usually requires a fairly large amount of memory to
build the decompression tables (in fact, `compress` has a command-line option
to control the size of the decompression tables, since some of the early
systems to which it was ported (*cough*MS-DOS*cough*) did not have enough
memory to use the full 16-bit codes).  This version has no large static or
dynamic tables.  It is able to decompress 16-bit files using a single function
and a few ints.

To run the program, take an existing compressed file and pass it to the program
on the command line.  On the odd chance you don't have `compress` hanging about
on your system, I've provided compressed copies of this year's IOCCC rules
and guidelines files.  To print them, just do

    ./prog ioccc_guidelines.txt.Z

The Details
-----------

The basic cleverness here comes from realizing that the compressed data is
itself an encoded version of the code dictionary.  When the encoder sees
an input string that is not in its dictionary, it emits the code corresponding
to the longest prefix that is in the dictionary and adds a new entry consisting
of that code followed by the next input character.  This means that when the
decoder wants to know how to decode a code, it just needs to find the spot in
the code-stream where the encoder added that entry to the dictionary.  The
code at that spot is the prefix, and the first character of the following code
is the suffix.  Decoding then just becomes recursion, to follow the chain of
prefixes and suffix characters.

Of course, it's not nearly that simple.  Finding the code in the stream is
complicated by several issues:

 * Codes are at bit offsets within the stream, and must be extracted.
 * As codes are added to the dictionary, the code word size grows, so finding
   the offset to a particular code word is involved.
 * The `compress` encoder reserves a code word that clears the coding tables.
   When this is encountered, the computation of offsets and bit sizes reset.
 * The `compress` decoder is designed to always read a block of eight code
   words at the same time, so that it need only read N bytes to get eight N-bit
   code words.  When the "clear" code is encountered, the entire eight-word
   block is flushed (since the decoder didn't know the word size would change).
   The program needs to account for this extra flushing.
 * The end of the stream is not explicitly marked; the encoder just pads out
   the output to the next byte.  The decoder must notice this to know when
   to stop.
 * The output stream contains a header that must be skipped.

Managing all the details involved added a lovely additional layer of
obfuscation to the otherwise elegant recursive decoder.  Still, the code
manages it in a remarkably small amount of code.

Limitations
-----------

The decoder doesn't look at the header.  If you supply something that is not
compressed data, it's likely to crash in an interesting manner.

In particular, it doesn't look at the third byte of the header, which encodes
the maximum code word size and whether "block mode" was used when the encoder
was run.  If you use `compress` in its default mode, the maximum word size
will be 16 bits and "block mode" will be enabled.  You are unlikely to find
any files that don't use "block mode", since all versions of `compress` after
2.0 (circa 1984) use it by default and have no documented way to disable it.
Reducing the bit depth is still possibly by using the `-b` flag.  Modern
systems have no problem with the 200 KB or so needed for 16-bit decoder
tables, so the need for reducing the table size has passed, hence this program
always assumes 16-bits...  However, should you find a file that needs a
smaller table, feel free to change the hard-coded 16 in the source into the
appropriate number and recompile.

In the event that you don't supply an argument, or that argument doesn't name
a readable file, the program will just silently exit.  This is a feature.

The program depends on having a little-endian system.  On a big-endian system
you will get a wierd big-endian version of `compress`, which might have come to
pass in an alternate universe where the vax on which `compress` was authored
had been big-endian.  Luckily for us, it wasn't, and neither are most of the
systems you might want to compile this for.


--------------------------------------------------------------------------------
<!--
(c) Copyright 1984-2016, [Leo Broukhis, Simon Cooper, Landon Curt Noll][judges] - All rights reserved
This work is licensed under a [Creative Commons Attribution-ShareAlike 3.0 Unported License][cc].

[judges]: http://www.ioccc.org/judges.html
[cc]: http://creativecommons.org/licenses/by-sa/3.0/
-->
# Most Useful

Dave Burton <ioccc@snox.net>  
<http://snox.net/ioccc>  


## Judges' comments:
### To use:

    make
    
    ./prog "expression"

or

    ./prog
    (input expressions)
       
### Try:

    ./prog '?0x3343<<2'

    echo '?0x3343<<2' | ./prog

    ./prog

    Enter:

	a=0xfeedface
	b=0xcafe
	a << 16 + b

    grep '[0-9]' prog.c

    ./prog < test.in

    less calc.man

### Selected Judges Remarks:

"Look, Ma, no ~~hands~~ digits!"

The place where some arithmetic operations are done, for example,
division or modulo, are easy to find. Where are addition and subtraction?

We were impressed with the level of detail the author "blogged" the obfuscation process.



## Author's comments:
calc - an integer expression calculator that outputs in both hex and decimal
----------------------------------------------------------------------------

All useful tools should include sufficient documentation.
See the included man page. ;-)

Notes
-----

This program is named calc.  Onomatopoeia of sorts, in the visual realm.
The formatting was easier: Form Follows Function (although [Hou][1] did this better).
It was tempting to call it iCalc, with i for integer (and it was written on an iDevice),
but sanity prevailed.

Printed in 8 pt Courier, it makes aesthetically pleasing 8.5 x 11 wall art.

[1]: http://www.ioccc.org/2011/hou/hint.html "Hou Qiming"

prog.c vs prog.orig.c
---------------------

Dominik Muth observed a syntax error on `1+1`, `1-1`, `1|1`, and `1^1` when using an
ARM based computer, although `1*1` and others worked correctly.
This occurs because some platforms by default treat `char` as `unsigned char`.
The original code has this weakness, which can be corrected by adding `-fsigned-char`
to the compile line.
The modified code is agnostic to `char` signed-ness.

Why is this entry obfuscated/interesting?
-----------------------------------------

Yes, this is another calculator program.

However, unlike any other calculator source code the author is aware of,
this one contains no digits.  At all.  Anywhere.  As in

	grep '[0-9]' prog.c || echo no digits!

Nor are the digits simply obfuscated.  There are no character constants.
There is only one single, short string, and it does not contain any obfuscated digits.
And yet the output is in decimal and hexadecimal, and it accepts octal, decimal, and hex input.

Flow control is by `for` and `return`.  It is If-less.  Switch-less.  While-less.  Hope-less.   
Literally, if not figuratively. ;-)

The code size is intentionally 2015, as stated by iocccsize -i,
and can be reformatted without changes (as in rule2.c) to exactly 4096 octets.

Finally, calc is interesting, if for no other reason than it is practically useful:
Hex/decimal conversion, arithmetic, byte-swapping, bit-shifting, and logical operations with memory,
on the command line, or interactively.

But the question is why is the entry obfuscated?
------------------------------------------------

The code follows many industry best-practices:

- You know what it does just by looking at it.

- Numbers and digits have often been used for obfuscation,
  so in a bid for better clarity, this code has no digits at all.

- In the spirit of clarity, most of the variables are declared before use, so they
  are readily visible, with single letter names that don't clutter the screen,
  in a tautological arrangement.

- More helpful is the use of `typedef`s instead of `#define`, so the types remain useful
  even in the debugger, and source code beautifiers will not undo careful presentation.

- `#defines` are used here in the best spirit of the preprocessor: to shorten
  repetitive constructs, not for obscurity.

- All functions are short (and therefore easy to understand?) and do only one thing, well, ....

- Curly braces invite endless holy wars over readability.  This code only uses them
  for function definitions, thereby greatly improving readability, and reducing arguments
  about said readability.

- One of C's many blessings (until recently) is a modicum of keywords,
  of which only 8 are used:
  `for`, `return`, `typedef`, `void`, `char`, `short`, `unsigned` and `long`;
  10 if `#include` and `#define` are counted.

- The code helpfully declares "syntax_error!" right up front, filling the reader with confidence.

- In spite of its inherent clarity, the code was presented to both *indent*(1) and
  *clang-format*(1), after running it through the preprocessor, sustaining its better qualities.

- That the code is obfuscated is spelled out two different ways in the source; it helps
  to reformat the code to see the second spelling.

- The author is overly fond of the code that handles input.
  There is no memory allocation, nor pre-allocation of arrays, so where does the
  memory come from?  The multi-base strtol() code is pretty trick.
  No special attempt was made to replace operations with obscure mathematical relations,
  as the (lack of) beauty is in the parsing -- ask not where is the modulus operation,
  but how does it know when to mod -- okay, but where is add and subtract?
  And really, who doesn't enjoy a setjmp() in the argument list?

- Finally, documentation of the source code structure is helpfully provided in rot13 format.
  But isn't it unsportsmanlike to rely upon it?  However, even with this helpful guide,
  things like reading input lines remain as tricky to read as they are to write.

Compiler warnings
-----------------

Calc is C99 compliant, and is ANSI/C90 compliant except for wanting 64-bit `long long`.
Changing the two `long long` typedefs to `long`, and compiling with `gcc -m32`
yields a program that operates on 32-bit values, with wrap-around of shifts mod 32:

	1<<48
	65536	0x00010000

gcc 4.2.1 without arguments compiles cleanly (e.g. cc prog.c -o prog).
This is my workaday compiler.  gcc is also clean with -ansi, and -std=c99.

clang 3.6.0 lives up to its namesake, resounding on non-problems.
To stifle these complaints:
	-Wno-return-type -Wno-parentheses -Wno-empty-body

When invoked with -ansi -pedantic, there are two warnings, which can be ignored:

  * `ISO C90 does not support 'long long'`   

With -Wall -std=c99, both are quite noisy, and all can be ignored:

  * `array subscript has type 'char' [-Wchar-subscripts]`   
  * `value computed is not used [-Wunused-value]`   
  * `operation on 'j' may be undefined [-Wsequence-point]`   

Test Suite
----------

If the program name begins with an "e", it echoes stdin to stdout.
This allows for a convenient test suite:

	ln -s prog eprog
	PATH=. eprog < test.in | diff - test.out

Spoilers
--------

If you do not want to puzzle out how it works, see spoilers.markdown.

--------------------------------------------------------------------------------
<!--
(c) Copyright 1984-2016, [Leo Broukhis, Simon Cooper, Landon Curt Noll][judges] - All rights reserved
This work is licensed under a [Creative Commons Attribution-ShareAlike 3.0 Unported License][cc].

[judges]: http://www.ioccc.org/judges.html
[cc]: http://creativecommons.org/licenses/by-sa/3.0/
-->
# Most Diffused Reaction

Someone Anonymous  
Twitter: @hirekoke  

Yusuke Endoh  
<https://github.com/mame/>  
Twitter: @mametter  


## Judges' comments:
### To use:

    make
    
    <tbd-tool-rubl-perl-python?>

### Try:

    Connect to port http://localhost:10333 with your browser

### Selected Judges Remarks:

How did the leopard get its spots? Why are a zebra's stripes unique?

In case you didn't recognise the portrait of Alan Turing, there are some
pointers to his features like eyes with "stdeye-o" and "<--mouth". Can you
find any other tributes?

## Author's comments:
What does "Alan Turing" remind you of?  Cryptanalysis of the Enigma?  Turing machine?  Turing test?  This program is also based on his work.


### Whirlwind tour

Compile the program as follows:

    $ clang -O3 -std=c99 \
        -Wall -Wextra -pedantic -o prog prog.c \
        -Delta_u="Du*laplacian(u)-u*v*v+F*(1-u)" \
        -Delta_v="Dv*laplacian(v)+u*v*v-v*(F+K)" \
        -DF=0.040 -DK=0.060 -DDu=0.200 -DDv=0.100 \
        -DUV_BACKGROUND=1,0 -DUV_DROP=-0.5,0.5 \
        -DTIMESTEP=1.0 -DSPEED=2 -DRGB=255:128:192

Then, run it under `tcpserver` command in [ucspi-tcp](http://cr.yp.to/ucspi-tcp.html) package, which was created by Daniel J. Bernstein, IOCCC 1989 "Best of Show" winner.

    $ tcpserver -v 127.0.0.1 10333 ./prog ioccc.txt

Finally, open `http://127.0.0.1:10333/` by a modern browser supporting HTML5.  You can use the mouse cursor to place drops into the Petri dish interactively.


### Description

This is a simulator of *reaction-diffusion systems*.

Reaction-diffusion systems, proposed by Alan Turing in [1], are mathematical models in which two chemical substances are transformed into each other (*local chemical reactions*) and spread out (*diffusion*).  Their interactions sometimes form non-trivial patterns, such as spots, spiral, dappling, and labyrinths.

The systems are generally formulated as follows:

    du/dt = F(u, v) + Du * laplacian(u)
    dv/dt = G(u, v) + Dv * laplacian(v)

The functions `F(u, v)` and `G(u, v)` represent reactions of each substance, and the parameters `Du` and `Dv` are diffusion coefficients.  By changing the functions and parameters, you can see a wide range of behaviors.

See [the Wikipedia article of "Reaction-diffusion system"](https://en.wikipedia.org/wiki/Reaction%E2%80%93diffusion_system) in detail.

This program simulates the systems.  The field consists of 128 x 128 cells.  Each cell includes infomration of an amount of the two substances, and interacts with neighbor cells (in terms of von Neumann neighborhood) in each frame.


### Configuration

You can change the model, initial pattern, simulation speed, and color via macro definition.


#### Model: `-Delta_u=<expression> -Delta_v=<expression>`

The definitions represent the equations of reaction-diffusion system.  For example, the following is [the Gray-Scott model](http://groups.csail.mit.edu/mac/projects/amorphous/GrayScott/) in TeX notation.

    \frac{\partial u}{\partial t} = D_u \Delta u - u v^2 + F (1 - u)
    \frac{\partial v}{\partial t} = D_v \Delta v + u v^2 - v (F + K)

You can specify this model as follows:

    -Delta_u="Du*laplacian(u)-u*v*v+F*(1-u)" \
    -Delta_v="Dv*laplacian(v)+u*v*v-v*(F+K)"

`Du`, `Dv`, `F`, and `K` are parameters of that model.

#### Initial pattern: `-DUV_BACKGROUND=<u0>,<v0> -DUV_DROP=<u1>,<v1>`

The definitions specifies the initial amount of the two substances u and v.  All cells have `(u0, v0)` by default.

You can specify a pattern file when the executable is invoked (not compile-time).  The file should include a sequence of points, see `ioccc.txt`, `center.txt`, or `line.txt` as examples.  Each amount in cells near to the point included in the file, will be added by `(u1, v1)`.

#### Simulation speed: `-DTIMESTEP=ts -DSPEED=spd`

The definitions are for changing the simulation speed.

`TIMESTEP` is a simulation time step.  The bigger, the faster but more unstable.

`SPEED` is a frameskip parameter.  The bigger, the faster but more sluggish.

#### Rendering color: `-DRGB=r:g:b`

This specifies a color used for rendering.


### Examples

Some interesting parameters are included in `Makefile`.  Do one of the following command and open `http://127.0.0.1:10333`.

    $ make gray-scott-1 && tcpserver -v 127.0.0.1 10333 ./gray-scott-1 ioccc.txt
    $ make gray-scott-1 && tcpserver -v 127.0.0.1 10333 ./gray-scott-1 center.txt
    $ make gray-scott-1 && tcpserver -v 127.0.0.1 10333 ./gray-scott-1 line.txt
    $ make gray-scott-2 && tcpserver -v 127.0.0.1 10333 ./gray-scott-2 ioccc.txt
    $ make gray-scott-3 && tcpserver -v 127.0.0.1 10333 ./gray-scott-3 ioccc.txt
    $ make gray-scott-4 && tcpserver -v 127.0.0.1 10333 ./gray-scott-4 ioccc.txt
    $ make fitzhugh-nagumo-1 && tcpserver -v 127.0.0.1 10333 ./fitzhugh-nagumo-1 ioccc.txt
    $ make fitzhugh-nagumo-2 && tcpserver -v 127.0.0.1 10333 ./fitzhugh-nagumo-2 ioccc.txt
    $ make oregonator && tcpserver -v 127.0.0.1 10333 ./oregonator ioccc.txt

These examples are created by drawing (and modifying) the pattern files of [Ready](https://github.com/GollyGang/ready), a cross-platform implementation of various reaction-diffusion systems [2].

### Compatibility

#### C part

This program compiles clean with no warnings under `-std=c99 -Wall -Wextra -pedantic`.  Since it uses `long long` for 64bit integers, C99 is required.

#### Browser part

You must use a modern browser that supports the latest specification of WebSocket [3].  All the following browsers worked for me:

* Google Chrome 45
* Mozilla Firefox 39
* Microsoft Internet Explorer 11 (works but sluggish)

I think Safari 6 will work but I haven't tested.  (I have no recent os x.)

#### tcpserver alternatives

I think you may use `inetd` and `xinetd` instead of `tcpserver`.  Here is an example of inetd configuration.

    10333 stream tcp nowait nobody /path/to/prog /path/to/prog /path/to/initial-pattern.txt

But note that I didn't test well.

### Internal

1. The C program accepts HTTP connection from the browser, and sends a HTML document.
2. The browser tries to upgrade the connection to WebSocket.
3. The C program accepts WebSocket upgrade.  This negotiation process requires SHA1 hash [4] and Base64 encoding [5].  The C program calculates them without the aid of any external libraries.
4. The C program simulates the reaction-diffusion system, and then send the field data to the browser on each frame.
4. The browser receives and renders the field data onto the HTML5 canvas.


### References

* [1] Turing, A. M., "The Chemical Basis of Morphogenesis", Philosophical Transactions of the Royal Society, 1952.
* [2] The Ready Bunch, "Ready", A cross-platform implementation of various reaction-diffusion systems, since 2011, <https://github.com/GollyGang/ready>.
* [3] Fette, I. and A. Melnikov, "The WebSocket Protocol", RFC 6455, DOI 10.17487/RFC6455, December 2011, <http://www.rfc-editor.org/info/rfc6455>.
* [4] Eastlake 3rd, D. and P. Jones, "US Secure Hash Algorithm 1 (SHA1)", RFC 3174, DOI 10.17487/RFC3174, September 2001, <http://www.rfc-editor.org/info/rfc3174>.
* [5] Josefsson, S., "The Base16, Base32, and Base64 Data Encodings", RFC 4648, DOI 10.17487/RFC4648, October 2006, <http://www.rfc-editor.org/info/rfc4648>.

--------------------------------------------------------------------------------
<!--
(c) Copyright 1984-2016, [Leo Broukhis, Simon Cooper, Landon Curt Noll][judges] - All rights reserved
This work is licensed under a [Creative Commons Attribution-ShareAlike 3.0 Unported License][cc].

[judges]: http://www.ioccc.org/judges.html
[cc]: http://creativecommons.org/licenses/by-sa/3.0/
-->
# Most Well-rounded Hash

Qiming Hou <hqm03ster@gmail.com>  
<http://www.houqiming.net/>  


## Judges' comments:
### To use:

    make
    
    echo IOCCC | ./prog

### Try:

    echo "" | ./prog

### Selected Judges Remarks:

A good start for understanding this entry might be
https://www.ietf.org/rfc/rfc1321.txt. How does it compute this using only a
single looping construct? The original reference source code for this
algorithm is about 355 lines of code, yet this entry is only 199 lines with
one statement per line and it isn't using lots of macro expansion tricks like
the reference code!

Some things that make you go, "huh?"

	./prog < prog.c | cut -c-5
	./prog < Makefile | cut -c-4

How are those values magically returned?

What happens with a large file? Something over 256K

	./prog < large_file

Where does that message come from?


## Author's comments:
This looks like a normal C program.

Almost everything is a double.

There are tell-tale signs like `pow(2,(?/12))` and `exp(-?*?)` (names redacted). You can also find a bunch of cosines and polynomial evaluations.

It looks like a ????? ???????????, right?

Run and find out.

### Why obfuscated

Some poor scripting folks only have access to doubles (Jav?script, L?a, BA?IC, etc.).

As a C programmer, I feel obliged to show a gesture of sympathy, to experience their pain and provide an answer.

Except when absolutely necessary (`printf`, `int main()`, array indexing), there isn't a single integer. Even `getchar()` and `EOF` are immediately converted.

Since `bool` counts as an integer type too, there is no boolean either. No comparison, no `if`, no `?:`, no `||` `&&`. Everything is done in a single loop that terminates on printf. Straight up arithmetic.

`floor` and `ceil` are technically double-to-double functions, but they feel like cheating. Yes `cos`, no `floor`.

### Limitations

Hard requirements:

* The platform must implement the `double` type as IEEE754-compliant 64-bit floating point numbers.  The 80-bit intermediate format used by x87 is considered as an violation of this. The code should print an error message on such platforms.

* The program must start with the CPU / FPU in round-to-nearest mode.

Soft requirements:

* The compiler must respect `volatile`. The code is formatted to warn about that, though.

* The printed result is only correct on little-endian machines. The program takes care to warn about this issue after printing an incorrect big-endian result. Error messages become garbled, though.

Tested platforms:

* Linux 3.18.7, Rasperberry Pi 2, clang 3.0-6.2, (works)
* Linux 3.18.7, Rasperberry Pi 2, gcc 4.6.3, (works)
* Mac OS X 10, x64, Apple LLVM version 6.1.0 (clang-602.0.53), (works)
* Windows 8.1, x86, MSVC 2012 (works) 
* Windows 8.1, x64, MSVC 2012 (works)
* Windows 8.1, x86, MinGW gcc 4.6.2 (fails, prints error message)
* Windows 8.1, x86, MinGW gcc 4.6.2 with -msse2 -mfpmath=sse (works)

--------------------------------------------------------------------------------
<!--
(c) Copyright 1984-2016, [Leo Broukhis, Simon Cooper, Landon Curt Noll][judges] - All rights reserved
This work is licensed under a [Creative Commons Attribution-ShareAlike 3.0 Unported License][cc].

[judges]: http://www.ioccc.org/judges.html
[cc]: http://creativecommons.org/licenses/by-sa/3.0/
-->
# Most Crafty

Gil Dogon  
<http://sokoban-gild.com>  


## Judges' comments:
### To use:

    make

    ./prog

### Try:

    ./prog

    press and hold the Left Arrow key until you turn 90-degrees to the left

    when you see a long tunnel, press the function key F2

    Use the Up, Down, Left and Right keys to change your path

    Press function higher numbered function keys (F3, F4, ...) to go faster

    Press F1 to stop

    Turn 90-degrees to one side

    Press F4 to and drill into some blocks for a bit

    Press F1 to stop

    Turn 180-degrees to face the way you came

    Press F2 and navigate back down the new hole until you reach the long tunnel again

    Press F1 to stop

    etc.

    Press the ESC key

### Selected Judges Remarks:

You are in a twisty maze blocks, almost all alike.

Those blocks are generated by  twisty maze of code blocks, almost all different.

Can you find your way around either and understand where you are?

How many function keys does your keyboard have?  Can you generate very high number function keys such as F30 or F31?  :-)

*Textures? We don't need no stinking textures.*

## Author's comments:
### What is it?

Just run prog with no arguments on an X11-compatible system. The scenery, though pseudo-randomly generated should be strangely familiar, specially to those still in their teen age. You can navigate using the keyboard arrow keys and the function keys. Your speed is a linear function of (n-1) where Fn is the last function key you have pressed, and you always move in the direction you are looking at. Be aware that you are probably some kind of a Creeper as is obvious from looking at the program, hence your movement is destructive to the environment. So after pressing F12 for warp speed, and moving around randomly, you might find yourself in a 3D maze of twisty little passages, from which there is only one Esc(ape) key. Note that in theory if you have a specialty keyboard with 32 function keys you may even press F31 to reach infinite improbability drive speed, though the author had never tested this feature. However a hidden comment in keysymdef.h suggests the existence of a mythical Sun Keyboard with 35 function keys :)

### Full disclosure.
This entry, tough pretty thoroughly obfuscated, is not entirely original, nor am I Notch. The inspiration for this entry is a demo code written by the Notch himself, which was released with the following  license: "you may use the code in here for any purpose in any way you want, at your own risk". That version will henceforth be referred to as the original. Though the original in itself was quite nice and rather dense piece of code, it was not written in C, nor entirely and meticulously obfuscated, a state of things I hopefully rectified.

### Some extra features.

Basing it on the original which already had a wonderful simple and concise ray casting through a generated voxel world rendering, I added a few tweaks of my own device:

* Two pass optimized rendering. The program first calculates 1/16 of the output image by ray casting, and then, when possible uses texture interpolation on the voxel faces. It speeds up the rendering by at least a factor of 4 on most scenes, but extra care must be taken when passing rays through the leaves voxels ...
* Fixed a small omission in the original. When you looked though a transparent leaves voxel, you did not see the leaves at voxel faces that were far from you. In this version the rendering of those (far face leaves) is correct.
* Window rendering size specified in Makefile.
* Added the keyboard controls for navigation (and destruction).

### Portability issues.

This entry is rather portable I think on modern platforms. It assumes of course basic X-windows availability. There are several other salient assumptions though:

* The entry assumes sizeof(int)=4. This seems to cover pretty much everything that supports X-windows so would be broken only on quite ancient machines, embedded processors, or some big iron 64 bit system where sizeof(int)=8.
* The entry assumes the default visual has 24 bit depth (RGB). This seems to be the case on most X Servers this days.
* The entry, does a thing which is an absolute No-No for X-windows program, i.e. assuming it knows some numeric values for keysyms defined in keysymdef.h . I have searched far and wide the lord Google's domain, yet was unable to find a version of the file where those assumptions were broken. This enables the important support of up to 32 function keys keyboards without spilling over the size limit, and allows us to use such fun expression for arrow view control as the following:

       *(a&1?&C:&B)-=(.05 -a/2%2*.1)*!(a-1&4092^3920)


### Precision issues.

The entry, on purpose, (see the section about SIMD below) does not use enough bits of precision, so some times the ray will miss the intersection of two voxel faces and push on through. That's why you may notice some noise along close up voxel edges. Fixing this issue would have taken the entry over the size limit regrettably.

### Obfuscations.

Well, of course you have all the usual suspects, used for extreme compression, and such a nice layout: not very informative identifiers, which are being reused all over the place, some rather gruesome looking expressions, a whole load of magic constants with apparently no rhyme nor reason (including a Lagrange polynomial), and a message from our friendly Cetaceans. However it also includes some clever and not so obvious though instructive techniques, to subtly make the code more magical and efficient, at the same time.

Those techniques are about the use of 64 bit integers in order to do SIMD work, in a portable way without ever using any SSE/AVX or other non-portable compiler inline functions! The irony though, is that when compiling the program on modern X86 architectures indeed SSE/AVX is used for the long longs.
Following is some "Spoiler" information, So if you want to play tough, stop reading at this point.

### Portable SIMD programming.

So how is this done? Quite simply by using the whole long long arithmetic's capability. I think the C99 standard assures us that long long has at least 64 bits. Most of those bits are unused in normal programs, however here we use them more wisely. For example, in the inner loop of the program you have the innocent looking expression i+=d. What it does in fact, is a SIMD addition of two vectors, each with three signed fixed point coordinates, advancing our ray in 3D space! 
To spell it out, the macro producing such vectors is P, and the assignment q=0x820008202625a0 sets our creeper original position to about (32.5, 32.5019, 2441.406) . 

Evidently when doing such arithmetics, care must me taken to avoid overflow from one component to the other, but since our voxel world is a torus of size 64 in each dimension this hardly matters. A subtle issue, is how to deal with signed quantities. In the i+=d expression above i has 3 positive components, but d has arbitrary signed components, as our ray may face in any direction. It seems things should not work, specially as we defined both i and d as unsigned! However notice that the T (and P )macro converts float to  signed long longs. Once sign is extended from a least component into higher bits, it seems at first to be recipe for disaster, however everything works beautifully, and you get precise component results when the final accumulation components in i are positive. This only gets broken a bit when the final accumulation has a least significant negative component. To see this bug in action change the assignment above to q=0x82000820000000, and look towards the negative direction of the main tunnel.

Similar technique is used on the RGB components so their brightness can be adjusted simultaneously by the expression: o=o*b>>8 . Of course some spare bits are needed between the components, so they are spread in the long long and reordered as RBG.

--------------------------------------------------------------------------------
<!--
(c) Copyright 1984-2016, [Leo Broukhis, Simon Cooper, Landon Curt Noll][judges] - All rights reserved
This work is licensed under a [Creative Commons Attribution-ShareAlike 3.0 Unported License][cc].

[judges]: http://www.ioccc.org/judges.html
[cc]: http://creativecommons.org/licenses/by-sa/3.0/
-->
# Most Complete Use of CPP

Dominik Muth <muth.ioccc@freenet.de>  


## Judges' comments:
### To use:

    make -B [MACHINE=your_machine.h] [TAPE=your_tape.h] [X=[0|1|2|3|4|5|6|7|8|9]] [V=[0|1|2]] run

### Try:

    make -B V=2 run

    strings prog | grep '(,)'

    make -B MACHINE=machine_times2.h TAPE=tape_five.h V=1 run

    make -B MACHINE=machine_chaos_5_2.h X=5 run

### Selected Judges Remarks:

This is something we were fearing all along: that the C preprocessor is Turing-complete
even without conditionals and recursive file inclusion as some kind of a
[rewriting system](https://en.wikipedia.org/wiki/Rewriting). Now we have the proof!

## Author's comments:
### Preprocessor Turing Engine

#### Features

- Turing machine runs in preprocessor
- universal (unlimited configurable states, symbols, and tape)
- no `#if`s or other conditional directives, only `#define`s
- no recursive `#include`
- single compiler run (no repeated preprocessing)
- no variadic macros
- verbosity levels:
  + `V=0` (default) only prints the final tape
  + `V=1` additionally prints one tilde character per machine step (slow)
  + `V=2` additionally prints details on each machine step (slow; generates large files)
- make target `run` runs `./prog` and filters a little statistics out of the verbose output
- `X` (defaults to 3) sets the maximum number of steps: *M*(`X`) ~ 8<sup>`X`</sup>

#### Limitations

If the machine does not halt after *M*(`X`) steps, you will see unexpanded macros in the output.

#### Compiler warnings

If `V=1` or `V=2` is used, you may see "`warning: string length is greater than the length '4095' ISO C99 compilers are required to support`".

#### Programming

Implementing your own Turing machine is easy. Take a look at the supplied header files for examples.

##### Tape Symbols

Every symbol used (except "`_`") must be explicitly declared using

	#define sym_SYMBOL(sym, _SYMBOL) sym

Example:

    #define sym_1(sym, _1) sym

##### Tape

The initial content of the tape must be defined in the tape header using a triple like:

	#define tape ((((,),...l2), l1), c, (r1, (r2..., (,))))

- `l1`, `l2`, ... are the symbols to the left
- `c` is the symbol at the current position
- `r1`, `r2`, ... are the symbols to the right

The empty pairs "`(,)`" represent the continuations of the tape, filled with underscore symbols ("`_`"). They are expanded on demand.

##### State Machine

All transitions are defined in the machine header using the syntax

	#define CURRENT_SCANNED (WRITE, MOVEMENT, NEXT)

where

- `CURRENT` is the current state
- `SCANNED` is the symbol at the current position
- the whitespace before the parentheses is significant
- `WRITE` is the symbol to be written to the tape
- `MOVEMENT` is "`L`" for left, "`R`" for right, or nothing
- `NEXT` is the next state

There must be a state "`A`" defined, which becomes the initial state of the machine.

To halt the machine, use the keyword "`break`" as in

	#define A_1 (2, break)

--------------------------------------------------------------------------------
<!--
(c) Copyright 1984-2016, [Leo Broukhis, Simon Cooper, Landon Curt Noll][judges] - All rights reserved
This work is licensed under a [Creative Commons Attribution-ShareAlike 3.0 Unported License][cc].

[judges]: http://www.ioccc.org/judges.html
[cc]: http://creativecommons.org/licenses/by-sa/3.0/
-->
# Best Documented

Jens Schweikhardt  
<http://www.schweikhardt.net>  


## Judges' comments:
### To use:

    make

    ./prog n

    where n is a base 16 number of any size

### Try:

    ./prog 19


### Selected Judges Remarks:

This code is clean.  When you compile with all warnings enabled,
such as with clang:

   cc -Weverything -pedantic -std=c11 -Dtyp=uint64\_t -O3 prog.c -o prog

The code compiles without warnings on the systems that we tested!

Even more, the code was 100% clean when we ran it against various
static source checkers.

This tool references a problem that David I. Bell once described
as having one of the largest "yummo quotients" in number theory:

                         complexity of the solution
    yummo quotient = -----------------------------------
                     complexity of the problem statement

Erds privately told one of the IOCCC judges:

"Solving the [Generalized Riemann hypothesis](https://en.wikipedia.org/wiki/Generalized_Riemann_hypothesis#Extended_Riemann_hypothesis_.28ERH.29)
would be a good warmup exercise for someone to get ready
to begin to work on the [Collatz conjecture](https://en.wikipedia.org/wiki/Collatz_conjecture)."

You may explore this famous conjecture using this entry:

    ./prog 2410
    ./prog abfff
    ./prog 27f8cebf
    ./prog 246f8fddf
    ./prog 2e95ab51ffea9de
    ./prog e6a5c22fd7bde9f
    ./prog 1b7dd73a937485bf
    ./prog 7d3237680d190a77e53751b
    ./prog 302ab3d052fb87c06228d249581be0e4

When you first look at the source, the code looks fairly straightforward.
But look again.  Like the Collatz conjecture, simplicity is deceptive!
Oh, and the variable names?  They are not simple single letter variables,
they are names of various [Proteinogenic amino
acid](https://en.wikipedia.org/wiki/Proteinogenic_amino_acid):
which is yet another simple building block that can be used to
build some very complex structures.  :-)

p.s. We appreciated that apart from a few powers of 2, the source
code is magic number free.

## Author's comments:
The TL;DR version
-----------------

This is the cleanest program ever submitted. If for some input it enters
a non-terminating loop or runs out of memory you will be insta-famous.
It's a bit like a lottery without the need to buy a ticket and you can
play as often as you like. One notable historic person has even offered
some prize money.

The program illustrates the bloat caused by adherence to too many rules,
each of which may sound sane in isolation, but in their entirety lead to
an obfuscated, hard to read and understand monster.

What this program does.
-----------------------

The program tests whether a given natural number satisfies the
[Collatz Conjecture](https://en.wikipedia.org/wiki/Collatz_conjecture):

Take any natural number *n*. If *n* is even, divide it by 2 to get *n*/2.
If *n* is odd, multiply it by 3 and add 1 to obtain 3*n* + 1.
Repeat the process indefinitely.
The conjecture is that no matter what number you start with,
you eventually reach 1.

Paul Erds said about the Collatz conjecture:
"Mathematics may not be ready for such problems."
He also offered $500 for its solution.

For example, the sequence of numbers for *n* = 6 is

>    6, 3, 10, 5, 16, 8, 4, 2, 1.

Continuing past one leads to the *cycle* 1, 4, 2, 1, 4, 2, 1, ...
Interesting factoid: if you allow *negative* start values, there are
a few more cycles, each of different length:

>   1, 2, 1
>
>   5, 14, 7, 20, 10, 5
>
>   17, 50, 25, 74, 37, 110, 55, 164, 82, 41, 122, 61, 182, 91, 272, 136, 68, 34, 17

The program computes the sequence for a given positive natural number
and stops at 1. The number *n* is specified in hexadecimal (without 0x
prefix) as the first argument. The program prints the given number in
zero-padded hex and each iteration along with a line count in decimal.
The example above looks like this (compiled with 64 bit word size):

    $ ./prog 6
    0000000000000006
    0000000000000003 1
    000000000000000A 2
    0000000000000005 3
    0000000000000010 4
    0000000000000008 5
    0000000000000004 6
    0000000000000002 7
    0000000000000001 8

The size of *n* is only limited by the argument size limit of your
shell/OS (the program implements arbitrary size bignums).
To query this on your POSIX system, run

    $ getconf ARG_MAX
    262144

which reports the limit in bytes, here 256KB. This allows to test
whether a [Googol](https://en.wikipedia.org/wiki/Googol), which is
10<sup>100</sup>, satisfies the conjecture. But what is a googol in hex?
Fear not,
[bc(1)](http://pubs.opengroup.org/onlinepubs/9699919799/utilities/bc.html)
to the rescue:

    $ printf 'obase=16;10^100\n' | bc
    1249AD2594C37CEB0B2784C4CE0BF38ACE408E211A7CAAB24308A82E8F1000000000\
    0000000000000000
    $ ./prog 1249AD2594C37CEB0B2784C4CE0BF38ACE408E211A7CAAB24308A82E8F10000000000000000000000000 \
    | less
    [...]

Observe how the first 100 iterations melt the zeros to the right. Can you explain
why?

For a given *n* the program behavior is one of the following 3:

1. The sequence stops at 1. No fame. No money. Thanks for playing. Computational
   mathematicians have tested all *n* < 4FFDD776055A0000 (~10<sup>18</sup>)
   so don't try anything less than that.
2. The chosen *n* leads to a sequence with ever bigger numbers,
   so that eventually the bignum cannot be stored in memory. If this happens,
   the program outputs `laugh` (more likely) or `throw up` (less likely) and
   stops. You *might* have found
   a number for which the sequence *diverges*. If confirmed, this disproves the
   conjecture.
3. The chosen *n* leads to a cycle not including 1 (i.e. runs forever,
   repeating the same sequence over and over). You have disproved the
   conjecture and should certainly submit a paper to the nearest
   mathematical journal.


Design objectives
-----------------

I gave myself the following objectives. Like in real world programming,
not all of them can be met 100%. Think of them as a multidimensional
continuum, where trade-offs have to be made.

1. No arbitrary limits on the input number. 64 bits might be enough
   for everybody, but is not enough for exploring new Collatz-territory.
   Thus bignums are required.
2. Ultra-portable. Must run on C89 systems and self-adapt to C99 and C11
   features like exact width types.
3. Super-efficient. Must be able to run with the widest type as the
   base of the bignums. Make the user select the widest type supported
   by the implementation and then crunch away. If a non-standard
   128bit type is available, it should be usable.
4. Pentagon level lint cleanliness and MISRA compliance.
5. Easy to understand, self-documenting clear code. A joy for maintenance
   programmers. The epitome of best practice demonstration for all
   future textbooks on C.

Program Obfuscation
===================

In the following I address all the *tests* as specified by your honors in the
*guidelines*.

 * look at the original source
 * convert ANSI tri-graphs to ASCII
 * C pre-process the source ignoring `#include` lines
 * C pre-process the source ignoring `#define` and `#include` lines
 * run it through a C beautifier
 * examine the algorithm
 * compile it (with flags to enable all warnings)
 * execute it

Look at the original source
---------------------------

Using one letter identifiers is quite old. I decided to use TLI (three
letter identifiers). Not the random kind, rather with a connection to
the meaning of life, the universe and the rest. Enter amino acids! Among
the myriad of possible amino acids there are 23 from which proteins are
built. In biochemistry, each is assigned a TLI (see [Proteinogenic amino
acid](https://en.wikipedia.org/wiki/Proteinogenic_amino_acid)):

	ala	Alanine
	cys	Cysteine
	asp	Aspartic acid
	glu	Glutamic acid
	phe	Phenylalanine
	gly	Glycine
	his	Histidine
	ile	Isoleucine
	lys	Lysine
	leu	Leucine
	met	Methionine
	asn	Asparagine
	pyl	Pyrrolysine
	pro	Proline
	gln	Glutamine
	arg	Arginine
	ser	Serine
	thr	Threonine
	sec	Selenocysteine
	val	Valine
	trp	Tryptophan
	tyr	Tyrosine
	asx	Asparagine or Aspartic acid
	glx	Glutamic acid or Glutamine
	xle	Leucine or Isoleucine
    unk Unknown

My own research results complete this list (not yet in Wikipedia due to
the rule "[No original
research](https://en.wikipedia.org/wiki/Wikipedia:No_original_research)"):

	and	Androgynine
	xor	Xenoricine
	not	Notanamine
	tla	Triletramine

Interestingly, the TLI are the perfect mnemonics for C language source.
For example, `met` is "Main's Exit Type" (`int`), `ala` is "A Large
Algebraic" (bignum), `ile` an "Incremented Local Entity" (index
counter), `gly` means "Grow Larger memorY", `gln` is "Grown Larger Now"
(after realloc), `not` is a "Not Overflowing Type" (recursive!), `unk`
is the "UNit (Known as 1)", `trp` is the "Tabula Rasa Product" (zero),
`phe` is "Print HEx" and so on.

Convert ANSI tri-graphs to ASCII
--------------------------------

Huh??!

C pre-process the source ignoring '#include' lines
--------------------------------------------------

Wow, an identity operation (except for the `<stdint.h>` and `EOF + __STDC__`
trivialities). Did you gain any insight through this?

C pre-process the source ignoring '#define' and '#include' lines
----------------------------------------------------------------

`#define`? Which `#define` directives? How many 4K source files do you
see that neither use a single `#define` directive *nor* abuse the build
file? Even though the "no `#define`" rule I submitted myself to made it
hard, I could use `__LINE__` and stdio macros `EOF`, `L_tmpnam`,
`BUFSIZ`, `FILENAME_MAX`, `TMP_MAX` to obfuscate at least something.

Run it through a C beautifier
-----------------------------

Another identity operation. I've done it for you already. Use this
`.indent.pro` with FreeBSD indent:

	$ cat .indent.pro
    -bad   /* blank line after decls */
    -bap   /* blank line after functions */
    -br    /* braces on if line */
    -i8    /* indent */
    -l999  /* line length */
    -npcs  /* no space after function call names */
    -npsl  /* don't break procedure type */
    -ut    /* use tabs */
    -ce    /* cuddle else */
    -nip   /* no parameter indentation */
    -di1   /* declaration indent */
    -Tand
    -Tmet
    -Tthr
    -Tpro
    -Tser
    -Tala

It looks like a perfect program should:

  *  two and a half `#includes` of unsuspicious standard headers
  *  followed by self protection against goofy implementations
  *  followed by a handful of `typedef`s
  *  and a pair of file scope objects by necessity
  *  prototypes! With parameter names! `static` for internal linkage even! This __must__ be a first in IOCCC history.
  *  function definitions, `main` last
  *  everything is fully const-poisoned: automatics, statics, arguments, even `main`
  *  everything is fully curly braced, even single statements
  *  plenty of meaningful TLC (Three Letter Comments)

The program contains not a single *magic number* (only 0 and powers of
2, each power from 1 to 512) which are obvious to competent software
engineers). How many programs have *that* property? The check for
`__STDC_VERSION__` was a bit tough to arrive at, since 199901L has too
many bits set. But I realized that I only needed a number larger than
199409 and less than 199901. 199680 has only 4 bits set and writing it
as (256 + 128 + 4 + 2) * 512 minimizes the character count. That's what
judges get when they don't like programs that are longer than they need
to be.

Examine the algorithm
---------------------

Spoilers ahead. Duh!

Pseudocode, with comments matching those in the C source:

    /* run */
    if (non-NULL and nonempty argv[1]) {
       n = convert(argv[1])
       print n                       /* 2hx */
       while (n != 1) {              /* one */
          if (n is odd) {            /* odd */
             m = deep copy of n      /* cpy */
             n <<= 1                 /* shl */
             n += m                  /* add */
             increment n             /* inc */
          } else {                   /* eve */
             n >>= 1                 /* shr */
          }
          print n                    /* 2hx */
      }
    }

Bignums are represented as the two member structs

    typedef struct {
         size_t places;   /* number of places in base 2<sup>8*sizeof(type)</sup> */
         type  *number;   /* dynamically allocated memory for number */
    } bignum

Compile it (with flags to enable all warnings)
----------------------------------------------

Here's where the program shines brighter than a [gamma-ray
burst](https://en.wikipedia.org/wiki/Gamma-ray_burst)!

I challenge you to throw all kinds of compilers, lints, checkers and
analyzers at my program and make it find the slightest of issues.

Is `clang -Wall -Wextra -Weverything -Dtyp=uint32_t prog.c` all you can
do? Clang has implemented a new warning? Bring it on!


Execute it
----------

May you win the jackpot!

For least surprising results, the execution character set should be
ASCII. The program computes four bits from every character in `argv[1]` and
interprets them as a hex digit. On ASCII the characters a-f, A-F and 0-9
are converted as expected.

This means however, that the program accepts __any string__, turns it
into a starting number (which is output as the first line), and starts
crunching. Nothing stops you from executing

    $ ./prog "$(cat prog.c)"            # Kind of quine?
    $ ./prog "$(cat rules guidelines)"  # A jackpot? Maybe next year...
    $ ./prog "$(cat /bin/ls)"           # Number cut short at first NUL byte.

In a certain way, the program is character set and encoding agnostic.

Assumptions made
----------------

* The `EOF` macro from `<stdio.h>` must expand to negative one since it is used
  to decrement a pointer and do some other math.
  None of the tools catches this one. The program self-protects against unusual
  systems with `#if EOF + __STDC__` followed by `#error goofy!`. In the rare event
  your system is goofy, replace all `EOF` tokens with `(-1)` and remove the
  `#error` directive.


While the program works best when bytes/characters are octets and the
number of bits in a type is `sizeof(typ) << 3`, it will work correctly
on 24bit or 36bit systems with 9 bits/byte, or systems where
`sizeof(typ)` is 1 even for `int` and so on. On such systems, it will only
use 8 * `sizeof(typ)` bits per place. It does not work when `CHAR_BIT <= 7`.


Results of various checkers
---------------------------

### cppcheck

The open source static checker [cppcheck](http://cppcheck.sourceforge.net/)
checks various problems with respect to style, performance, portability
and general fishiness. To enable all checks, run

    $ cppcheck --enable=all --force -I/usr/include -Dtyp=uint32_t prog.c

No issues found.

### flawfinder

The open source static checker [flawfinder](http://www.dwheeler.com/flawfinder/)
checks various problems with respect to security like buffer overflows,
function arguments to known troublemaker functions and more. It doesn't need to
pre-process code, so can be run without the `typ` macro being defined:

    $ flawfinder prog.c
    Flawfinder version 1.31, (C) 2001-2014 David A. Wheeler.
    Number of rules (primarily dangerous function names) in C/C++ ruleset: 169
    Examining prog.c
    FINAL RESULTS:
    ANALYSIS SUMMARY:
    No hits found.
    $

### valgrind

The open source dynamic checker [valgrind](http://valgrind.org/)
runs an executable and verifies all memory accesses and (de)allocations for
proper bounds and memory leaks.
Since the program frees all memory in all possible execution paths, even when
it must bail out,
valgrind should be happy. An early version of my program however reported this:

    $ valgrind --leak-check=full --show-leak-kinds=all ./prog 6
    [...]
    ==14615== HEAP SUMMARY:
    ==14615==     in use at exit: 4,096 bytes in 1 blocks
    ==14615==   total heap usage: 4 allocs, 3 frees, 4,108 bytes allocated
    ==14615==
    ==14615== 4,096 bytes in 1 blocks are still reachable in loss record 1 of 1
    ==14615==    at 0x4C236C0: malloc (in /usr/local/lib/valgrind/vgpreload_memcheck-amd64-freebsd.so)
    ==14615==    by 0x4F62175: ??? (in /lib/libc.so.7)
    ==14615==    by 0x4F62073: ??? (in /lib/libc.so.7)
    ==14615==    by 0x4F514EE: ??? (in /lib/libc.so.7)
    ==14615==    by 0x4F51265: vfprintf_l (in /lib/libc.so.7)
    ==14615==    by 0x4F3E001: printf (in /lib/libc.so.7)
    ==14615==    by 0x40101E: phe (in ./prog)
    ==14615==    by 0x400A9F: main (in ./prog)
    ==14615==
    ==14615== LEAK SUMMARY:
    ==14615==    definitely lost: 0 bytes in 0 blocks
    ==14615==    indirectly lost: 0 bytes in 0 blocks
    ==14615==      possibly lost: 0 bytes in 0 blocks
    ==14615==    still reachable: 4,096 bytes in 1 blocks
    ==14615==         suppressed: 0 bytes in 0 blocks
    ==14615==
    ==14615== For counts of detected and suppressed errors, rerun with: -v
    ==14615== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)

From which I concluded that `printf` allocated a single 4K block for
which no matching free existed. But how to free memory allocated deep
down in the guts of the Standard I/O library? After some serious head
scratching it hit me. The only chance I have is telling the system I no
longer want to do I/O, maybe then it would free that buffer. A reading
of C99 7.19.5.1, "The fclose function", was encouraging:

>  Whether or not the call succeeds, the stream is disassociated from the file
>  and any buffer set by the `setbuf` or `setvbuf` function is disassociated from the stream
>  (and deallocated if it was automatically allocated).

So I `fclose(stdout)` before returning and now:

    $ valgrind --leak-check=full --show-leak-kinds=all ./prog 6
    ==14571== Memcheck, a memory error detector
    ==14571== Copyright (C) 2002-2013, and GNU GPL'd, by Julian Seward et al.
    ==14571== Using Valgrind-3.10.0 and LibVEX; rerun with -h for copyright info
    ==14571== Command: ./prog 6
    ==14571==
    0000000000000006
    0000000000000003 1
    000000000000000A 2
    0000000000000005 3
    0000000000000010 4
    0000000000000008 5
    0000000000000004 6
    0000000000000002 7
    0000000000000001 8
    ==14571==
    ==14571== HEAP SUMMARY:
    ==14571==     in use at exit: 0 bytes in 0 blocks
    ==14571==   total heap usage: 4 allocs, 4 frees, 4,120 bytes allocated
    ==14571==
    ==14571== All heap blocks were freed -- no leaks are possible
    ==14571==
    ==14571== For counts of detected and suppressed errors, rerun with: -v
    ==14571== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)

A squeaky clean valgrind result!

### FlexeLint

FlexeLint is a commercial lint tool by [Gimpel
Software](http://www.gimpel.com/html/index.htm). It supports nearly a
thousand checks, broadly categorized into 4 levels,

  1.  Syntax errors only (messages 1 to 399)
  2.  Warnings (messages 400 to 699)
  3.  Informational messages (700 to 899)
  4.  Elective notes (900 to 1000 and > 9000)

There is an [on-line
demonstrator](http://www.gimpel-online.com/OnlineTesting.html) you can
use for checking your C programs and I highly recommend trying it. For a start,
paste the well know first program in the form and press "Analyze Code". Note
the FlexeLint configuration options in comments (no space between `/*` and `lint`).

    /*lint -w4            turn on everything */
    /*lint +esym(534,*)   no demonstrator defaults */
    /*lint -e966          indirectly included header file not used */
    /*lint -esym(9058,_*) tag not used outside typedef */
    /*lint -misra(2)      */

    #include <stdio.h>
    int main(void)
    {
        printf("hello, world\n");
        return 0;
    }


Possible checks include those for MISRA 2004 compliance verification.
The [Motor Industry Software Reliability
Association](https://en.wikipedia.org/wiki/Motor_Industry_Software_Reliability_Association)
has produced a [list of 121 required and 20 advisory
rules](http://doc.hcc-embedded.com/display/CODING/MISRA+Rules) for C
programming. I am proud to report that my program fulfills *almost all*
rules. To assess the few exceptions, one has to understand that MISRA
rules are geared towards embedded systems used in the automotive
industry. That's why features like `malloc` and `printf` are right out.
But that's too restrictive for an IOCCC hosted application, so I ignored
these:

 * 17.1 Pointer arithmetic shall only be applied to pointers that address an array or array element.
 * 17.4 Array indexing shall be the only allowed form of pointer arithmetic.
 * 20.4 Dynamic heap memory allocation shall not be used.
 * 20.9 The input/output library stdio.h shall not be used in production code.
 * 20.11 The functions abort, exit, getenv, and system from the library stdlib.h shall not be used.

I started out with enabling *all* messages using FlexeLint's `-w4`
option and disabling all noise from system headers. Then I dealt with
the remaining messages by addressing them or suppressing them in such a way
that the set of suppressions was minimal. At the end of the day, this is
what remained:


    //  === Tested with FlexeLint 9.00L on FreeBSD 11 ===
    //  Compiler:
    //  "4.2.1 Compatible FreeBSD Clang 3.6.1 (tags/RELEASE_361/final 237755)"

    -w4                          // Enable maximum pickiness
    -passes(6)                   // Recommended in FlexeLint manual for torture testing
    +fsc                         // Make string literals have type const char*
    +fnr                         // ptr-returning functions may return NULL
    -strong(AJX,and,pro,ser,ala) // strong types
    -strong(AcJcm,thr)           // thr is strong, but most arithmetic is okay
    -strong(AarJemorX,met)       // met is strong, but some use is okay
    +libclass(angle)             // All <headers> are system headers
    -wlib(1)                     // Only errors for system headers
    -i/usr/include               // System headers
    -i/usr/local/lib/supp/ansi   // Comes with FlexeLint
    -d__GNUC__=4                 // Pretend...
    -d__GNUC_MINOR__=2           // I'm...
    -d__GNUC_PATCHLEVEL__=1      // someone else.
    -d__builtin_va_list=char*    // Fake this compiler extension
    -d__inline=                  // Delete this compiler extension
    -d__attribute__(x)=          // Delete this compiler extension
    +e900                        // Announce number of messages produced

    //                   MISRA 2004 checking

    /usr/local/lib/supp/lnt/au-misra2.lnt    // Enable all MISRA checking
    -elib(960)       // Don't check FreeBSD system headers for required rules
    -elib(961)       // Don't check FreeBSD system headers for advisory rules
    -e829            // stdio.h used
    -e522            // MISRA 14.2 Highest operation, lacks side-effects
    -esym(960,17.4)  // pointer arithmetic other than array indexing used
    -e971            // char without signed/unsigned
    -e974            // stack usage report
    // Use verboten functions, Req. Rules 20.4 malloc() et al., 20.11, exit()
    -esym(586,malloc,realloc,calloc,free,exit)

    -e911            // implicit promotion of smaller than int to int
    -e921            // cast from integral to integral
    -e925            // cast from pointer to pointer
    -e958            // padding required in struct

    +e9???           // Enable all 9xxx informational messages, except:
    -e9079           // conversion from pointer to void to pointer to other type
    -e9087           // cast performed between a pointer to object type and a
                     // pointer to a different object type
    -e9141           // global declaration of symbol

    //    Messages due to code in FreeBSD headers.
    //
    -dlint           // The "lint" macro is tested in x86/_types.h
    -elib(537)       // Repeated include file
    -e793            // external identifiers > 6 chars
    -e935            // (unsigned) int within struct (actually the size_t)
    -estring(960,_*) // Could be defined at block scope
    -e964            // Header file not directly used
    -e966            // Indirectly included header file not used
    -elib(970)       // int outside typedef
    -esym(9003,_*)   // could be defined at block scope
    -elib(9047)      // FILE pointer dereferenced
    -esym(9058,__*)  // tag not used outside typedef
    -e9092           // NULL does not expand to a pointer (but plain 0)


Compulsory obfuscations
-----------------------

Which of the rules cause which obfuscation?

MISRA 6.1, "The plain char type shall be used only for the storage and
use of character values." This forbids using character constants in
expressions other than assignments to `char` objects. A consequence is
that printing digits with `'0' + digit` is not allowed (even though
`'0'` is technically an `int`!) so I am forced to output hex digits with

    printf("%c", (met)tyr + 32 + 16 + ((8 + EOF) * ((met)tyr / (8 + 2))));

because of the "no magic numbers other than powers of two" rule. How is this
an improvement over `printf("%c", '0' + tyr + 7 * (tyr / 10)`, MISRA?


MISRA 6.3 "typedefs that indicate size and signedness should be used in
place of the basic types." Well, if you can't infer the size and
signedness from `typedef int met`, you're not a real C programmer.


MISRA 10.5, "If the bitwise operators `~` and `<<` are applied to an
operand of underlying type `unsigned char` or `unsigned short`, the
result shall be immediately cast to the underlying type of the operand."
Because the program must work for any unsigned type chosen for the `typ`
macro, including the narrow types enumerated in the rule, a lot of
redundant casting ensues. It gets worse with the next rule...

MISRA 12.1, "Limited dependence should be placed on the C operator
precedence rules in expressions." This requires parentheses for almost
all expressions involving more than one operator, especially those for which
a cast is required, leading to hard to understand expressions such as

    const ser glx = (ser)((asx > (ser)64u) ? (ser)((ser)asx + (ser)8u + (ser)1u) : (ser)asx);
    not.not[leu] = (and)((and)not.not[leu] | (and)(((and)glx % (and)16u) << (and)lys));


MISRA 14.7, "A function shall have a single point of exit at the end of
the function." Sigh. Since I must use eloquent prototypes (8.1, 16.3,
16.4) and static functions (8.10, 8.11), I can only use a few functions.
Everything usually written with an early `return` now cause *another
useless indent level*. The first three `if` statements in `main` cause a
silly 24 character indent. The maximum indent is forced to 8, which is way
too high for a sane function.


MISRA 16.10, "If a function returns error information, then that error
information shall be tested." A cast to void would draw a lint warning, so
I use the `printf` result in expressions,

	lys -= 4 * printf("%c", (met)tyr + 32 + 16 + ((8 + EOF) * ((met)tyr / (8 + 2))));
	val += printf("\n") / ((__LINE__ * L_tmpnam) + TMP_MAX);
	val -= (printf(" %d\n", val) > BUFSIZ) ? FILENAME_MAX : EOF;

which are, in the absence of errors, equivalent to

    lys -= 4;
    /*nop*/
    ++val;


MISRA 13.1, "Assignment operators shall not be used in expressions that
yield a Boolean value." Forbids the idiomatic `if ((p = malloc(n)) ==
NULL)` and requires separate statements, in other words, bloat.


MISRA 16.7, "A pointer parameter in a function prototype should be
declared as pointer to const if the pointer is not used to modify the
addressed object." in conjunction with lint's "Note 952: Parameter could
be declared const" causes const-poisoning for all functions,

    static void phe(const ala not);
    static void gly(ala *const not, const and his);
    met main(met val, const pro *const his[]);

and quite a number of automatic variables.

### Why the "laugh" and "throw up" messages?

The guidelines state "We like programs that: make us laugh and/or throw
up :-) (humor really helps!)"

### If you have a 128 bit type

If your compiler supports a 128 bit wide type (e.g. clang, gcc) then
you can use it via the `typ` macro:

    clang -Dtyp=__uint128_t -o prog prog.c

Indeed, the program can use (and lints clean for) all of

    clang -Dtyp=uint8_t  -o prog8  prog.c
    clang -Dtyp=uint16_t -o prog16 prog.c
    clang -Dtyp=uint32_t -o prog32 prog.c
    clang -Dtyp=uint64_t -o prog64 prog.c
    clang -std=c89 -Dtyp="unsigned long" -o prog89 prog.c

This works because the program has no need for corresponding `SCN` or
`PRI` macros to do the scanning and printing of variables of these
types. With a 128 bit type the program can represent numbers up to
340282366920938463463374607431768211457 (3.4 * 10<sup>39</sup>) as a
single "place", enough to explore yet untested numbers for the rest of
your life.

### How big a number can I test with 4 GB of RAM?

The number of hex digits in the start number is limited by `ARG_MAX`,
probably minus some overhead for the environment variables (use
[`env`(1)](http://pubs.opengroup.org/onlinepubs/9699919799/utilities/env.html)
to trim your environment). In bits this leaves you with 2<sup>4 *
ARG_MAX</sup>.

The algorithm requires two bignums in memory for addition.
If you hit a divergent number, this will cause out-of-memory ("laugh")
somewhere near 2<sup>16,000,000,000</sup> (4GB/2 * 8bits/byte).
Sadly, I don't have a test case :-)

How long would it take to overflow the *Not Overflowing Type*? Lets
assume we're processing 2GB numbers. The program copies, shifts by one,
adds and increments 2GB long bit strings, each time completely thrashing
the data cache -- at *all* levels. We have a fast machine that can do an
iteration in one second, on average. To make things easy, we round up
3*n* + 1 to 4*n*, and assume we never need to divide by two (which is
quite optimistic). Then each iteration shifts left by 2. This would take
8 billion seconds, or about 250 years. If you want to get famous, you
better *remove* some of the RAM, use an ancient box, or reduce available
memory resources with the ulimit(1) built-in of your shell.

For all intents and purposes, the *Not Overflowing Type* keeps the promise!

--------------------------------------------------------------------------------
<!--
(c) Copyright 1984-2016, [Leo Broukhis, Simon Cooper, Landon Curt Noll][judges] - All rights reserved
This work is licensed under a [Creative Commons Attribution-ShareAlike 3.0 Unported License][cc].

[judges]: http://www.ioccc.org/judges.html
[cc]: http://creativecommons.org/licenses/by-sa/3.0/
-->
# Most Different

Anthony Howe <achowe@snert.com>  
Montreal, Quebec, Canada  
<http://www.snert.com/>  
Twitter: @SirWumpus  


## Judges' comments:
### To use:

    make

    ./prog file1 file2

    ./prog -d file1 file2

### Try:

    ./prog prog.orig.c prog.c

    make test
    ./prog -d ABXYEFCD.tmp ACDBECFD.tmp
    ./prog ABXYEFCD.tmp ACDBECFD.tmp

    rm -f curds.tmp whey.tmp
    cp /usr/share/man/man1/cc.1 curds.tmp
    cp /usr/share/man/man1/cc.1 whey.tmp
    chmod 666 whey.tmp
    make makeholes
    ./makeholes -n 1000 whey.tmp
    ./prog curds.tmp whey.tmp
    ./avgtime.sh 100 ./prog curds.tmp whey.tmp

    # Assuming curl(1) installed, grab a really HUGE text file.
    curl -L -o war-and-peace.txt http://www.gutenberg.org/ebooks/2600.txt.utf-8
    cp war-and-peace.txt nuked.tmp
    ./makeholes -c'~' -n 1000 nuked.tmp
    ./prog war-and-peace.txt nuked.tmp
    ./avgtime.sh 100 ./prog war-and-peace.txt nuked.tmp

### Selected Judges Remarks:

This is the best use of the FNV that we have seen in the IOCCC so far!
The output, when used without -d, is compatible with POSIX diff and
is suitable for use with patch.

We welcome back Canada to the list of nations from where winning
entries have been submitted.

Is this code a bug or a feature? :-)  Or is this an attempt to corrupt the
programming of our youth?  Should we heed Kyle's mom words that she uttered
during a South Park P.T.A. Meeting?

   "We must stop dirty (C) language from getting to our children's ears!"

   [Blame Canada](https://www.youtube.com/watch?v=bOR38552MJA):

Or should we teach our youth to understand the intricacies of this code?
Ying Tong Iddle I Po!  We suggest you read the source for yourself, which
might be easier than the academic papers it was inspired by.

NOTE: Unlike the original entry source, prog.orig.c, prog.c uses a
64 bit FNV hash and fixes a function call warning.

## Author's comments:
Features
--------

* "An O(NP) Sequence Comparison Algorithm" by Wu, Manber, Myers, Miller.

* Output compatible with patch(1).

* Strokes one of the judge's ego (I couldn't email chocolate or curry).


Description
-----------

This is a functioning micro diff tool using an [O(NP) algorithm][Wu+89], compared to the older [O(ND) difference algorithm][Mye86] used by some versions of diff.  Its output is based on the default diff(1) output described by POSIX and [The Open Group Base Specifications][SUSV7].  The output is suitable for use with patch(1).

The -d option simply writes the edit distance between file1 and file2.


Observations
------------

The FNV1a hash is a little slow compared to the trival hash GNU Diff uses.  I downloaded a plain text copy of "War And Peace" from Project Gutenberg, used ``makeholes.c`` to make 1000 random changes, then profiled and timed the program verses GNU Diff.  The bottle neck appears to be in the file I/O and line hashing with an average +0.05s slower.  Using a huge file like "War And Peace" for testing offsets the diff(1) optimised file I/O.

There is no hash collision checking, partly because FNV1a appears to generate very [few collisions][HshCmp] and an assumption that localised collisions within a region of edits are highly unlikely.


Support Files
-------------

* ``prog-test.sh``  
Basic test program verifies known test edit distances and patch support.

* ``avgtime.sh``

* ``makeholes.c``  
Random edits (holes) made to a file in-place.


References
----------

Wu, Manber, Myers, and Miller; August 1989;  
"An O(NP) Sequence Comparison Algorithm";  
<http://myerslab.mpi-cbg.de/wp-content/uploads/2014/06/np_diff.pdf>

Fowler, Noll, Vo; 1994  
<http://www.isthe.com/chongo/tech/comp/fnv/index.html>

Fowler, Noll, Vo on Wikipedia  
<https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function>

"diff", The Open Group Base Specifications Issue 7  
IEEE Std 1003.1, 2013 Edition  
<http://pubs.opengroup.org/onlinepubs/9699919799/utilities/diff.html>

Eugene W. Myers; "An O(ND) Difference Algorithm and Its Variations";  
Algorithmica, 1986, pages. 251-266  
<http://www.xmailserver.org/diff2.pdf>

Webb Miller and Eugene W. Myers; "A File Comparison Program";  
Software-Practice And Experience, Vol. 15(11). 1025-1040 (November 1985)  
<http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.189.70&rep=rep1&type=pdf>

D.S. Hirschberg, "A linear space algorithm for computing maximal common subsequence problem";  
Comm. of ACM, Vol. 18, June 1975, pages 341-343  
<http://www.mathcs.emory.edu/~cheung/Courses/323/Syllabus/DynProg/Docs/Hirschberg-LCS-1975.pdf>

Which hashing algorithm is best for uniqueness and speed?  
<http://programmers.stackexchange.com/questions/49550/which-hashing-algorithm-is-best-for-uniqueness-and-speed>

[Wu+89]: http://myerslab.mpi-cbg.de/wp-content/uploads/2014/06/np_diff.pdf

[FNV94]: http://www.isthe.com/chongo/tech/comp/fnv/index.html

[FNVWi]: https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function

[Mye86]: http://www.xmailserver.org/diff2.pdf

[SUSV7]: http://pubs.opengroup.org/onlinepubs/9699919799/utilities/diff.html

[Mil85]: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.189.70&rep=rep1&type=pdf

[Hir75]: http://www.mathcs.emory.edu/~cheung/Courses/323/Syllabus/DynProg/Docs/Hirschberg-LCS-1975.pdf

[HshCmp]: http://programmers.stackexchange.com/questions/49550/which-hashing-algorithm-is-best-for-uniqueness-and-speed

--------------------------------------------------------------------------------
<!--
(c) Copyright 1984-2016, [Leo Broukhis, Simon Cooper, Landon Curt Noll][judges] - All rights reserved
This work is licensed under a [Creative Commons Attribution-ShareAlike 3.0 Unported License][cc].

[judges]: http://www.ioccc.org/judges.html
[cc]: http://creativecommons.org/licenses/by-sa/3.0/
-->
# "For the Birds!" Award

Chris Mills  
Twitter: @MisterXopher  


## Judges' comments:
### To use:

    make
    
    ./prog

### Try:

    Pressing the up arrow and the down arrow at the right time.

### Selected Judges Remarks:

Did you find that mobile application game a bit frustrating?
Well you can adjust the makefile parameters to make life a
bit easier for you:

    make clobber all DW=199999 DW=22 DH=16 DA=50 DI=-150

From the makefile:

    # Game parameters
    #
    DU=99999        # Time between steps in microseconds.
		    # Make it larger if the game is too fast for you.

    DW=28           # Pipe-to-pipe spacing, in columns.
		    # Farther apart is easier.

    DD=20           # Space between pipes.
		    # The difference between DD and DW is the width of a pipe.
		    # Narrow pipes are easier to fly though.

    DH=8            # Height of gap in pipe.
		    # Make this larger to make the game easier.

    DA=100          # Acceleration due to gravity (scaled by 256).
		    # Smaller values make you glide slower.

    DI=-200         # Impulse velocity of a flap (scaled by 256).
		    # Make larger if you want an less intense tapping experience!

    DB='"<o^="'     # Sprite for player when gliding.
		    # HINT: Try using various emoji.
		    # NOTE: The string MUST be enclosed inside double quotes.

    DF='"<ov="'     # Sprite for player when flapping.
		    # HINT: Try using various emoji.
		    # NOTE: The string MUST be enclosed inside double quotes.

    DG='"Tap to Flap!"'     # Instruction text.
			    # Change to your native tongue.
		    # NOTE: The string MUST be enclosed inside double quotes.

Enjoy! 

    TAP!! TAP!! TAP!!
    FLAP! FLAP! FLAP!

## Author's comments:

The Program
===========

Better late than never to jump on the bandwagon of 2014's most successful
mobile game.  The game is called Tappy Bird, and has all the sophisticated
gameplay of the original, except with an exciting twist! (you get to fly to
the right instead of to the left).

In addition, the game features exciting new customization options!  Too hard?
Ran into that damn wall too many times?  Now you can change physics!  Change
any of a number of parameters (speed, gravity, etc.) of the game to suit your
gameplay!

You can even make the game more challenging -- resize the terminal window to
make the world taller or shorter.  You'll never be able to get through the
pipes when they are four times as tall!

Instructions
------------

The instructions are printed at the start of the game:  Tap to Flap!

Hit any key to make your bird fly.  Navigate her between the gaps in the pipes.
Your score is shown in the upper left, along with your current high-score.

Customization options
---------------------

To customize the gameplay, change any of the following options on the compile
command line:

 * `-DU`: Time between steps in microseconds.  Make it larger if the game
   is too fast for you.
 * `-DW`: Pipe-to-pipe spacing, in columns.  Farther apart is easier.
 * `-DD`: Space between pipes.  The difference between `D` and `W` is the
   width of the pipe.  Narrow pipes are easier to fly though.
 * `-DH`: Height of gap in pipe.  Make this larger to reduce the challenge.
 * `-DA`: Acceleration due to gravity (scaled by 256).  Smaller values
   make you glide slower.
 * `-DI`: Impulse velocity of a flap (scaled by 256).  Make this smaller
   if you want an intense tapping experience!
 * `-DB`: Sprite for player when gliding.
 * `-DF`: Sprite for player when flapping.  
 * `-DG`: Instruction text.  Change to your native tongue.

Feel free to try out physics or playfield options to make the game more
interesting.  Try setting the player sprites to change the game completely --
maybe you can be a fish, or a pig -- the options are limitless!  Try using
emoji -- you can be a flying beer mug!

Note that since the `curses` library on POSIX doesn't natively support wide
characters (needed for UTF-8 support, which is needed for emoji), you may need
to make some changes to the `Makefile` to get emoji to work on your system.
To help you get started, I've included some example substitutions for emoji
sprites and instruction text; for example, type

    make EMOJI=beer LANGUAGE=spanish

or

    make EMOJI=globe

for some examples (the full list of options is in the `Makefile`).  Don't
forget to `make clean` first.  If the output doesn't look right, you may need
to link with the "wide" version of `ncurses`.  On MacOSX 10.11, it should work
with the current `-lcurses`; on Linux, you probably need `-lncursesw`.
See the `Makefile` to make this change if you need to.  Or buy a Mac.

You will also need a UTF-8 compatible terminal and an emoji font installed,
and you will need to have your `LANG` environment variable set to use UTF-8.
Again, if this is too complicated, maybe just go and get that Mac.

Future additions
----------------

Future versions of the game will include monitization via the freemium model
with micropayments for customization options, play-to-win and of course
live-streamed targeted video advertising.



--------------------------------------------------------------------------------
<!--
(c) Copyright 1984-2016, [Leo Broukhis, Simon Cooper, Landon Curt Noll][judges] - All rights reserved
This work is licensed under a [Creative Commons Attribution-ShareAlike 3.0 Unported License][cc].

[judges]: http://www.ioccc.org/judges.html
[cc]: http://creativecommons.org/licenses/by-sa/3.0/
-->
# Most connected

Scott Vokes  
Twitter: @silentbicycle  


## Judges' comments:
### To use:

    make
    ./prog < example-1.txt

### Try:

    ./prog < example-2.txt
    ./prog < example-tab.txt
    ./prog < ioccc.txt

### Selected Judges Remarks:

What this program does is not witchcraft and there are no spectres, but you
might have a meltdown trying to work it all out.

This entry is designed to mislead in many ways. However, if you find yourself
wanting to know the possibilities for navigating a graph, you will get the
answer you seek with no hocus pocus.


## Author's comments:
Introduction
------------

This program reads a directed graph (as lines with integer node IDs),
and prints the graph's nodes in reverse-topologically sorted order,
grouped into strongly connected components. Given a set of nodes
representing targets and edges representing dependencies between them,
it produces a build order with any dependency cycles gathered.

For example, the following input (provided as `example-1.txt`):

    0 4 8
    1 0
    2 1 3
    3 2
    4 1
    5 4 6
    6 5 2
    7 3 6 7

would be interpreted as:

    0 -> 4, 8
    1 -> 0
    2 -> 1, 3
    3 -> 2
    4 -> 1
    5 -> 4, 6
    6 -> 5, 2
    7 -> 3, 6, 7

So, node 0 has edges to / depends on nodes 4 and 8, node 1 depends on
node 0, and so on. Then, it groups the graph's nodes into
strongly connected components and prints them in reverse-topologically
sorted order:

    0: 8
    1: 0 1 4
    2: 2 3
    3: 5 6
    4: 7

It uses Tarjan's strongly connected components algorithm for the
grouping and reverse-topological sorting, along with a bonus hidden
implementation of counting sort, which sorts each group.

For other details about the input format, see "Issues and
Limitations".


Building
--------

To build:

    ${CC} -o prog prog.c -std=c11 -O3 \
        -Wall -Wextra -pedantic -Wno-missing-prototypes

`-Wno-missing-prototypes` is necessary because there aren't any
prototypes. (They would put the program well over the size limit.)

Note: The program can also be built with `-std=c99` or `-std=c89`.

If building with `-Weverything`, then `-Wno-strict-prototypes`
may also be necessary -- the function pointer declarations for
`_` and `B` may get warnings otherwise, for reasons described
under "Obfuscations".


Obfuscations
------------

- This entry uses functions that have a variable number of arguments,
  but despite what the rules say, there is no need to be careful about
  `va_list` implementation differences. :) . There are several
  references to a function pointer, `_`, but it's called with different
  numbers of arguments in different places. (In particular, look at
  `spell`.) Because the function pointer declaration has an empty list
  of parameters, the argument count and types are unconstrained. `_` is
  set to different functions in several places, but it is always called
  with appropriate argument(s) for its possible current functions. This
  is allowed by the standard -- The section on F,I,N,D,M,Y,C,L,U,E has
  further details.

- It uses `_` in three different scopes: as a goto label (function
  scope), as an enum name, and a `_` function pointer (which is required
  to have file scope, since it starts with '_'). There are also other
  `_`s: it appears in a string, obscured by a headecimal escape sequence
  (`\x5f`), and the cauldron is supported by a giant underscore.
  (Does this program qualify for Best One Liner?)

- Most of the variables are not only global, but used for unrelated
  purposes at different times, so just renaming them while studying the
  program should make it even more confusing. The few variables local to
  functions have their names reused for different things in other
  functions.

- There is an enum early on that defines several single-letter
  identifiers: F,I,N,D,M,Y,C,L,U,E. These are used for array offsets,
  both individually and in combination. The first several values are
  also a clue: ISO/IEC 9899:1999 chapter 6.7.5.3 verse 14 describes how
  function declarators with an empty parameter list behave. (As does
  3.5.4.3 for ANSI C, which explains the 0x3543 that appears soon
  after.)

- Several parts of the program's state are stashed in otherwise unused
  offsets of the node arrays. These locations are accessed in multiple
  ways, such as using `I[p]` (where I == 7) as well as `p[F+L]` (6+1),
  or `b[M-N]` (14-5) and `U[b]` (where U == 9).

- The other identifiers are misleading, punny, or both. `spectre` does
  not exploit CVE-2017-5753 or CVE-2017-5715, for example -- it just fits
  the witch theme. `cast` doesn't cast, `hex` has nothing to do with
  hexadecimal, `bubble` is not bubble sort, there is no undefined
  behavior in `nasal_demons`, and `main` has absolutely nothing to do
  with a hand.

- For well-formed input, how the program determines when to exit is a
  bit obscure. `main` ends with a `goto` leading back to an earlier `_`
  label, so it just loops forever, and `exit` only appears in code paths
  related to error-handling. It looks like `cast` calls `meltdown` with
  its second argument set to 0, which would call `exit`, but running in
  gdb with a breakpoint on `cast` reveals that it isn't being called...

- Instead of using `isdigit()`, the program checks the numeric value of
  each `char`, and literals that would suggest comparing against e.g. '0'
  are specified in octal in one place, and produced by arithmetic using
  the enum elsewhere.

- Common conventions are subverted: `i` is not a loop index, `argv` and
  `argc`'s names are swapped.

- `NULL` does not appear in the program. Instead, `argc[argv]` (which is
  required to be a null pointer) is saved and passed to where its value
  is needed.

- Oh, and the program is squashed into the shape of a bubbling cauldron,
  on top of a giant underscore, so there's that.


Issues and Limitations
----------------------

- Despite appearances, it does not handle numbers in hex, or provide
  a `curses(3)`-based interface.

- The expected input format is zero or more lines of space-separated
  integers. If other characters appear in the input, it will either
  reject the input entirely and exit with a non-zero status, or skip
  number(s) adjacent to the non-digit characters, depending on where the
  characters appear. Tabs and multiple consecutive spaces are handled
  correctly, however.

- Individual lines of input longer than `0x3543 - 1` bytes will be
  split and processed as if they were multiple lines of input, which can
  produce incorrect results. This magic number's significance is
  described earlier.

- The algorithm expects its input to represent a fully connected graph.
  While the output is otherwise topologically sorted, if there are nodes
  completely unconnected to the rest of the graph (with or without
  self-cycles), they will be output as soon as they are processed --
  this means that, when there are disconnected nodes, reordering the
  input lines can produce different output. Addressing this by adding
  another pass is would put the program over the size limit.

- While the node IDs don't need to be consecutive or start at 0, the
  implementation doesn't have special handling for sparse graphs. If you
  give it a graph with nodes numbered 0 and 2147483647, it will attempt
  to allocate sufficient memory (potentially around 32 GB) for the
  entire range of graph nodes, even if those are the only ones. If
  memory allocation returns NULL, it will gracefully exit, otherwise it
  will succeed, eventually, perhaps after a great deal of swapping.

- Node IDs >= 2147483648 will cause the program to print an error
  message and exit with a non-zero status. This shrinks the code that
  detects overflowing the array size by a bit.

- A very large group of nodes in a cycle can cause a stack overflow.
  This typically takes over 100,000 nodes, and depends on the order the
  nodes are visited. Addressing this would put the program over the size
  limit.

- The implementation depends on the characters '0', '1', ... '9' having
  the values 48 through 57, rather than using `isdigit()`. As noted
  above, this program has nothing to do with a hand.

--------------------------------------------------------------------------------
<!--
(c) Copyright 1984-2018, [Leo Broukhis, Simon Cooper, Landon Curt Noll][judges] - All rights reserved
This work is licensed under a [Creative Commons Attribution-ShareAlike 3.0 Unported License][cc].

[judges]: http://www.ioccc.org/judges.html
[cc]: http://creativecommons.org/licenses/by-sa/3.0/
-->
# Best use of python

Yusuke Endoh  
Twitter: @mametter  


## Judges' comments:
### To use:

    make

    ./prog

### Try:

    make

    ./prog | tee prog_next.c
    make prog_next
    ./prog_next | tee prog_next.c
    make prog_next
    ./prog_next | tee prog_next.c

    make python

    make python3

### Selected Judges Remarks:

And now for something completely different: A program whose metabolic
processes are a matter of interest only to historians. It has kicked the bucket
and departed to that mysterious country from whose bourne no traveller returns!
This is an EX-tremely obfuscated program!


## Author's comments:
                             ___-----__
                          _--          --__
                        _-        _--_     \
                      _-    /\  +-.:.:-+ /\ \
                     /      \/  |.:.:.:| \/  |
                    /           |:.:.:.|     |
                   /            |.:.:.:|      |       ___-----___
                  |              |.:.:|       |      /           \
                  |              |:.:.|       |     <   It's ...  |
                  \               |:.|       |       \           /
                   \               ||        |        ---_____---
                 _--\                       |
               _-    -__                    |
            __-         --___               |
          _-                                |
         /                                   |
        |                                     |

--------------------------------------------------------------------------------
<!--
(c) Copyright 1984-2018, [Leo Broukhis, Simon Cooper, Landon Curt Noll][judges] - All rights reserved
This work is licensed under a [Creative Commons Attribution-ShareAlike 3.0 Unported License][cc].

[judges]: http://www.ioccc.org/judges.html
[cc]: http://creativecommons.org/licenses/by-sa/3.0/
-->
# Best one-liner

Dave Burton  
<http://ioccc.snox.net>  


## Judges' comments:
### To use:

    make
    ./prog < any-file

### Try:

    ./prog < prog
    ./prog < prog.c

### Selected Judges Remarks:

One line, one array, one loop and one statement but it prints many bytes. It won.

## Author's comments:
Feed this anything on stdin.

The included script may be used as a driver program for this entry.
It adds several nice-to-have features, and allows salt-to-taste customizability.

This code has been compiled and tested on:

* OSX-10.11, gcc 4.2.1 and clang 3.0, -O0 and -O3
* X86-Linux, gcc 4.1.2 and 4.8.4, -O0 and -O3
* ARM-QEMU, gcc 4.8.4, -O0 and -O3
* X86-FreeBSD 10.3, clang 3.4.1, -O0 and -O3
* TCC 0.9.26 (x86-64) (used as a proxy for [2001/bellard](http://ioccc.org/years.html#2001_bellard))
* UNIX V7 pcc (Johnson's C compiler) on a [simulated PDP-11/45](http://simh.trailing-edge.com/)
  (see spoiler for further detail)

<div style="margin-bottom:60em;margin-top:4em"><strong>Spoiler below; scroll down.</strong></div>

SPOILER
-------

This started life as a personal challenge: write the shortest hex dump utility in C.

The self-imposed ground rules in the hunt for shortest:
the code has to output correctly,
no extraneous newlines, the code must be portable,
and without bypassing the solution using execve(2),
or functions built upon it (system(3), popen(3), etc).  E.g:

	main(){system("hd");}	// it's turtles all the way down!

is not acceptable.
And, "output correctly" is the output format of this entry.  QED.

Early attempts ended up at a reasonably short 157 characters.
This was too long for a one-liner, so it had to be formatted as something more interesting.
This solution is pleasing, but a true one-liner was the hoped-for goal.
Here is the 157 character version in it's entirety:

	char     O,o[  20];L(O){
	putchar  ( O+  48+39  *(9<
	O));}    I(O)  {L(~     15);
	O|| puts(o);}  main     (l){
	for(;~(l=getchar())     ;I(O
	&=15     ))o[  O++      ]=4<
	(4^l     >>5)  ?l:     46,L
	(l>>     4),L  (l&15);O&&
	I(o[     O]=0  );}//157c

While thinking about this in the shower (you are not the only one that does this!)
came the idea which reduced the code to just 119 chars.
This dramatic reduction started to feel close to minimal, and the hunt resumed.
The progression to the present size is interesting,
and it is interesting that the same algorithm can be expressed so differently
by slight rearrangement of its parts.

	// 119
	char O,o[20];main(l){for(;~(l=getchar());O||puts(o))o[O++]=isprint(l)?l:46,O&=15,printf("%02x ",l);O[o]=0;O&&puts(o);}
	// 116
	char O,o[20];main(l){for(;O++[o]=~(l=getchar())?4<(4^l>>5)?l:46:0;(O&=15)||puts(o))printf("%02x ",l);O>1&&puts(o);}
	// 115
	char O,o[20];main(l){for(;O[o]=~(l=getchar())?4<(4^l>>5)?l:46:0;(O=-~O&15)||puts(o))printf("%02x ",l);O&&puts(o);}
	// 113
	char O,o[20];main(l){for(;~l;(O=~l?printf("%02x ",l),-~O&15:!O)||puts(o))O[o]=~(l=getchar())?4<(4^l>>5)?l:46:0;}
	// 112
	char O,o[20];main(l){for(;~l;(O=~l?-~O&printf("%02x ",l)*5:!O)||puts(o))O[o]=~(l=getchar())?4<(4^l>>5)?l:46:0;}
	// 111
	char O,o[20];main(l){for(;~l;O||puts(o))O=(O[o]=~(l=getchar())?4<(4^l>>5)?l:46:0)?-~O&printf("%02x ",l)*5:!O;}
	// 110
	char O,o[0];main(l){for(;~l;O||puts(o))O=(O[o]=~(l=getchar())?4<(4^l>>5)?l:46:0)?-~O&printf("%02x ",l)*5:!O;}
	// 109
	char O,o[];main(l){for(;~l;O||puts(o))O=(O[o]=~(l=getchar())?4<(4^l>>5)?l:46:0)?-~O&printf("%02x ",l)*5:!O;}

There are solutions without the ASCII sidebar that are significantly shorter.
These do not compete in the same category, since their output is materially different.
They are derived from the solutions above, but are still fascinating as concise utilities,
so here is their progression, for the curious:

	// 102
	I;O(O){putchar(O+48+39*(9<O));}main(l){for(;~(l=getchar());O(++I&15?~15:~37))O(l>>4),O(l&15);O(-38);}
	// 80
	O;main(l){while(~(l=getchar()))printf("%02x%c",l,++O&15?32:10);O&15&&puts("");}
	// 78
	O;main(l){for(;~l;(O=~(l=getchar())?printf("%02x ",l),-~O&15:!O)||puts(""));}
	// 77
	O;main(l){for(;~l;(O=~(l=getchar())?-~O&printf("%02x ",l)*5:!O)||puts(""));}
	// 76
	O;main(l){for(;~l;O||puts(&O))O=~(l=getchar())?-~O&printf("%02x ",l)*5:!O;}

It is possible to reduce the size of each of these by one by eliding the trailing newline.
This was not reported above since the newline kept getting appended by processing software,
and it is more interesting to remove characters by changing code than by filtering:

	$ tr -d '\012' < 109.c | wc -c
	108
	$ tr -d '\012' < 76.c | wc -c
	75
	$ tr -d '\012' < 109.c | cc -o 108 -xc -
	$ verify 108
	$

An obfuscated hex dump has been done before:
[1986/bright/bright.c](http://ioccc.org/1986/bright/bright.c) is similar in function,
but it uses more characters in just setting up its obfuscation than this entire solution!

BIGGER SPOILER
--------------

If you are unhappy with the way DEL (character 127) is handled,
replace the cryptic expression `4<(4^l>>5)?l:46` with `32>l|l>126?46:l`.
Both take the same number of characters, but the former is a bit more interesting.
Bonus question: how does the first expression work?

BIGGEST SPOILER (and some history)
----------------------------------

Technically, `char o[0];` is illegal (SS 6.7.6.2) according to ISO (N1570).
And `char o[];` is a conditionally supported feature (SS 6.7.6.2, 6.10.8.3).
However, it works in modern C implementations as an extension,
including GCC, Clang and TCC, for X86 and ARM,
on multiple operating systems (Linux, OSX, FreeBSD), so it is _functionally_ correct.
MicroSoft Visual C++ does not allow `char o[]` or `char o[0]`,
and implements its close relative `char o[1]`
such that writing more than a single char will cause a fault, which is _technically_ correct.

But how does this work at all, even as an extension?
`o[]` allocates one(!) byte in a zero-filled data area (formerly BSS).
The UNIX-derived systems this code was run upon all place the
storage of `O` and `o` into a zero-filled VM page with nothing following:
thus, there are plenty of available and unused zero bytes following `O`, addressed via `o`,
and this code only needs 17.
This is _undefined_ behavior, but as shown, it is widely available.

The [1979 Seventh Edition UNIX][1] (v7) system pre-dates the IOCCC by several years,
and the source code to `sh`(1) was a [significant inspiration for this contest][2].
There are two C compilers present: `cc` written by Dennis Ritchie, and `pcc` written by Steven Johnson.
The nested conditional expressions in 116 and smaller are too complex for `cc` ("Illegal conditional")
but `pcc` handles them correctly, and neither compiler accepts `char o[]` or `char o[0]` nor puts the bytes in
a zero-filled page (as a paged VM was not yet written for UNIX).

[1]: http://minnie.tuhs.org/cgi-bin/utree.pl
[2]: http://ioccc.org/all/README
[3]: http://www.computerworld.com.au/article/279011/a-z_programming_languages_bourne_shell_sh/?pp=4

More significant is that v7 `printf`(3) does not report the number of characters written,
and therefore 111 compiles but does not work correctly;
113 is the shortest code that compiles and runs correctly in Ancient UNIX.

> Interesting digression: v7 `printf` (`_doprnt`) was written in PDP-11 assembler.
> It pre-dates `varargs.h`, and assembly was the only way to gain access to the variable argument types.
> The first edition _The C Programming Language_, 1978, page 71, remarks:

>> By the way, there is no entirely satisfactory way to write a portable function
>> that accepts a variable number of arguments, because there is no portable way
>> for the called function to determine how many arguments where actually passed to it in a given call.
>> ... 
>> `printf`, the most common C function with a variable number of arguments,
>> ... is also non-portable and must be modified for different environments.

> It is fascinating to explore the roots of C through the history of the operating system
> it was birthed within.  C is often criticized as a difficult, inscrutable language, 
> but as this contest demonstrates, this is in parody.
> _Shell-gol_ is one of those instances where someone [preferred a different language][3],
> and (ab)used the preprocessor to re-mold C into something they found comfortable.
> Most of the rest of the system, especially in the kernel,
> are models of clarity and efficient expression.

TL;DR
-----

So which version is the shortest, portable hex dump?

* 109 works with (most?) modern Unix-like systems and compilers, see example list above.
* 111 works adds Microsoft, is standards-approved, and does not exploit undefined behavior.
* 113 works on Ancient UNIX and the portable C compiler.
* 119 works on all platforms, including the original Ritchie PDP-11 C compiler.

Coda
----

Clearly, the smallest possible program violates modern best practice.
It is not even possible to compile cleanly, but it will compile correctly.

Included is `prog.nowarn.c`, a modern C implementation that is -- perhaps -- the smallest,
clean-compiling version using `clang` or `gcc` with `-Wall -pedantic`.
Note that while this is larger than all but the original attempt,
it will *not* work with the original Ritchie PDP-11 C compiler,
since the expression within the ternary remains too complex.

Try

	cat prog.c prog.nowarn.c

to compare the differences (`diff` is not helpful on a one-liner).

--------------------------------------------------------------------------------
<!--
(c) Copyright 1984-2018, [Leo Broukhis, Simon Cooper, Landon Curt Noll][judges] - All rights reserved
This work is licensed under a [Creative Commons Attribution-ShareAlike 3.0 Unported License][cc].

[judges]: http://www.ioccc.org/judges.html
[cc]: http://creativecommons.org/licenses/by-sa/3.0/
-->
# Most shifty

Don Yang  
<http://uguu.org/>  


## Judges' comments:
### To use:

    make
    more generated1.c
    more generated2.c
    more generated3.c

### Try:

    make
    ./left < prog.c
    ./right < prog.c
    ./left < prog.c | ./left

    ./shift < prog.c

    ./msg0
    ./msg1
    ./msg2

### Selected Judges Remarks:

Code should be readable in any direction! This tool will help you rotate your
code so you don't have to stare at it sideways or even upside down. Rotating
this program left and recompiling will reveal other tools including a right rotate
and a shift program.

Strange things happen when the world is upside down! It is entirely possible
that this is remark is completely misleading.

What exactly does the shift program do?

Like a great sliding puzzle (hint) this entry has 6 more programs that will
reveal messages and one more tool that can be used to reveal the final
message hidden in the original source.  All of these can be created using
combinations of ./left, ./right and ./shift and the additionally generated
programs.

The final message can be revealed using

    ./msg9 < prog.c

But what combinations will generate ./msg3, ./msg4, ./msg5, ./msg6, ./msg7,
./msg8 and finally ./msg9?

## Author's comments:
# Tools usage

Nuko is a text rotator: given some text in stdin, Nuko will write the
same text to stdout, but rotated 90 degrees counterclockwise.

    gcc prog.c -o left
    ./left < input.txt > rotated_counterclockwise.txt

Due to static memory allocation, only the first 1K columns by 1K rows
are rotated, the rest are silently ignored.  But fear not, a separate
tool with dynamic memory allocation is included:

    ./left < prog.c > r1.c
    gcc r1.c -o right
    ./right < input.txt > rotated_clockwise.txt

For variety, this second tool rotates clockwise instead of
counterclockwise.  Also, it can handle files larger than 1024x1024,
depending on how much memory you got.

Of course we wouldn't stop with just two rotations, if we continue to
rotate counterclockwise once more, we get another program.  This
program outputs a single message to stdout, which is the name of the
series that Nuko came from.

    ./left < prog.c | ./left > r2.c
    gcc r2.c -o msg0
    ./msg0

There is one final rotation, which produces a tool that removes
leading whitespaces:

    ./left < prog.c | ./left | ./left > r3.c
    gcc r3.c -o shift
    ./shift < input.txt > no_leading_space.txt

Where this might be useful, besides ruining the formatting of certain
files, is that it completes the set of tools needed to solve the
puzzle that is embedded in prog.c

# Puzzle box

Notice how the edges of prog.c contain two notches.  By rotating
prog.c and removing leading space, the code would be shifted one space
toward one of those notches (and creating a new notch on the other
side).  This shifted code behaves slightly different from the original
program.  For example, here are two more messages that can be
produced:

    ./shift < prog.c | ./right > msg1.c && gcc msg1.c -o msg1 && ./msg1
    ./shift < prog.c | ./left > msg2.c && gcc msg2.c -o msg2 && ./msg2

In total, there are 9 embedded strings that can be produced via a
sequence of rotates and shifts, one of which can be used to extract
the 10th final string from prog.c.  The intent is to simulate those
wooden puzzle boxes that can be opened by pushing and shifting various
well-concealed seams.  Thus, finding the correct sequence of rotates
and shifts is left as an exercise to the reader (but if you are really
lazy, just read the Makefile).

Source code for all the tools needed to solve this puzzle are embedded
in prog.c, all you need is a C compiler.

# Features

   - Code compiles when rotated 4 ways.  This required a bit of
     patience to achieve.  Code still compiles even with one column of
     text shifted.  This required even more patience.

   - All rotated and shifted variants compiles without warnings.  This
     involves various tweaks to satisfy cases where compiler is overly
     protective, including but not limited to the "1125" at line 4 as
     opposed to "1025", to satisfy -Waggresive-loop-optimizations.

   - CRC32 of the code is embedded in the code itself.

   - Process for writing prog.c is available in spoiler.html

# Compatibility

Nuko and the rotated tools accepts only ASCII files where each
character maps to exactly one byte.  Also, end-of-line sequence is
assumed to be LF only, as opposed to CR-LF.  All control characters
are treated like normal printable characters, so files containing tabs
will look weird after rotation, for example.

Nuko has been verified to work with these compiler / OS combinations:

   - gcc 4.8.4 on Linux
   - gcc 4.9.2 on Linux
   - gcc 6.1.0 on JS/Linux
   - gcc 6.3.0 on Linux
   - gcc 6.4.0 on Cygwin
   - clang 3.5.0 on Linux
   - clang 3.8.1 on Linux
   - clang 5.0.1 on Cygwin
   - tcc 0.9.25 on JS/Linux

Nuko compiles without warnings with all compilers above, even with
"-Wall -Wextra -pedantic" for gcc and clang.

--------------------------------------------------------------------------------
<!--
(c) Copyright 1984-2018, [Leo Broukhis, Simon Cooper, Landon Curt Noll][judges] - All rights reserved
This work is licensed under a [Creative Commons Attribution-ShareAlike 3.0 Unported License][cc].

[judges]: http://www.ioccc.org/judges.html
[cc]: http://creativecommons.org/licenses/by-sa/3.0/
-->
# Most cacophonic

Anton lgmyr  
Twitter: @aalgmyr  


## Judges' comments:
### To use:

    make

    cat prog.c | ./prog           # Printing garbage might break your font
    ./prog <file1> <file2> > out.raw
    ./prog -d 2 0 out.raw         # Decode the first (0th) channel out of two

### To try:

    ./prog -h | ./prog -d 1 0

    # Who needs cat?
    ./prog prog.c | ./prog -d 1 0

    # Assuming ALSA
    echo '<<<<<<  /\_/\_/\  _-_-_-_  !!!!!  :.:.:.:  >>>>>> ****** ~~~~~~~' |
        ./prog | aplay -c1 -fFLOAT_LE -r44100

    # Assuming sox
    echo -n ' MENE MENE TEKEL UPHARSIN ' | ./prog | 
        sox -t raw -c 1 -r 44100 -L -e floating-point -b 32 - -n spectrogram -d 10 -X 300

### Selected Judges Remarks:

Be warned, this is not your garden variety text-to-speech program! Earplugs are advised,
or at least a handy and well-tested volume knob.

Pixels are numbered, amplitudes are weighed, frequencies are divided,
and the message can be displayed in fiery letters, but don't be alarmed.

How does decoding of the waveform work? Can you encode an arbitrary text in a sound sample?


## Author's comments:

What is this?
=============
To put it brief, this entry is akin to a sound based cat. It takes characters as input and outputs them into frequency space as audio. The entry also supports decoding the produced waveforms using the `-d` flag. Usage instructions is output if run with the `-h` flag, albeit not in an immediately legible format.

Details
-------
In normal operation, the entry reads characters from one or more sources. If the `-h` flag is given, usage instructions is used as a source. Else if file paths are present as arguments those will be used. Else stdin is used.

If a character is part of the supported subset of ASCII `{10, 32-126}` then that character is output into frequency space of an audio signal (44.1 kHz single precision float, endianness should depend on system endianness) through stdout. Any other character will be interpreted and outputted as a space.

Characters are printed using a (slightly modified) pixel font based on [gohufont](https://github.com/hchargois/gohufont). Pixels are drawn using crosses in frequency space, achieved by simultaneous up and down chirps.

Each input source is designated its own channel in the output (one float per channel per time step in the output) so if you have a surround sound system you could listen to a cacophony of chirpy characters.

Interestingly, with training you might actually be able to tell characters just from hearing. But even without training you can easily read along with the printed characters and have the sound make sense with the look of the characters.

See image spoiler.png for an example spectrogram.

Limitations
-----------
There is no error checking done when opening files, so expect segfaults if you provide the wrong path to a file.

This program is bound to misbehave if int is less than 32 bits.

Flags will only be interpreted correctly if they are the first argument. Reading a file named `-d` or `-h` is fully possible if it is not the first file provided, even though I am not sure why you would want to do that.

Providing invalid/unexpected arguments to the decode flag will result in odd behavior. Some erroneous arguments cause segfaults (negative number of channels, channel id outside valid range). One argument in particular causes an infinite loop printing whitespace.

Techniques
==========

Obfuscation
-----------
A lot of the obfuscations done came naturally from trying to appease the size tool. To name some:

* One character names
* Merging of related (and not so related) arithmetic operations
* Short circuiting for flow control to replace some `if`s
* Some `#defines`, sadly

On the intersection of size and obfuscation is the data encoding, which was quite fun to design.

Some additional obfuscation was done to mathematical formulas. Somewhat known expressions was transformed into equivalent but less recognizable counterparts.

I have tried to avoid intentional red herrings in the code, although fishy statements are plentiful.


Data encoding
-------------
The large string in the beginning of the source file contains font data, encoded in base64 using characters in the range `' '` to `'_'`. The space was chosen as the zero because the data contains a lot of zeroes, and quite helpfully the size tool ignores whitespace even in strings. Without this fact the program would have been too large and the decoding feature would have had to go. Fortunately this hole in the size spec was readily available. :)

Characters in the font (5x8 pixels, 40 bits) is packed into 7 base64 digits (which was a pain to decode in minimal code).

Math
----
Note that even though floats are used for the waveforms, the standard math library is not used at all! Most arithmetic is done purely on integers. The only major exception is generating a table of sine values which are interpolated to give high resolution waveforms. Can you see when the generation is triggered, and how it is done?

A critical issue encountered was that having abrupt starts and ends of signals cause a lot of problems with spectral leakage which makes spectrograms hard to read and audio painful to listen to. To reduce spectral leakage a windowing function was used. Although the one used is quite well known, it is not in a form that should be familiar to anyone. What looks like a polynomial and quacks like a polynomial might not actually be a polynomial, at least not deep inside.

Printing a string
-----------------
The program was written to deal exclusively with file descriptors, so how would one go about printing a char array not from a file descriptor without adding additional logic? Answer: `ungetc` into stdin, one char at a time (to be standards compliant). This is used to print the usage instructions.

Compilation warnings
====================
Compiling using

    gcc -Wall -Wextra -pedantic

gives only `-Wmisleading-indentation` which is sensible considering the source code. While

    clang -Wall -Wextra -pedantic

is a bit more pessimistic and gives `-Wempty-body` (I like loops without bodies), `-Wstring-plus-int` (since apparently some people think string+int is a concatenation) and one of the weirder warnings I have seen from me splitting a negative constant with whitespace. Compiling using

    clang -Wall -Wextra -pedantic -Weverything

produces a few pagefuls of warnings and makes me feel generally bad about myself. :(

Misc
====
The reported size of the source code using the size tool is very intentionally 2018.


--------------------------------------------------------------------------------
<!--
(c) Copyright 1984-2018, [Leo Broukhis, Simon Cooper, Landon Curt Noll][judges] - All rights reserved
This work is licensed under a [Creative Commons Attribution-ShareAlike 3.0 Unported License][cc].

[judges]: http://www.ioccc.org/judges.html
[cc]: http://creativecommons.org/licenses/by-sa/3.0/
-->
# Best of show

Christopher Mills <mrxo@sonic.net>  
Twitter: @MisterXopher  


## Judges' comments:
### To use:

    make
    ./prog

### Try:

    make
    ./prog
    (At the ">boot" prompt, type return)
    (At the ":" prompt, type "rk(0,0)rkunix")
    NOTE: To quit, press Control-E

### Selected Judges Remarks:

Do small machines only need small programs?  This program weighs in at just
3636 bytes, which is considerably lighter than the original machine it can replace.

This program can take you back to the start of everything, it is possible to
run v0. Just type:

    make
    ./v0

    NOTE: To quit v0, press Control-E

You will be greeted with a familiar prompt of "login". The username and
password are "dmr" and "dmr". To make things more familiar you'll need to
create '.' as it hasn't been invented yet on this image!

    @ ln dd dmr .

An "ls" will reveal that C hasn't been invented yet! IOBCC anyone? The
compiler is "bc". It producess assembly, which will then need to be assembled
together in this order "ops.s bl.s hello.s bi.s" to produce a.out!

But wait, we said this was the start of it all! This program can also run a
program that replaces an even larger machine that can run BSD 2.9. To start this,

    make
    ./prog

    (At the ">boot" prompt, type return)
    (At the ":" prompt, type "rk(0,0)rkunix")
    NOTE: To quit prog, press Control-E

This should now be very familiar and it is possible to compile and run one of
the very first IOCCC entires "mullender.c"

But wait, there is even more!  Try:

    make
    ./v6

    (At the "@" prompt, type "rkunix")
    NOTE: To quit v6, press Control-E

## Author's comments:

>   *This IOCCC entry is dedicated to the late Dennis M. Ritchie*


The Program
===========

Since this is the 25th "annual" IOCCC, I thought I should mark the occasion
with a look back to its earliest roots.  At the same time the contest enters
its 34th year of providing a safe forum for poor C code, the C language
itself is fast approching its 50th anniversary, along with the UNIX operating
system whose history is so entwined with.

The program delivered here is both a full machine emulation of the original
PDP-7 that Ken Thompson used to write the first version of UNIX and a full
machine emulation of the PDP-11/40 used by subsequent UNIXes.  The `Makefile`
can build versions that can run each of the following:

  1. UNIX v0 for the PDP-7 (circa 1969)
  2. Research UNIX Version 6 (circa 1975)
  3. BSD 2.9 (circa 1983)

For reasons to be described in a bit, the last (BSD 2.9) is the default.

Building and Running BSD 2.9
----------------------------

To run BSD 2.9, do `make` to build `prog` and then `./prog` to run it.

You should see a prompt from the first-stage bootloader that looks like

        >boot

Type `RETURN` at this point and you will get to the second-stage boot loader
that looks like

        40Boot
        :

The 40 in the prompt indicates that the bootloder has correctly determined
that we are running on a PDP-11/40.

At this point, type the rather cryptic command `rk(0,0)rkunix` -- this tells
the system to look at the first partition on the first RK05 fixed disk, find
the `rkunix` file and load it.  You should eventually see the following:

        >boot
        
        40Boot
        : rk(0,0)rkunix
        
        Berkeley UNIX (Rev. 2.9.1) Sun Nov 20 14:55:50 PST 1983
        mem = 135872
    
        CONFIGURE SYSTEM:
        xp ? csr 176700 vector 254 skipped:  No CSR
        rk 0 csr 177400 vector 220 attached
        hk ? csr 177440 vector 210 skipped:  No CSR
        rl ? csr 174400 vector 160 skipped:  No CSR
        rp ? csr 176700 vector 254 skipped:  No CSR
        ht 0 csr 172440 vector 224 skipped:  No CSR
        tm 0 csr 172520 vector 224 skipped:  No CSR
        ts 0 csr 172520 vector 224 skipped:  No CSR
        dh ? csr 160020 vector 370 skipped:  No CSR
        dm ? csr 170500 vector 360 skipped:  No autoconfig routines
        dz ? csr 160110 vector 320 skipped:  No CSR
        dz ? csr 160110 vector 320 skipped:  No CSR
        dn 0 csr 175200 vector 300 skipped:  No autoconfig routines
        vp ? csr 177500 vector 174 skipped:  No autoconfig routines
        lp ? csr 177514 vector 200 skipped:  No CSR
        Erase=^?, kill=^U, intr=^C
        # 
    
Congratulations, you are running BSD UNIX 2.9 in single-user mode as root.

On the other hand, if you did a typo somewhere, the boot loader has probably
crashed and halted -- if so, type Control-E to quit the simulation and try
again.  If you did really badly, you might have corrupted the virtual disk.
If so, consider a `make clean` to start from scratch.

Assuming you managed to type 15 characters correctly, You should be at the
root prompt.  Most of the commands you are familiar with work here (this was
only a quarter of a century ago -- how much could things have changed?).
Let's try some:

        # ls
        .cshrc       .profile     boot         hkunix       mnt          tmp
        .login       2.9stamp     dev          lib          mullender.c  unix
        .msgsrc      bin          etc          lost+found   rkunix       usr
        # df
        Filesystem  Mounted on  kbytes    used    free  % used
        /dev/rk0    /             1958    1688     270     86%
        # cc mullender.c
        # ./a.out

The program you've just run was the [winner of the first IOCCC contest from
1984] [1]  (or was it 1894?), a personal favorite of mine.  It is rather
tightly bound to running on either a PDP-11 or a VAX.  Now you have one.

Hitting Control-C will return you to the BSD UNIX prompt.  Hitting Control-D
will log you out of the single-user session and get you back to the `:login:`
prompt.  Here you can log in as `root` and get a full timesharing session.
Feel free to try things like `vi`.  I've taken the liberty of editing the
`.login` and `.profile` files to set the console to a less traditional setup
so that you don't have to wait for the Model 33 KSR teletype to move its
carriage.  I've also predefined `TERM` to `vt100`, which will probably work
well enough with whatever sort of ANSI terminal emulation you are using.

Note that I have not mounted the `/usr` disk here, so some commands from
`/usr/bin` will be missing, along with all of the `man` pages.  They are
[available online] [2] if you need them.  Adding a second RK05 disk was
possible, but I didn't get around to it...  As the Judges can no doubt attest,
"Mid 2017" creeps up on you quicker than you expect. :)

Once you've had enough fun in BSD 2.9, type Control-E to exit the emulation.

Building and Running Research UNIX v6
-------------------------------------

Research UNIX v6 and BSD 2.9 use the same executable, but require a different
disk image.  Type `make v6` to build it, then type `./prog` to run it.

You should see the boot loader prompt which is a single `@`:

        @

At this point, you again must type a special incantation: `rkunix`.  After that
you should see:

        @rkunix
        mem = 1035
        RESTRICTED RIGHTS
        
        Use, duplication or disclosure is subject to
        restrictions stated in Contract with Western
        Electric Company, Inc.
        # 

You are now running a single-user session of v6 UNIX.  You might want to start
with `stty -lcase` because otherwise everything will be IN ALL CAPS.

Again, if you failed typing seven characters without making a mistake, you
may need to use Control-E to quit the simulation.

Assuming you're more careful than that, we can try a few commands:

        @rkunix
        mem = 1035
        RESTRICTED RIGHTS
        
        Use, duplication or disclosure is subject to
        restrictions stated in Contract with Western
        Electric Company, Inc.
        # STTY -LCASE
        # ls
        bin
        dev
        etc
        hpunix
        lib
        mnt
        rkunix
        rpunix
        tmp
        unix
        usr
        # cat > foo.c
        main()
        {
            printf("Hello, World!\n");
        }
        # cc foo.c
        # ./a.out
        Hello, World!

Why is Version 6 interesting?  Well, it was the oldest version that I could
find a boot image of that had a C compiler...  This C compiler is recognizably
C, but not quite the same syntax as we have today.  It's much closer to the
[B language] [3] from which it is derrived.  In particular, this C compiler
would not be able to compile `mullender.c` (as simple as it is), because the
following syntax features don't exist yet:

  * The `short` data type doesn't exist yet.  Only `int` (`short` will show
    up when `long` comes, and the port to the Interdata 7/32 starts to make
    the idea of portability become important).
  * Hexidecimal constants don't exist yet.  Digital's computers all used
    octal.
  * The array initializer syntax hasn't yet moved to using `=`.  It still uses
    the older form taken from B, which looks like `array[] { 1, 2, 3 };`

It can still compile "Hello World!" (note that you must type a Control-D after
you finish entering the code, to let `cat` see an end-of-file).

This version of UNIX doesn't go into multi-user mode if you do a Control-D.
Single-user mode was entered because the front-panel console switches were
set to the magic number 0173030 (this can be changed with a re-compile).

Once you are done with Version 6, Type Control-E to exit the simulation.

Note that since both BSD 2.9 and UNIX v6 use the same PDP-11/40 emulation
code, and they use the same name for the disk (`rk05.fs`), if you want to go
back to the BSD simulation, you should either delete `rk05.fs` or do a
`make clean` before you do a `make`.

Building and Running UNIX v0
----------------------------

We now set the Wayback Machine to the very start of it all, 1969.

[The story] [4] here is interesting and well worth a read.  Bell Labs was
pulling out of the Multics project and Ken Thompson and his collegues had
become accustomed to the relatively nice programming environment.  They also
enjoyed the early computer game [*Space Travel*] [5] and wanted another system
to run it on.  They found a PDP-7 which was already obsolete at the time to
port *Space Travel* to.  The primitive programming environment influenced
Thompson to recreate parts of the Multics experience in the much more
hardware-constrained PDP-7 environemnt.  In the summer of 1969, with his wife
out on a month-long vacation, Thompson re-wrote a filesystem emulation he had
been experementing with to include an assembler, a shell, an editor and an
operating system kernel and hence created the first version of UNIX (although
it hadn't been named that yet).

You can try out this version by typing `make v0`.  Since this version is a
native PDP-7 emulation, it gets its own binary.  Type `./v0` to run it.  You
should see the login prompt.

        login:

There are two user accounts `ken` and `dmr`, with the passwords `ken` and `dmr`
respectively.  Let's try the Dennis Richie's `dmr` account:

        login: dmr
        password: dmr
        @ ls
        .       ?

Even though this is not Ken's doing, I feel this gives me licence to
include this quote from the BSD `fortune` program:

> Ken Thompson has an automobile which he helped design. Unlike
> most automobiles, it has neither speedometer, nor gas gauge,
> nor any of the numerous idiot lights which plague the modern
> driver. Rather, if the driver makes any mistake, a giant "?"
> lights up in the center of the dashboard. "The experienced
> driver", he says, "will usually know what's wrong."

What's the deal here?  Well, that's a slightly long story.  The short version
is we have gone so far back in the history of UNIX that *we don't have
filesystem paths yet*.  In other words, we can't say something like
`/bin/ls` yet, and the shell can't store that path in `$PATH` to search for it.
We also haven't invented `.` or `..` yet.  In fact, the filesystem isn't even
the traditional UNIX tree structure, it's a directed graph of hard links...

`ls` needs to be able to read '`.`', the current directory.  `dmr`'s home
directory doesn't have that yet, but we can make it, because the home
directory has a hard link to `dd`, which is the directory that holds all
of the user home directories (this will eventually become ``/``, the root
path).  We can do

        @ ln dd dmr .

To make the new link (note that `ln` doesn't support paths either, so you have
to give it three arguments -- a directory in the current dir, a file in that
directory, and the new name).

Now `ls` will work, and we can try some other things while we are here:

        login: dmr
        password: dmr
        @ ln dd dmr .
        @ ls
        dd      
        system  
        as.s    
        b_readme
        bi.s    
        bl.s    
        db.s    
        hello.b 
        ops.s   
        .       
        @ cat b_readme
        Here is how to compile and run hello.b:
        
          @ bc hello.b hello.s
          @ as ops.s bl.s hello.s bi.s
          I
          II
          ops.s   
          bl.s    
          hello.s 
          bi.s    
          @ a.out
          Hello, World!
        
        
        @ bc hello.b hello.s
        @ as ops.s bl.s hello.s bi.s
        I
        II
        ops.s   
        bl.s    
        hello.s 
        bi.s    
        @ a.out
        Hello, World!
        @ 

The last command is invoking the compiler for an exteremely early version of
the [B programming language] [3], the predecessor to C.  Thompson missed the
convinience of writing code in a high-level language -- Multics was written
a version of PL/1 -- and wanted the same convinience on UNIX.  He preferred
BCPL (a typeless language) to PL/1.  As Dennis Ritchie [wrote] [6]:

> B can be thought of as C without types; more accurately,
> it is BCPL squeezed into 8K bytes of memory and filtered
> through Thompson's brain.

A look at the B reference manual will show the strong correlation with C, and
shows the source of a lot of C's mysteriousness -- some of which is preserved
simply so that C could compile the *dozens* of lines of existing B code...

Thompson's assembler was also extremely simple.  It didn't even know about
opcodes -- these need to be defined in the first assembly file, with the
assembler OR-ing the opcode fields together (space was the "operator" for
logical OR).  There is no link step -- all files are provided to the assembler
on the command line, concatenated together and assembled, producing a single
`a.out` (assembler output) file.  Even after UNIX got a linker, `a.out`
remained the default name of the binary generated by the linker (and hence
also by `cc`).

This system is still has the familiarity of UNIX, with all the two- and
three-letter commands, device files, shell redirection, the same core system
calls (`read`, `write`, `open`, `close`, `creat`, `fork`, etc.).  There are a
number of differences still:

  * As noted, there are no file paths
  * `read` and `write` do I/O on (18-bit) words.  Character I/O to files needs
    to unpack those to bytes, and of course deal with `NUL` characters.
  * `exec` was performed by the shell directly.  Arguments are passed as
    four words (eight bytes), and space padded.  This matches the format for
    file names for `open` and `creat`.
  * `wait` does not yet exist.  A more complicated mechanism for sending and
    recieving messages (`smes` and `rmes`) are used instead.
  * File permission bits are all different, since groups don't exist yet.
  * User programs are not allowed to run during disk I/O.  This is because the
    disk controller's "data break" (DMA) accesses were so fast relative to the
    CPU that transfers would be dropped if an instruction that used
    "deferred" mode (indirection) was executed.  This also meant that the
    "program break" (interrupt) routine in the kernel had to specifically
    avoid deferred accesses by using self-modifying code to do indirection
    through pointers.
  * Although the PDP-7 suppoted a "trap mode" (a primitive supervisor mode),
    the UNIX kernel doesn't use it.  This means that user programs could alter
    or crash the kernel at will (in fact, there is a system call that returns
    addresses of useful kernel routines so that user code can call them
    directly).

As usual, when you are done exploring UNIX v0, type Control-E to exit the
simulator.

About the Program
=================

The program came about when I was looking for something to honor the pending
50th anniversary of the C language (because of the mercurial nature of IOCCC
contest scheduling, I chose not to wait for the actual 50th anniversary).
I had though of writing self-hosting compilers for a stripped-down version of
C, or maybe even a version of the B language...  At the same time, I was
obsessed with the idea of allowing `mullender.c` from 1984 to run.  Although
that was still a possibility on an interpreted version of B or a stripped-down
version of C, it felt cheap, as it would be `mullender.c` only in spirit.

It was during this time that I discovered that in 2016, members of the Unix
Heritage Society got access to [printouts of assembly-language source for the
original version of UNIX] [7].  With what was a [huge amount of work] [8],
they scanned in the printouts, fixed up the OCR translations, built assembler
and file system tools from scratch and made an accurate simulation of
Thompson's PDP-7 that allowed them to get the system up and running.  Although
source for the entire kernel and about half of the user-space commands were
present (including the runtime and libraries for the B compiler), the
remainder needed to be written from scratch, including the shell.  The final
results of the project are [available on github] [9].

None of this was remotely easy (as I was to discover myself).  The PDP-7 is
long gone, and the documentation for it is less complete than one would like.
In addition, the devices attached for it were a bit of a mystery.  The disk
system is referenced only in an old price list.  It was a RB09 fixed disk,
probably made by Burroughs.  It is close to what was called the RC10 for the
PDP-10, but with a different interface.  And the system also included a custom
display device called Graphics-2, which had been built in-house by AT&T.
It can't be completely ignored, because the kernel itself pokes at it (the
UNIX crew used it as a second terminal -- a "glass TTY").

I decided that implementing this PDP-7 would be possible as an IOCCC entry.

The emulator emulates the full machine:

  * PDP-7 Central Processor
  * Core Memeory Module Type 147 -- extends the core to 8,192 18-bit words
  * Extended Arithmetic Element Type 177 -- adds one's-complement
    multiplication, division and shifting
  * Real Time Clock
  * Teletype Model 33 KSR
  * Perforated Tape Reader Type 444
  * RB09 Fixed Disk Controller

The [PDP-7] [10] is an odd duck by modern computer standards:

  * 18 bit words, with no byte addressing.
  * Both one's and two's complement math (there is `ADD` for one's complement
     and `TAD` for two's complement).  The EAE is entirely one's-complement.
  * "Microcoded" instructions.
  * Auto-increment memory locations.
  * Non-reentrant function calls (the return address is stored at the indicated
    address and the PC jumps to the location after it).
  * The `XCT` instruction, that executes the word loaded from memory as an
    instruction.
  * An instruction `LAW` that loads the instruction opcode into the
    accumulator.
  * Heavy use of "inline" operands.  For instance the `MUL` instruction expects
    the second operand to be stored in memory after the instruction.  This
    pretty much requires the use of self-modifying code.
  * No immediates.  Almost all constants have to live in memory locations and
    be referenced by address.
  * Common operations, like "subtract" and "inclusive OR" are not directly
    supported on the machine and require multiple instructions and some spare
    memory locations to support.  Being clever also helps.
  * Single accumulator architecture.  No direct support for things like stacks.
  * I/O is done with dedicated I/O instructions (which are also microcoded).
  * The RB09 disk controller gets a special mention here because of its
    particularly annoying encoding of track and sector offsets in
    [packed BCD] [11].  A non-trivial amount of code space in the simulator
    is needed to convert into and out of BCD, along with an equivalent amount
    of code in the UNIX kernel itself.

The simulation handles everything I was able to discover about the PDP-7, even
things that the UNIX code itself doesn't use.  For instance, it correctly
implements the "trap mode" feature (a primitive form of supervisor mode) even
though the kernel does not enable it.  It also implements the microcoding of
the EAE instructions even though the UNIX environment uses only the standard
encodings.  If you wanted to do a 11-bit multiply instead of an 18-bit one,
it will probably work.

The simulation starts by loading a boot program off of the virtualized paper
tape, which is in a modified version of the RIM boot loader format.  The
RIM format encodes each 18-bit word as three six-bit characters, using one bit
to denote the final word (which is executed directly and is usually a `JMP` or
`HLT` instruction).  The load address comes from the console address switches.
Both of these are controlled by compile-time flags.

The emulator continues emulating instructions until it sees a `HLT` instruction
which will cause it to exit.  Console I/O is emulated by setting the terminal
into raw mode and polling via `read`.  Line-clock ticks (at 60 Hz) are done
by polling `gettimeofday`.  Dynamic frequency code arranges to reduce the
polling interval to a few polls per tick, so that simulation remains
responsive.  Since we use the real wall-clock time, this means that the
emulated system will see time advance at the correct rate.

Licencing Fun
-------------

So now I have a system that can run UNIX v0.  One problem remains...  I don't
have permission to submit UNIX v0 to the IOCCC.  It is not my code and the
copyright for it remains the property of whoever owns that part of what was
once Bell Labs -- I believe it is Nokia at this point.  I have worked around
this problem in two ways:

First, I didn't submit the source code or binary image for v0 UNIX as part of
my IOCCC entry.  I merely submitted a `Makefile` that can issue a `curl`
command to fetch a prebuilt v0 disk image from the github repository.  I am
hoping this is considered part of "Legal abose of the rules" which is supposed
to be "somewhat encouraged".  As per RULE 12, I am justifying said abuse here,
in the remarks file.

Secondly, the choice to run the UNIX v0 code is optional.  If you are worried
about Nokia's lawyers running you to ground for running a 50-year old copy
of a binary image for a machine that is almost completely nonexistant, you
can just not do so.  Delete the lines from the `Makefile` and sleep well.
You still have two other UNIXes to play with.

What about the other two UNIX variants?  These are both covered by licences
that allow me to use them.  Back in 2002, Caldera International released
Research Unix versions 1-7 and 32V under a [permissive BSD-like license] [12].
BSD UNIX is based off of v7 UNIX, and of course has its own permissive
BSD licence.  And in 2017, Nokia also released versions 8-10 under the
condition that it will not assert copyright rights for non-commercial use.

So the newer UNIXes are in the clear.  I doubt anyone actually cares about
version 0 either, but technically it's still under copyright.

PDP-11/40
---------

So if I have a PDP-7 emulator, how do I run operating systems that expect a
PDP-11?  Simple...  *I emulate a PDP-11/40 on the PDP-7*.  I have written
PDP-7 assembler code to emulate a PDP-11/40 with the following equipment:

  * PDP-11/40 (KD11-A)
  * EIS instruction set (KE11-E)
  * Memory management unit (KJ11-A)
  * Line time clock (KT11-D)
  * 124 Kwords of memory (244 Kbytes)
  * RK05 fixed disk drive (RK11)
  * Console TTY (DL11)

This required a few tweaks to the emulator.  The first problem is that the
RK05 disk is about 2.5 MB, but the RB09 is only about 2 MB.  That's easily
solveable -- just add more tracks to the RB09.  UNIX v0 is unlikely to notice
(although the number of tracks is a compile time parameter, and the `v0`
build commands set it to the correct value).

The second problem is that we are simulating a system that can have up to
124 Kwords of memory on a system with only 8 Kwords total.  That meant I needed
to virtualize the PDP-11/40's physical memory (and add a few more tracks to
the disk to hold the virtualization).

A large amount of time was spent tuning this code to be efficient.  The
memory virtualization uses part of the 8 Kword memory as an LRU cache, and
uses a number of first-level microcaches to avoid having to do the LRU updates.
This also serves to offload the complexity of the PDP-11's segmentation logic
from a large number of memory accesses (the PDP-11 does as many as eight
accesses per instruction).  Despite the super fast emulated disk, the PDP-7
code in the emulator is slow, mostly because it has to do a bunch of divides
to convert the linear disk offset into a BCD-coded track and sector for the
emulated RB09.  I/O polling is again used, except this time it uses the
PDP-7's  "skip on flag set" I/O instructions.  As with the PDP-7 emulator
itself, the PDP-11 emulator dynamically measures the instruction throughput
relative to the line-clock tick, so that it only polls for I/O a few times
per tick.

The one remaining problem is building the disk images themselves.  Since the
PDP-11's disk is 16-bit, but the PDP-7's is 18-bit (which the emulator stores
in 32-bit `int`s), a conversion program is needed to unpack the binary disk
images from 16 bits per word to 32.  This in turn needs to be done in the
`Makefile` using standard POSIX tools, which aren't exactly good with binary.
I had a wierdly clever way to do this with `od`, `awk` and `uudecode` that
I will leave as an exercise for the curious, but I decided it would be easier
to do it with the PDP-7 emulator itself, feeding a simple program in on its
boot tape.  This required an additional tweak to the emulator, since by default
its console TTY is not eight-bit clean (in fact, UNIX v0 expects to see the
MSB set on the terminal reads, and sets it on writes, what is called "mark"
parity).  This is also enabled by a compile-time setting (used only for the
`builddisk` program).

Despite the complexity of the PDP-11 instruction set and its emulated I/O
devices and the corresponding primitiveness of the PDP-7's instruction set,
the emulation itself is a suprisingly small amount of code, not really taxing
the 8 Kword memory, with about 2.25 Kwords of actual code and a similar
amount of space for the memory virtualization cache and disk block buffer,
leaving nearly half (3.5 Kwords) of the memory unused.  The simulator executes
somewhere around 250 PDP-7 instructions per PDP-11 instruction.  On my laptop,
the PDP-7 is running somewhere in the neighborhood of 70 MIPS, which means the
PDP-11 is running at about 0.3 MIPS, which is probably not too far off of its
actual speed (the cycle time of an 11/40 was around a microsecond for simple
instructions, but could be proportionally larger for instructions that did
multiple memory accesses, which many did).

As an aside, although the idea of emulating the PDP-11 on an emulated PDP-7
came about from the realization that I needed a response to the late-discovered
licence issue, I'm quite pleased with the result -- it enables an interesting
window on the dawn of the UNIX era.  I feel that someone should complete the
circle here by emulating a VAX 780 on the PDP-11 and run 4.2BSD on it, so that
we can get the [original runtime environment used for the first IOCCC] [13].

Compile-time Options
--------------------

The following command flags control the compilation:

  * `-DI="image.fs"`: Name of the disk image file.  This must be created
     offline, and be of the correct size to avoid segmentation violations.
  * `-DA=4096`: Setting of the console address switches.  This tells the RIM
    bootloader where to load the boot image.
  * `-DS=0`: Setting of the console data switches.  The PDP-7 emulation can
    read these with the microcoded `OAS` (OR switches into AC) instruction.
    By proxy, the PDP-11 emulation can read them via the `CSW` device.
  * `-DW=MAP_PRIVATE`: This sets the memory mapping for `mmap`.  Setting to
    `MAP_PRIVATE` makes the disk image be copy-on-write.  Setting it to
    `MAP_SHARED` makes the disk image be sharable.  Do the latter if you want
    to preserve the disk contents between sessions.
  * `-DT=`: List of initializers for the `termios` structure.  The v0 UNIX
    expects the terminal to be in half-duplex mode, echoing its input, with
    swapped CR and NL.  The PDP-11 UNIXes don't.
  * `-DX=5`: The ASCII code of the control character that causes the simulation
    to abort.  If set to 0, there is no abort code.
  * `-DY=128`: Controls console I/O parity.  If set to zero, the console is
    eight-bit clean.  If set to 128, the high bit is set on keyboard reads and
    masked off on printer output ("mark" parity).  UNIX v0 expects the latter.
  * `-DV=270`: The size of the disk, in tracks.  The UNIX v0 disk has 200
    tracks (each has 80 sectors of 64 18-bit words).  The PDP-11 UNIXes
    increase this to 270, to allow for the larger RK05 disk emulation
    (406 tracks of twelve 256-word sectors), plus the space for the 124 Kwords
    of virtualized memory and the 8 Kwords of emulator code.
  * `-DP="xxx"`: RIM bootstrap program paper tape image.  Be careful with the
    quoting here -- there is at least three levels going on.  In particular,
    you will need to escape `$` as `$$` to protect it from `make`.

What is the ASCII art supposed to be?
-------------------------------------

The ASCII art represents a torn piece of [paper tape] [14].

Acknowledgements
----------------

None of this could have been possible without the hard work of

  * Warren Toomey and the other members of the
    [The Unix Heratage Society] [15]
  * Robert M. Supnik and the other contributors to [SimH] [16], the simulator
    for historic computer architectures.  The number of times I needed to
    "Use the Source, Luke" on SimH to unravel some dark corner of these
    machines was uncountable.
  * [Bitsavers] [17], which acquired, scanned and preserved all the manuals
    I spent many hours squinting at.
  * Ken Thompson, Dennis Ritchie, Brian Kernigan, M\. D\. McIlroy, J\. F\.
    Osssanna, Rudd Canaday and the other members of the Bell Labs
    Computing Science Research Center who were responsible for the invention
    of UNIX, the C programming language, and the innumerable other innovations
    that we now take for granted as part of the modern software landscape.
    In particular, the [home page of the late Dennis Ritchie] [18] contained
    a trove of useful information on the evolution of UNIX and C and is
    recommended for perusal by others who share my peculiar retrocomputing
    affectations.

Finally, thanks to my spouse for putting up with the many hours I spent on this
nonsense, and treating "I'm working on my IOCCC entry" as an acceptable answer
to queries about how I was spending my free time.  Similarly, I apologise to
those friends and coworkers who had to listen to me complain about obscure
corner-case bugs in my code.  The obsession is over, at least until next
time...

-------------------------------------------------------------------------------

[1]:  http://ioccc.org/1984/mullender/mullender.c            "mullender.c"
[2]:  http://minnie.tuhs.org/cgi-bin/utree.pl?file=2.9BSD    "2.9 BSD"
[3]:  https://www.bell-labs.com/usr/dmr/www/kbman.html       "B Language"
[4]:  https://www.bell-labs.com/usr/dmr/www/hist.html        "UNIX history"
[5]:  https://www.bell-labs.com/usr/dmr/www/spacetravel.html "Space Travel"
[6]:  https://www.bell-labs.com/usr/dmr/www/chist.html       "C History"
[7]:  http://www.tuhs.org/Archive/Distributions/Research/McIlroy_v0/ "V0 Scans"
[8]:  http://minnie.tuhs.org/Y5/wkt_hapop_paper.pdf          "UNIX v0"
[9]:  https://github.com/DoctorWkt/pdp7-unix                 "PDP-7 UNIX"
[10]: http://bitsavers.trailing-edge.com/pdf/dec/pdp7/F-75P_PDP7prelimUM_Dec64.pdf "PDP-7 Manual"
[11]: https://en.wikipedia.org/wiki/Binary-coded_decimal     "BCD"
[12]: http://www.tuhs.org/Archive/Caldera-license.pdf       "Caldera Licence"
[13]: https://groups.google.com/forum/?hl=en#!msg/net.lang.c/lx-TAuEyeRI/HdOOnNx6LC0J "First annual IOCCC announcement"
[14]: https://en.wikipedia.org/wiki/Punched_tape             "Paper Tape"
[15]: http://www.tuhs.org                      "The Unix Heritage Society"
[16]: http://simh.trailing-edge.com            "SimH"
[17]: http://bitsavers.trailing-edge.com       "Bitsavers.org"
[18]: https://www.bell-labs.com/usr/dmr/www/   "DMR Homepage"


--------------------------------------------------------------------------------
<!--
(c) Copyright 1984-2018, [Leo Broukhis, Simon Cooper, Landon Curt Noll][judges] - All rights reserved
This work is licensed under a [Creative Commons Attribution-ShareAlike 3.0 Unported License][cc].

[judges]: http://www.ioccc.org/judges.html
[cc]: http://creativecommons.org/licenses/by-sa/3.0/
-->
# Best tool to reveal holes

Yusuke Endoh  
Twitter: @mametter  


## Judges' comments:
### To use:

    make
    ./prog < textfile > output.gif

### Try:

    ./prog < golem.txt > golem.gif
    ./prog < smily.txt > smily.gif

### Selected Judges Remarks:

To get the best experience, use a GIF viewer that can handle animated gifs.
On OS X you can use Safari using "open -a Safari smily.gif"

Some things to consider are that this 2.5KiB gem encodes a 96 character 8x8
font (naively this could already take 6144 bytes) and a GIF encoder.  But
how does it know which characters are closed?

You should only give this program printable ASCII characters.

Unfortunately this won't run on your PDP8, if you had one, as it needs at
least 2MiB of memory to run in.

## Author's comments:
This program generates an animated GIF from a plain text.  Run:

    gcc -o prog prog.c
    ./prog < invisible.txt > invisible.gif

Open invisible.gif and then wait a minute.  You will see a hidden message.
Can you tell the difference between letters that leaves the mark and ones that does not?

Other examples:

    ./prog < golem.txt > golem.gif
    ./prog < smily.txt > smily.gif

The program itself has a hidden message.

    ./prog < prog.c > prog.gif

--------------------------------------------------------------------------------
<!--
(c) Copyright 1984-2018, [Leo Broukhis, Simon Cooper, Landon Curt Noll][judges] - All rights reserved
This work is licensed under a [Creative Commons Attribution-ShareAlike 3.0 Unported License][cc].

[judges]: http://www.ioccc.org/judges.html
[cc]: http://creativecommons.org/licenses/by-sa/3.0/
-->
# Best abuse of the rules

Dave Burton  
<http://ioccc.snox.net>  


## Judges' comments:
### To use:

    make

    ./prog [-tcksri] < file.c

### Try:

    ./prog -i < prog.c
    ./prog -s < prog.c
    ./prog -sk < prog.c

If you get stuck, try:

    make test

If you get really stuck, try:

    man ./tac.man

### Selected Judges Remarks:

They say size isn't everything, and in the case of IOCCC [iocccsize.c](http://www.ioccc.org/2018/iocccsize.c)
that is saying something!  What is this program weighing and how much does it weigh?


## Author's comments:
tac - tokenize and count C and derivative languages
---------------------------------------------------

<blockquote><pre style="font-style:italic">
tac computes C program size  
(obfuscated / otherwise)  
by splitting code as tokens small,  
ignoring space, then counting all.  

It tries quite hard to act the same  
as counting tool of I-OCCC fame.  
Some bugs were fixed, it's faster too,
and does more things, just add some glue!  

It does far more than print the size:  
the token part's a better prize!  
With each upon on a single line,  
how many things can you design?  

Included is a keyword sorter,  
de-obfuscator, freq reporter.  
With code produced as little parts,  
just add your own creative arts.  

But first you have to figure out  
the braces part, without a doubt!  
And then the code - it isn't easy:  
for as else?  That's rather cheesy!  

The rest of it is standard fare:  
expressions strange, the globals bare,  
confusing symbols one and oh,  
and precedence you have to know.  

The keyword list was made external,  
because of standards change eternal.
Thus other languages can now,  
be counted just like C, somehow!  

I hope you find this code obscure  
enough to win, and thus procure  
a public place for all to see  
how badly I can butcher C!  
</pre></blockquote>

Said another way....
--------------------

`tac` is the inverse of `cat`(1): it un-concatenates its input into C tokens,
writing the token stream to stdout.  There are options to suppress the token ids,
summarize the token counts, and several options to allow it to be compatible
with `iocccsize`.

The token-based output is quite useful in analyzing source code (see below),
and the counter is more accurate than `iocccsize` (see below); but this can be
fixed by using the -c compatibility flag, restoring the following problems as
in the official tool:

* whitespace **within** a string is **not** counted;
  this seems wrong, as these chars **are** significant
* "`{;}`" is not counted within a double-quoted string
* whitespace preceding a comment is char-counted, unless the comment starts a line
* -k processes the reserved words within `//` comments(!), but not `/*`, changing the counts

The following bugs are always corrected:

* treats `/*/` as a complete comment (`/*/int if for/*/` has three keywords)
* -k enables `//*` or within a line comment `/*` to initiate a comment block until following `*/`
* -k processes double quote characters in `//` comments -
  thus a solitary quote consumes everything until the next quote
* single quotes are not handled correctly (`'"'` starts a dquote in `iocccsize`)
* `#ifndef` is omitted as a keyword (but `#ifdef` is allowed?)
* I is not a reserved word.
* `tac` correctly penetrates [23rd century cloaking technology][1]. ;-)

There is one (known) remaining problem with detection:

* comments between preprocessor hash and keyword are not replaced with whitespace;
the following counts #include as two tokens, `#` and `include` (not as a reserved word):

		#/*this will not be counted*/include/*correctly*/<stdio.h>

Fixing this properly hampers backwards compatibility in counting.  This requires
eliding comments during readsource (ISO 5.1.1.2, phase 3), and yet still
counting words correctly absent -k.

[1]: http://ioccc.org/2014/birken/hint.html "Best use of port 1701"

Backwards Compatibility
-----------------------

`tac` was run over all 366 previous IOCCC winning entries:

	find ~/src/obc -type f -name \*.c | wc

The discrepancies found are documented and explained in the file "discrepancies".

	find ~/src/obc -type f -a -name "*.c" | xargs ./spotcheck ./prog | ./spotdiff |
		grep -v keep | diff -bw - discrep* | grep "[<>] cl "

In summary, there are only 6 unique entries out of 366 that have any variation
in Rule 2 counts; in all cases, the differences are due to bugs within
`iocccsize`, described in detail in the file `discrepancies`.  There are only 40
files (40/366, ~11%, including originals and variations) that differ at all, 31
only in word count; most word count differences appear related to comment block
detection, weighted more towards recent entries (2011 and onward = 20/40 ~50%).

This (minor) variation in word count values has not been addressed since
it is not a qualifying metric, nor is it very useful in a programming context:
whitespace surrounds English words, not necessarily C tokens, as in `a+=1;`.

Accuracy (versus compatibility) is demonstrated through a series of small test cases
designed to allow exhaustive, hand-counted values for comparison with the tool values.
These test cases were vital in debugging and regression testing, and provided a way to
determine which tool was correct when there were differences.

> A version of this tool in more clearly written C (tac.c)
> is presented for the Judge's consideration as a more accurate replacement for `iocccsize`.
> This obfuscated entry is derived from (and compatible with) that code,
> but due to obfuscation, has had some significant, deep changes for the contest.
> Nevertheless, the more clearly written code remains a spoiler for this entry.

NB: `iocccsize` gets a different answer from `tac` on its own (iocccsize.c) source code;
`tac` gets the correct answer.  This is due to the aforementioned bugs within `iocccsize`,
proved by fixing iocccsize.c with the included patch, so `iocccsize` reports
the correct answer for itself.

But wait... There's More!
-------------------------

There is no limit on line length, file length, comment length, or identifier length.

`tac` features an accurate tokenizer; which presents each C token on a line by itself.
This feature enables interesting analyses of C (and C++) code, hard to get any other way.

For instance, here is a simple token counter, useful in finding repeated long tokens, or operator
frequency, or counting the references to identifiers, constants, or breadth of use of the
language:

	!/bin/sh
	cat $* | ./prog -t | sort | uniq -c | sort -k1nr

And here is a C keyword frequency counter:

	#!/bin/sh
	function iskeyword {
	   awk 'BEGIN{f="c11";while(getline<f)k[$1]=0}
		{if($1 in k)k[$1]++}END{for(i in k)print k[i],i}'
	}
	cat $* | ./prog -t | iskeyword | sort -k1nr

This script was used to "optimize" the reserved word order so the most frequent IOCCC
winning entry keywords are checked first.

> An interesting aside: as might be expected, obfuscation has changed the frequency of
> keyword distribution over time.  The top five for the decades:
> 
>       1980s       1990s       2000s       2010s
>         -----       -----       -----       -----
>         94 if       532 char    375 if      254 int
>         69 for      524 if      372 char    217 for
>         59 while    417 int     332 int     198 if
>         48 char     223 for     184 for     121 return
>         43 int      223 void    165 return  104 char

The keyword list is external to the program, and is easily changed, sorted, checked, verified.
This allows such additional programs in concert with the tool's primary operation.

A poor-man's de-obfuscator can be based upon the output of `tac -t` and a handful of
simple rules (and another use of the external keyword file).
A more refined version of this is included in the file `unob.sh`,
but the simple code below is a serviceable obfuscated C de-obfuscator in a _scripting language_.
It really is this easy with `tac`:

	#!/bin/sh
	script='
	BEGIN {
		last=nl="\n";
		f="c11"; while(getline <f > 0) kw[$0]++; close(f);
	}

	function iskw(a)   { return a in kw }
	function indent(a) { return sprintf("%*s", n*3, " ") }
	function newline() { if (!infor && last != nl) printf last=nl; }
	function show(a) {
		if (last==nl) printf "%s", indent()
		printf "%s%s", space(), a
		last=a
	}
	function space() {
		return iskw(last) ||
		  (last ~ /[A-Za-z0-9_+-\/%^[&\]\)=:<>;]$/ && $0 !~ /[:;()\[\],]/) ? " " : ""
	}

	/^\(/	{ ++paren }
	/^\)/	{ --paren }

	/^for/		    { newline(); infor=1 }
	infor && /^;/	    { ++infor; show($0 " "); next }
	infor==1 && /^:/    { ++infor }
	infor>1 && paren==0 { infor=0 }

	/^\?/		{ tern++; n++; newline(); show($0 " "); next }
	tern && /^:/	{ newline(); show($0); --tern; --n; next }

	/^#/	{ newline(); show($0); newline(); next }
	/^;/	{ show($0); newline(); next }
	/^{/	{ show($0); ++n; newline(); next }
	/^}/	{ n--; newline(); show($0); newline(); next }

	{ show($0) }
	'
	cat $* | sed 's/#include/##include/' | cpp -E -trigraphs |
	sed 's/^# .*$//' | sed 's/^#//' |
	./prog -t | awk "$script"

On the question of obfuscation
------------------------------

* I assume you noticed the [braces][2]?

  _Every brace is sacred,  
  Every brace is great.  
  If a brace is wasted,  
  Clang gets quite irate_.

* Keywords follow the 2010s top five, without the `if`, for interesting flow control.
* Sometimes a `for` can be an `else` - [inconceivable][3]!
* I see the `getopt`.  But "[where's the beef?][4]"
* No character constants, several int constants, and one string
  (hint: which does not encode letters) -- how does this code parse code?
> Interesting aside: how many is "several int constants"?
>
>        ./prog < prog.c 2>/dev/null | awk '$1~/260/{a[$2]++}END{for(i in a)print i,a[i]}'
>        ... | wc
>
> Which numbers are most often used?
>
>        ... | sort -k2nr | sed 5q

* The code describes its function by careful arrangement of variables up front...
* ...coupled with a description of the typical IOCCC contestant, or at least the author
* Why shouldn't trigraph parsing be written in trigraph?
* Where iocccsize.c mocks, this code flaunts:
  "_no matter how well you may think you understand this code, you don't, so don't mess with it. :-)_"
* `O,0,l,1` are used to confusing effect, local names obscure global names.
* Globals are used to pass information between routines: don't reorder "unrelated" statements....
* How does the compatibility mode account for the fundamentally different manner of computation?
* The algorithm is quite efficient; reserved word detection and trigraph parsing particularly so.
* This may be the first obfuscated submission that provides the means for its own de-obfuscation.

[2]: https://www.youtube.com/watch?v=fUspLVStPbk&start=53 "Meaning of Life"
[3]: https://www.youtube.com/watch?v=OHVjs4aobqs "Inconceivable"
[4]: https://www.youtube.com/watch?v=Ug75diEyiA0 "Where's the beef?"

Rule 2
------

The keyword list is externalized as an include file.  This presents a useful
feature for the source code: not only can the reserved word script above be
produced, but the tool can be rebuilt with any set of reserved words, just by
using a different list.  For instance: removing all the secondary keywords;
removing all the C11 keywords; trying just K&R C.  Since C++ and Java share the
same operators as C, just change the keyword list and `tac` will correctly
tokenize both of these; the tokens >>> and :: can be handled with a short
post-filter (tokenfix, included).

I believe this entry may also satisfy the request for gratuitous use of all the C11 keywords?
Whether this context satisfies "intended C language context" is a matter of interpretation. ;-)
And `tac` is ready for the IOCCC++ contest.  And the IOJCC trashcan.

The following reserved word files are included:
	
	kandr   from my venerable 1978 18th printing "The C Programming Language"
	v7unix  7th edition Unix source code, extracted from c00.c
	kandr2  from my 1988 1st printing "The C Programming Language", 2e
	ansi    ANS X3.159-1989
	c99     ISO/IEC 9899:1999(E)
	c11     ISO/IEC 9899:201x(E) N1570
	c++98   http://en.cppreference.com/w/cpp/keyword
	c++11   ISO/IEC 14882:2011(E) N3337 2012-01-16
	c++14   ISO/IEC 14882:2014(E) N4296 2014-11-09
	java8   http://docs.oracle.com/javase/specs/index.html
	ioccc.kw.freq   c11 + additional words, sorted on frequency of occurrence in ioccc winners

NB: The keyword file used in this code is derived from the list in iocccsize.c,
which is neither complete (`#define`, `#ifndef`, `#undef` are missing
-- yes, Virginia knows about `#define` omitted on purpose),
nor correct (many more are added: `I`, `true`, `bool`, `compl`, ...):

	(sed -n '1p' c11; sed -n '2,$p' ioccc.kw.freq | sort) | comm -3 - c11

That is an obfuscated way to say "diff".  But it also more clearly shows the, um, diffs.

The usage string is similarly externalized, providing a better usability string than
the limits would otherwise allow.  If this is considered bending the rules too far,
just -DU=O to get a passible, if cryptic, usage message using no additional octets
than without the define.
This also allows the builder to configure the amount of help a utility should provide
([you want a manpage? Because that's how you get a manpage.][5])
-- a rather significant point of contention made moot.

There is definitely abuse of the Rule2 counter, exploiting a "feature" of `iocccsize`:
`iocccsize` does not Rule2 count {, } and ; when followed by whitespace -- even within a string!
Thus: Freecode, a simple, uncounted, highly obfuscated encoding of a central part
of this program.  (The reserved word list is not Freecoded, both because it is useful
apart from the program, and because Freecode is not entirely free.*)

* Some restrictions apply.  Not approved for all uses.  Some assembly required.

[5]: https://www.youtube.com/watch?v=VU0GYSA1POs "Ants"

Compilation
-----------

The code is ANSI compliant, but it does have a string longer than 509 characters.
It has been tested on OSX and Linux, Clang and GCC.

The code uses trigraphs, ironically: it parses trigraphs with trigraph code.
Because that's funny.  And it remains obscure after, so trigraphs are not used for obfuscation.
Thus -trigraphs -Wno-trigraphs (which is also humorous).

It's obfuscated C.  Thus -Wno-parentheses -Wno-empty-body -Wno-char-subscripts.

The code uses unsigned chars, but C strings are signed.  Thus -Wno-pointer-sign.
NB: This is *not* a portability concern, the one string holds only printable ASCII characters.

Thus:

	clang -ansi -Wall -trigraphs -Wno-trigraphs -Wno-parentheses -Wno-empty-body -Wno-char-subscripts -Wno-pointer-sign -DU=O -DW=\"keywords\" -o prog prog.c

Coda
----

Cody Ferguson was relentless in his pursuit of bugs.
Thanks to his reports, the version of `unob.sh` is stronger,
`tac` groks digraphs, `tokenfix` corrects for missing digraphs in `prog.c`,
and the program `manpage` was added to the corpus.

`manpage` is a useful program that turns ASCII versions of man pages (e.g. `tac.man`) into real
man pages.  It works for C and C-like languages, command lines,
and was designed to handle man page sections 1-8.
It works well on most inputs, but tends to need some raw nroff for more fancy constructions,
such as combined arguments
(e.g. the -r and -s arguments to tac are not recognised when written as -rs in prose).

Try:

	manpage tac

	manpage -h
	manpage -h | manpage
	manpage -h | manpage -R | less
	manpage -h | manpage -P | lpr

--------------------------------------------------------------------------------
<!--
(c) Copyright 1984-2018, [Leo Broukhis, Simon Cooper, Landon Curt Noll][judges] - All rights reserved
This work is licensed under a [Creative Commons Attribution-ShareAlike 3.0 Unported License][cc].

[judges]: http://www.ioccc.org/judges.html
[cc]: http://creativecommons.org/licenses/by-sa/3.0/
-->
# Most stellar

Timo Poikola <ioccc2018@ig.fi>  
<https://ig.fi/>  


## Judges' comments:
### To use:

    make

    ./prog

### Try:

On terminal supports 24 bit color, has black background, and size at least 125x38, try:

    ./prog

### Selected Judges Remarks:

It is said by some students of Astronomy:

    Oh, Be A Fine Gal, Kiss Me!
    Oh, Be A Fine Gentleman, Kiss Me!

Many [Mnemonic variations](http://www.star.ucl.ac.uk/%7Epac/obafgkmrns.html) exist.
You might wish, on a star, to better understand the colors being displayed.
And those in the deep south might wish to go north for a better view.


## Author's comments:
### How to build

    gcc -o prog -std=gnu11 -O3 prog.c

or

    make

### Poster

You can generate an A3 sized poster by _make docs_. This command creates a pdf file _poikola.pdf_.

### What this entry does
#### Introduction
It was a starry night when my wife pointed her finger up and asked: "What is this star and may I have some Easter eggs?"

So I had to sit down and solve those tricky questions with Nano and a C compiler.

#### Little spoilers
Basically, the program draws animated ASCII art of the Big Dipper using Annie Jump Cannon's spectral classification system of stars and I think the
colors of the output are as accurate as possible.

This program also tells once in a year if it is correct time to find and eat some Easter eggs.

The program has also at least three other functions, obvious and not so obvious.

#### Technical jargon
This program has been tested on xterm and Konsole and also Linux virtual terminal. Color support in the terminal is not necessary, but the effect is better with it.
This entry has partial support for terminals with a white background but the best viewing experience is achieved when the terminal in use supports 24-bit colors,
has a black background and the size is at least 125x38.

Special note for Mac users: __Terminal__ does not work as expected you might need xterm from XQuartz or some other
working terminal. Thanks to Dave Burton for spotting this problem.

The main reason for the header `unistd.h` is `getdelim()` but once I included it I also abused other functions and defines. This header is mutually exclusive with _-std=c11_.

The program was developed with little-endian machines; I tried to support big-endian too, but this support is somewhat limited.

This program has been compiled in

1. i386 (Debian Stretch) with gcc and clang
2. amd64 (Debian Buster) with gcc and clang
3. Raspberry Pi 3 (Debian stretch) with gcc and clang
4. Lego Mindstorms EV3 Intelligent Brick (Debian Jessie) with gcc and clang (in this case, compiling time with clang-3.5 12 seconds and with gcc 27 seconds)

### Warnings and restrictions required by law
Please do not feed little babies chocolate.

### Major spoilers
<div style="margin-bottom:61em;">&nbsp;</div>

I incorporated the Fletcher 16 checksum algorithm into the source for security reasons; it might be challenging to make changes without breaking the main functionality of the code.
The space after `#define p return` is necessary.

The computus uses an algorithm described in the journal Nature in 1876. It should be valid for Gregorian calendars.

#### Some obfuscation techniques used

1. I tried to use meaningless or misleading variable names. For example, this program draws the Big Dipper with the correct colors, but variables
like `o`, `b`, and `a` are used in totally unrelated tasks.
2. I reused and recycled variables almost every time when possible.
3. Unnecessary use of predefined stuff like `__ATOMIC_SEQ_CST`.
4. When I was a kid, my favorite programming language was Pascal. In Pascal, there are things like `begin;` and `end;` instead of curly brackets.
They are used also in my code, but I had to shorten them to meet size requirements.
5. I also have strong Perl background,
and therefore I added some dollar signs to the code. One of the first ideas was to
write all variables with prefixed `$`, but then I rejected it.

If you think you understand how this program works, can you answer these questions:

1. What is the value of `aI_` after line 21?
2. Why are there some big numbers on line 47?
3. How is the scaling effect created?
4. How do you change a single bit, without changing the functionality?


### Rot18ed part
Because the rot13 is too easy to decode with the plain eyes, I decided to use the Caesar cipher with the key 18.

Lzw xajkl tsffwj ak wfugvwv mkafy AWWW 754 xdgslk gf dafw 47. Al ak hjaflwv gfdq gf dalldw-wfvasf esuzafwk.

--------------------------------------------------------------------------------
<!--
(c) Copyright 1984-2018, [Leo Broukhis, Simon Cooper, Landon Curt Noll][judges] - All rights reserved
This work is licensed under a [Creative Commons Attribution-ShareAlike 3.0 Unported License][cc].

[judges]: http://www.ioccc.org/judges.html
[cc]: http://creativecommons.org/licenses/by-sa/3.0/
-->
# Most inflationary

Fabrice Bellard  
<https://bellard.org/>  


## Judges' comments:
### To use:

    make
    ./prog > lena.ppm

### Try:

    eog lena.ppm # On Linux
    preview lena.ppm # On MacOS

    wget http://upload.wikimedia.org/wikipedia/en/2/24/Lenna.png
    pngtopnm < Lenna.png | pnmscale 0.25 | cjpeg -arithmetic -dct float -quality 14 > small.jpg

The file `small.jpg` will be approximately of the same size as the raw image data
in the program. Compare the level of the detail and the artifacts of
`small.jpg` and `lena.ppm`.

### Selected Judges Remarks:

Compressing images is just a matter of simple arithmetic and some magic, isn't it?

We could understand some of the arithmetic but none of the magic.

Deciphering the mechanism used for data encoding to make use
of the whitespaces, braces and semicolons should be a slightly easier task.


## Author's comments:
This program outputs a 128x128 RGB image file to the standard output
using the portable pixmap file format (PPM). It contains the famous
"Lena" image which is used in many image compression tests. 

The uncompressed image is 12 times larger than the source code of the
program which includes the image data and the complete decoder. The
actual image data is 1220 byte long, which gives a compression ratio
of 40. Using a JPEG-like algorithm would not be enough to reach this
level of compression (the Lena image would be barely recognizable). So
the algorithm is based on the latest advances in image compression. It
includes the following features:

- DCT transform with variable block size (4x4, 8x8, 16x16 and 32x32)
- DC and directional predictors
- arithmetic coding
- YCgCo color space.

The image data is encoded to a C string with some tricks to make the
best use of the IOCCC size constraints. The identifiers were shortened
to a single letter to save space. No specific obfuscation was needed
as the algorithms already have a significant complexity.

Although the program was optimized to decompress its built-in image,
it accepts to decompress image files from its standard
input. Examples:
  
    ./prog d < lena512.bin > lena512.ppm
    ./prog d < fruits.bin > fruits.ppm
    ./prog d < vintage_cars.bin > vintage_cars.ppm

The original images for [fruits][1] and [vintage cars][2] come from
Wikipedia and were resized to a width of 1024 pixels. Warning: the
program is not protected against invalid input.

The program should be portable on any Unix system. On Windows the line
"_setmode(0, 32768); _setmode(1, 32768);" must be added at the start of
the main() function to avoid unwanted carriage return characters in
the output.

--------------------------------------------------------------------------------

[1]: https://commons.wikimedia.org/wiki/File%3AFruits_oranges%2C_jardin_japonais_2.JPG
[2]: https://commons.wikimedia.org/wiki/File%3ARed_Bull_Jungfrau_Stafette%2C_10th_stage_-_vintage_cars_%282%29.jpg

--------------------------------------------------------------------------------
<!--
(c) Copyright 1984-2018, [Leo Broukhis, Simon Cooper, Landon Curt Noll][judges] - All rights reserved
This work is licensed under a [Creative Commons Attribution-ShareAlike 3.0 Unported License][cc].

[judges]: http://www.ioccc.org/judges.html
[cc]: http://creativecommons.org/licenses/by-sa/3.0/
-->
# Most likely to top the charts

Qiming HOU  


## Judges' comments:
### To use:

    make
    ./prog < input.json > output.html

View `output.html` in a browser.

### Try:

    grep -e '[-?+*/^&|.<>=]' prog.c

    (cd ..; ls -lS */prog.c) | \
    awk 'BEGIN { print "["; } { print "{\"winner\":\"",$9,"\", \"size\":",$5,"},"} END { print "]"}' \
    > ioccc.json
    ./prog < ioccc.json > ioccc.html

What's not right with the output? How to fix it?

### Selected Judges Remarks:

This entry exhibits a way of obfuscation we haven't seen before, we think.
The rulez of programming in an imperative language are violated, aren't they?

Try figuring out how to increase the number of different colors, if you can.


## Author's comments:

Nowadays almost every programmer needs to do some Web chore. With all the open source stuff readily available, often we just need to call a bunch of libraries to generate an HTML page from a JSON feed.

This entry takes such decadence to an extreme. It just calls a bunch of libraries to generate an HTML page from a JSON feed, literally. There is no variable (function parameters included), no operator, no flow control statements except a few decorative returns. In compliance to production coding standards, the code is littered with fashionable jargon, doxygen comment, and license text.

As one would expect from such an approach, this program is much more resource intensive than it should be. And one needs a C99-compatible libc (with the common UNIX stuff) to build this and an HTML5-compatible browser to open the result. And it terminates with an assertion failure, but who cares if the web page is already generated?

--------------------------------------------------------------------------------
<!--
(c) Copyright 1984-2018, [Leo Broukhis, Simon Cooper, Landon Curt Noll][judges] - All rights reserved
This work is licensed under a [Creative Commons Attribution-ShareAlike 3.0 Unported License][cc].

[judges]: http://www.ioccc.org/judges.html
[cc]: http://creativecommons.org/licenses/by-sa/3.0/
-->
# Most able to divine code gaps

Derek Anderson  


## Judges' comments:
### To use:

    make
    ./prog < textfile

### Try:

    ./prog < prog.c
    ./prog < prog.orig.c
    ./prog < hint.text

### Selected Judges Remarks:

With this entry, you won't need to turn your monitor [upside down](http://en.wikipedia.org/wiki/River_%28typography%29)!

Compare `prog.c` and `prog.orig.c` and find out why we had to modify the entry, and what confused the author
(see the author's remarks). No, it was not the shape of the Roman V that we, or the compiler, didn't like.


## Author's comments:
## Compiling the program

    gcc -Wall -Wextra -Wpedantic -O3 -std=c11 prog.c -o prog

Also works with a standard of c99, but c90/c89 will not compile due to
for loop initial declarations, along with additional warnings about
variable length arrays and lack of a return statement.

## Additional info

This small program, when given text on stdin, will produce a pattern of
squiggly lines. This pattern is deterministic, and it shouldn't be too
difficult to determine from whence they come. There is even a comment
that describes the highlighted phenomena in the source, for those that
require a small nudge. With denser text blocks, such as an essay or
similar prose, the output can be rather pretty, in an chaotic emergence
sort of way. Try using this file, or the source file as inputs.

In its current form, this program can handle lines of length 255; to
adjust this limit, change the variable `a` at the top of the source.
Other adjustments, such as the exact printed characters, are rather
easy, once sufficient reverse engineering has occurred. Improvements
such as proper handling of tabs are left as an exercise to the reader.

In developing this program, the author found a potentially interesting
bug. If the expression `(j=k,j)` (near the middle of the source) is
changed to `(j=k,k)`, the program produces different output. The author
used compiler gcc 5.4.0, compiled for x86_64-linux-gnu. Enabling or
disabling optimization produces the same results. The author is not
sure who is the culprit, but instead shrugged and moved on with life.
Of course, YMMV with your own environment.

The structure of this program, as you may have deduced, is two for
loops, one nested in the other. There is also a bunch of direct
variable assignment, such as `j=k`. There is some filler fluff, such as
`0-0+0`, but all that sort should be rather easy to spot. It was mostly
added for the purpose of making certain things line up right, and only
secondarily to obfuscate.

--------------------------------------------------------------------------------
<!--
(c) Copyright 1984-2018, [Leo Broukhis, Simon Cooper, Landon Curt Noll][judges] - All rights reserved
This work is licensed under a [Creative Commons Attribution-ShareAlike 3.0 Unported License][cc].

[judges]: http://www.ioccc.org/judges.html
[cc]: http://creativecommons.org/licenses/by-sa/3.0/
-->
# Most unstable

Edward Giles  


## Judges' comments:
### To use:

    sudo apt install libsdl2-dev  # Linux
    Something else # MacOS
    make
    ./prog

### Try:

    ./prog ioccc.txt
    ./prog prog.c

### Selected Judges Remarks:

Can you explain the behavior of the program when ioccc.txt is given to it as input?

How would the description of the state machine look like when translated from
Polynomish to English?


## Author's comments:
Remarks
=======

This entry graphically displays a simulation of sand falling.
It uses SDL to draw the interface.

The code makes the following assumptions about the underlying system:

* SDL 2 is installed from https://libsdl.org
* "double" is an IEEE 754 floating-point type and sizeof(double)==8
* The compiler supports the C99 standard

In order to simulate the motion of the sand, a cellular automaton is used. The
state transition table is not stored directly. Instead, the program stores the
coefficients of a polynomial that map each state to the correct one. These
coefficients are stored as raw hexadecimal in the V[] array, and they are
reinterpreted as doubles when used. This allows more numeric precision in fewer
characters (base 16 > base 10), and makes the purpose of the array less clear.

The code is laid out graphically as a bucket pouring sand, and it is far easier
to observe this high-level layout than the code's actual function.

The preprocessor is used to both obfuscate the code as a whole and abbreviate
the calls to SDL. Additionally, throughout the code, the variables were named
so that they are short and easily confused with each other.

--------------------------------------------------------------------------------
<!--
(c) Copyright 1984-2018, [Leo Broukhis, Simon Cooper, Landon Curt Noll][judges] - All rights reserved
This work is licensed under a [Creative Commons Attribution-ShareAlike 3.0 Unported License][cc].

[judges]: http://www.ioccc.org/judges.html
[cc]: http://creativecommons.org/licenses/by-sa/3.0/
-->
# Most likely to be awarded

Marcin Ciura <mciura@gmail.com>  
Twitter: @mciura  


## Judges' comments:
### To use:

    make

    ./prog < text

### Try:

    ./prog < Makefile
    ./prog < hint.text

### Selected Judges Remarks:

This text was processed by prog. You may get confused.
We're not really sure: prog.c wasn't commented.
Who has been thoroughly puzzled by prog? Also how obfuscated is prog?
Having been written in C, how large of a vocabulary has it?


## Author's comments:
The Program
===========

"The Elements of Style" by prof. William Strunk, Jr. and E. B. White
is well known for its dislike of the passive voice.  Direct, vigorous,
active constructions were instead recommended by the authors.
The development of this program has been driven by this tenet.

Only passive sentences from the standard input are output.  The offending
part(s) of each sentence will be highlighted.  Several kinds of passive
constructions are recognized:

* Plain passive voice.
  Foo was bazzed by bar.
* Passive voice with "get".
  I got almost quuxed.
* Contractions.
  I'm not really quuxed: foo wasn't bazzed.
* Questions.
  Who has been quuxed?  Was foo indeed bazzed?  How was it bazzed?
* Clause-initial inversion.
  Also bazzed is bar.

Sentences are never broken by periods that follow abbreviations and
initials.  Both regular and irregular past participles are properly
dealt with.  Note that some words are red herrings: even though their
ending is -ed, they are not past participles.

The Big String
==============

Here is the purpose of every byte inside the **`c[]`** string:

* 0-9:  highlighting passive constructions in the output;
* 10-50:  classifying characters - called by **`V(4)`**;
* 52:  outputting the newline character;
* 51-187:  tokenizing text and detecting passive constructions - two
  type A state machines, called by **`V(2)`** and **`V(3)`**;
* 186-2786:  determining word categories (past participles, present
  simple and past simple forms of "to be", other forms of "to be",
  adverbs, wh-words, and other words) and recognizing abbreviations -
  two type B state machines, called by **`V(808)`** and **`V(205)`**.

The State Machines
==================

I heard you don't like state machines so I put a state machine in your
state machine so you can reject this entry while you reject this entry.

Both types of state machines in the program are Mealy machines: we can
think of their transitions as triples (**`transition_label`**,
**`next_state`**, **`output`**).

Type A
------

A state of type A state machine consists of eight transitions whose
representations occupy consecutive bytes.  The byte
**`c[3 + 8*state + transition_label]`** contains
**`(unsigned char)(30 + 5*next_state + output)`**.

The `transition_label` is either one of character classes:

* **`nil`** = 0,
* **`space`** = 1,
* **`new_line`** = 2,
* **`uppercase`** = 3,
* **`lowercase`** = 4,
* **`period`** = 5,
* **`bang_question`** = 6,
* **`punctuation`** = 7,

or one of word classes:

* **`adverb`** = 0,
* **`other`** = 2,
* **`past_participle`** = 3,
* **`to_be`** = 4,
* **`are_were`** = 5,
* **`wh_word`** = 6 (cf. the **`output`** of type B state machines).

The **`output`** is either one of:

* **`end_of_text`** = 0,
* **`sentence_start`** = 1,
* **`sentence_end`** = 2,
* **`token_end`** = 3,
* **`ignore`** = 4,

or one of

* **`passive_construction_start`** = 1,
* **`ignore`** = 2,
* **`passive_construction_end`** = 3.

Type A state machines run continuously.  Their state is kept in
**`k[2]`** and **`k[3]`**.

Below are sample steps of scanning a sequence of characters with
classes **`uppercase`**, **`lowercase`**, **`period`**, **`space`**,
and **`uppercase`**.

* **`state`** = 7, **`transition_label`** = 3 (**`uppercase`**), **`output`** = **`sentence_start`**
* **`state`** = 14, **`transition_label`** = 4 (**`lowercase`**), **`output`** = **`ignore`**
* **`state`** = 15, **`transition_label`** = 5 (**`period`**), **`output`** = **`token_end`**
* **`state`** = 13, **`transition_label`** = 1 (**`space`**), **`output`** = **`token_end`**
* **`state`** = 18, **`transition_label`** = 3 (**`uppercase`**), **`output`** = **`sentence_end`**

And here are sample steps of scanning tokens with classes **`to_be`**,
**`adverb`**, **`past_participle`**.

* **`state`** = 8, **`transition_label`** = 4 (**`to_be`**), **`output`** = **`passive_construction_start`**
* **`state`** = 22, **`transition_label`** = 0 (**`adverb`**), **`output`** = **`ignore`**
* **`state`** = 22, **`transition_label`** = 3 (**`past_participle`**), **`output`** = **`passive_construction_end`**

Type B
------

Type B state machines are built by a variant of the algorithm described
in the paper
*[How to squeeze a lexicon](http://sun.aei.polsl.pl/~mciura/publikacje/lexicon.pdf)*.
Their states are represented as interlaced sparse arrays of transitions.

The **`transition_label`** is one of:

* **`word_start`** = 0,
* **`period_or_apostrophe`** = 1,
* **`a_z_letter`** = 2..27.

The `output` is either one of word classes:

* **`adverb`** = 0,
* **`ignore`** = 1,
* **`other`** = 2,
* **`past_participle`** = 3,
* **`to_be`** = 4,
* **`are_were`** = 5,
* **`wh_word`** = 6,

or

* **`ignore`** = 1,
* **`abbreviation`** = 2.

The byte **`c[186 + (state + transition_label)] = (unsigned char)(2 + transition_label + 28 * output)`**.

The byte **`c[836 + 2*(state + transition_label)] =`**

* **`' '`** when **`next_state / 376 == 0`**,
* **`';'`** when **`next_state / 376 == 1`**.

The byte **`c[837 + 2*(state + transition_label)] =`**

* **`' '`** when **`next_state / 94 % 4 == 0`**,
* **`';'`** when **`next_state / 94 % 4 == 1`**,
* **`'{'`** when **`next_state / 94 % 4 == 2`**,
* **`'}'`** when **`next_state / 94 % 4 == 3`**.

The byte **`c[2136 + (state + transition_label)] = (unsigned char)(32 + next_state % 94)`**.

A type B state machine starts in a given **`state`** with **`output`**
set to **`ignore`**.  It scans a word backwards, converting character by
character to **`transition_label`**.  When it meets **`word_start`**, it
returns, leaving the most recently stored **`output`** in **`v`**.
It also returns when
**`c[186 + (state + transition_label)] != (unsigned char)(2 + transition_label + 28 * output)`**,
i.e. when the **`transition_label`** in the byte mismatches the
**`transition_label`** used to compute the index.  Otherwise, if the
**`output`** in this byte differs from **`ignore`**, the state machine
stores it in **`v`**.  Regardless of the value of the **`output`**,
it also assigns **`next_state`** to **`state`** and proceeds to scan
the previous character.  The state machine that determines the word
class is set up so that it never returns **`ignore`**.

Below are sample steps of scanning the word "chiefly".

* **`state`** = 623, **`transition_label`** = 26 ('y'), **`output`** = **`other`**
* **`state`** = 602, **`transition_label`** = 13 ('l'), **`output`** = **`adverb`**
* **`state`** = 594, **`transition_label`** = 7 ('f'), **`output`** = **`other`**
* **`state`** = 549, **`transition_label`** = 6 ('e'), **`output`** = **`ignore`**
* **`state`** = 543, **`transition_label`** = 10 ('i'), **`output`** = **`adverb`**
* **`state`** = 0, **`transition_label`** = 9 ('h') mismatches the value stored
in the byte.  Return **`adverb`**.

And here are sample steps of scanning the string "i.e.":

* **`state`** = 19, **`transition_label`** = 1 ('.'), **`output`** = **`ignore`**
* **`state`** = 24, **`transition_label`** = 6 ('e'), **`output`** = **`ignore`**
* **`state`** = 3, **`transition_label`** = 1 ('.'), **`output`** = **`ignore`**
* **`state`** = 2, **`transition_label`** = 10 ('i'), **`output`** = **`ignore`**
* **`state`** = 1, **`transition_label`** = 0 ('\0'), **`output`** = **`abbreviation`**.
Return **`abbreviation`**.

Remarks
=======

The judges found a bug in the handling of contractions: **`prog.orig.c`**
outputs "foo wasn'**[t bazzed]**".  I fixed the bug in **`prog.c`**, making
it output "foo **[wasn't bazzed]**" instead, and took the liberty to merge
one statement into a **`for`** loop inside its **`main()`** function.

The program uses a 9,437,187-byte buffer so it probably will not run
on 16-bit and smaller machines without changing the size of array **`C[]`**
and the expression **`9<<20`** inside the call to **`read()`**.

I have tested it on:

* Linux with gcc version 5.4.0 20160609,
* Linux with clang version 3.4-1ubuntu3,
* OS/X with Apple LLVM version 6.0 (clang-600.0.57).

For a clean compile under c89 and c90, add **`-Woverlength-strings`**
to **`CSILENCE`**.

--------------------------------------------------------------------------------
<!--
(c) Copyright 1984-2018, [Leo Broukhis, Simon Cooper, Landon Curt Noll][judges] - All rights reserved
This work is licensed under a [Creative Commons Attribution-ShareAlike 3.0 Unported License][cc].

[judges]: http://www.ioccc.org/judges.html
[cc]: http://creativecommons.org/licenses/by-sa/3.0/
-->
# Best use of weasel words

Cody Boone Ferguson <weasel@xexyl.net>  
<https://ioccc.xexyl.net/2018/weasel>  
Twitter: @xexyl  


## Judges' comments:
### To use:

    make

    ./weasel

### Try:

    ./weasel words
    ./weasel -mq words
    ./weasel -q -r8 'EVOLUTION IS A PROVEN FACT'
    ./weasel -m 'INTELLIGENT DESIGN'

    make test

### Selected Judges Remarks:

Looking back over the strata of past IOCCC entries, this program marks a new
mutation on our understanding of sequencing of code.  In adaptation of the
modern scientific that the C language has evolved, this mutant of a program
may stress your understanding of taxonomy of the C syntax tree.

The phenotype of the source suggests a veritable sea of primordial ASCII soup.
The encoded logic of the watchmaker suggests a variation of thought experiment
formulated by Richard Dawkins: but without the need for feeding too many
evolutionary relatives of the primate order in which us Homo sapiens hang
from the phylogenetic tree of life.

If you wish your computer to maintain one branch in the Cretaceous C code era,
while using more Cenozoic minded code migration, read rpm.markdown.

If you find yourself in an evolutionary dead end, try:

    man ./weasel.man


## Author's comments:
    0. Preface
    1. What it is
    2. How it works
    3. Hints (Keyboards, Options, Spoilers, Example Invocations)
    4. Obfuscation (Techniques, Beauty)
    5. How to build (S and N Constants, Compilation, Portability, Installing)
    6. Final thoughts
    7. Winning comments, thanks, dedications, links, etc.

## **0. Preface**

**SPOILER WARNING: A great deal of this document and the man page is full of
spoilers of different types; as such I would recommend that you try running the
judges suggested invocations as well as running `make test` before you get into
the document or the man page, unless you don't mind any spoilers. I don't reveal
much in the way of obfuscation however so if you just want documentation on the
program, how to compile, etc. then there isn't need to heed this note.**

I was at a loss on how to present my remarks; on the one hand I wanted to give
everything to the judges so they didn't miss anything. But on the other hand I
didn't want to reveal as much publicly and many people don't like to read long
texts. To resolve this I think the best way is referencing the judges' comments:
if you want a quick rundown of the entry try what they suggest and view the man
page (it explains all the options and describes the program briefly):

    man ./weasel.man

If that isn't sufficient **I would recommend reading this section** *(and
possibly the next)* where I attempt to give a brief explanation of the sections
to make reading it easier and faster. In addition I want to point out a few
things. *If you want more details read this document more thoroughly (or just
the sections that seem relevant to what you're after).* The [FILES][] file is a
quick list of files and respective summaries in this entry. Because several
sections are quite long I have added a skip to link to skip to the next
subsection or section at the beginning of each section (and subsection).

**[What it is](#what):** This is a brief summary of the program; the man page is
more thorough than this.

**[How it works](#how):** Explain some of the basic concepts and terms of the
program; if you're familiar with genetic algorithms there won't be any problem
following this section but it might be of some value to read anyway. There is a
randomised mode that doesn't use a genetic algorithm; it can be triggered a
number of ways but the **`-m`** option enables it specially (I discuss this
thoroughly in **[Hints](#hints)**).

**[Hints](#hints):** Perhaps the longest part of this document because in it I
document the [keyboards](#keyboards), [options](#options), subtleties (including
features that might appear to be bugs but aren't - including an
[input error](#error)), an [Easter egg spoiler](#spoiler) and quite a few
[example invocations](#invocations). If you've read the man page you probably
don't need this unless there is something specific you're after.

**[Obfuscation](#obfuscation):** Some of the techniques that might not be used.

**[How to build](#build):** Here I describe briefly
[the constants that can be redefined](#constants) **`S`** and **`N`**: the
maximum size of the chromosome (target string; the maximum length is **`S - 1`**
but it must be >= the default 38) and the number of offspring, respectively. I
also give [example compiler invocations](#compiling), [portability
notes](#portability), an [more portability notes](#bugs) and a [note on
rpm.markdown](#rpm).

On the subject of **`S`** and **`N`**: As the judges' suggested runs imply you
can change the target string at runtime; **`make test`** runs a script
*`test.sh`* which reads from the file *`test-strings.txt`*, running the program
for each string in the file, waiting approximately two seconds before
continuing.  I explain how to pass options to the script in part of
**[Hints](#test)**.

**[Final thoughts](#thoughts):** You might enjoy what I included; they're
humorous pieces by [Dennis Ritchie](#dmr) and [Ken Thompson](#ken) themselves
from the infamous *UNIX-HATERS Handbook*.

**[Winning thoughts](#winning):** What it means to me to win as well as some
dedications and thanks. Here too I include a link to a website which will be
dedicated to this entry beyond what will be published on the IOCCC website

[FILES]: FILES
[rpm.markdown]: rpm.markdown

## **1. <a name="what">What it is</a>**

Skip to [How it works](#how).

It is an implementation of Richard Dawkins' [Weasel program][] (Wikipedia).
According to Wikipedia in chapter three of his book [The Blind Watchmaker][]
Dawkins wrote:

> I don't know who it was first pointed out that, given enough time, a monkey
> bashing away at random on a typewriter could produce all the works of
> Shakespeare. The operative phrase is, of course, *given enough time.* Let us
> limit the task facing our monkey somewhat. Suppose that he has to produce, not
> the complete works of Shakespeare but just the short sentence 'Methinks it is
> like a weasel', and we shall make it relatively easy by giving him a typewriter
> with a restricted keyboard, one with just the 26 (capital) letters, and a space
> bar.  How long will he take to write this one little sentence?

He refers to the [Infinite Monkey Theorem][] (Wikipedia). As he points out the
operative phrase is *given enough time*; but even if it's extremely unlikely
*technically the probability is greater than 0*. He simplified it for the
monkey; I thought the monkey had it too easy: unlike his limited keyboard I have
(besides space) every character in the ASCII range **`0<=126`** that
**`isprint()`** returns non-zero except that only capital letters are included;
the file *`prog-simple.c`* has a slightly smaller keyboard. There are some
additional features I have added (including two Easter eggs); amongst others:
ability to change the target string and maximum length. See 
**[How it works](#how)**, **[Hints](#hints)** and **[How to build](#build)** for
more details.

In its simplest invocation this program will work its way (using a genetic
algorithm) towards the solution of the string **`METHINKS IT IS LIKE A WEASEL`**
(note that I use **`toupper()`** so it doesn't matter what case the input is the
comparison and output will always be capitalised).

[Infinite Monkey Theorem]: https://en.wikipedia.org/wiki/Infinite_monkey_theorem
[Weasel program]: https://en.wikipedia.org/wiki/Weasel_program
[The Blind Watchmaker]: https://en.wikipedia.org/wiki/The_Blind_Watchmaker

## **2. <a name="how">How it works</a>**

Skip to [Hints](#hints).

Here you can find a general explanation of a *[genetic algorithm][]* as well as a
brief history. Although the link provides more information (including images to
try and show the way they work) for those interested I will cite the summary:

> Genetic Algorithms (GAs) are adaptive heuristic search algorithm based on the
> evolutionary ideas of natural selection and genetics. As such they represent an
> intelligent exploitation of a random search used to solve optimization problems.
> Although randomised, GAs are by no means random, instead they exploit historical
> information to direct the search into the region of better performance within
> the search space. The basic techniques of the GAs are designed to simulate
> processes in natural systems necessary for evolution, specially those follow the
> principles first laid down by Charles Darwin of "survival of the fittest.".
> Since in nature, competition among individuals for scanty resources results in
> the fittest individuals dominating over the weaker ones.

**SPOILER WARNING: Some of the below might help you follow the code more
easily.**

For each *generation* there is a total of **`N`** *offspring*; generation 0 is
the pseudo-randomly initialised array *without parents.* Each offspring has its
own *chromosome* to be compared to the *target string* and a *fitness score*;
the higher the fitness score the more likely it will be a *parent of the next
generation* (randomised mode notwithstanding) as part of the *selection process*
(As the generations go by the fitness of the offspring should be higher; when
the fitness matches that of the target it will be printed and the loop will be
broken out of).

After determining the two parents *crossover* occurs: each new offspring
inherits DNA from the parents; every character in the chromosome string is
pseudorandomly selected from one of the parents' respective character. Next,
based on the *mutation rate*, perform *mutation* of the chromosome of each
offspring; in other words *some of the characters in the chromosome will be
assigned a pseudo-random value from the keyboard (in normal mode; in random mode
every character will be assigned a value*). Before mutation the offspring
chromosome will be printed; after mutation it will show what it was mutated to
(on the same output line). After the new generation has been sequenced the loop
goes back to the top and it starts all over until the maximum number of
generations **`SIZE_MAX - 1`** is reached or the target chromosome has been
found.

Note that the generation is checked *before the scoring takes place* by a prefix
increment equality check; when the generation is **`SIZE_MAX - 1`** the fitness
test loop will not be entered; instead the outer loop will end after printing:

> Too many attempts, blaming the monkey Eric even if he isn't typing or doesn't exist. Bye.

Why '*Eric*'? Because the judges stated in the [2018 guidelines][] that when
there is a user input error the program should insult the pet fish Eric even if
such a fish (no, weasels do not equate monkeys to fish but see below) doesn't
exist. The second to last example limitation example note (it's improved in the
final but this is relevant) they give is:

> The judges might not have a pet fish named Eric, so might want to state:
> 
> 	This entry factors integers between 1 and 2305567963945518424753102147331756070.
> 	Attempting to factor anything else will cause the program to insult your
> 	pet fish Eric, or in the case that you lack such a pet, will insult the
> 	pet that you do not have.

After the final message they ask:

> BTW: **What is so special about 2305567963945518424753102147331756070**?  You tell us!

The answer is this: **it is the primorial prime of 97:** the product of all
prime numbers less than or equal to N; **and the primorial prime of `N == 97` is
`2305567963945518424753102147331756070`**. There is no reference to this number
in my entry but it's nonetheless possible to **change the default target to it
without modifying the source code**; there are two hints in this very
paragraph; the first sentence in fact: the answer to the judges' question and
the definition. Can you get the program to search the primorial prime of 97
without passing in specially?

**On user errors:** if the generation reaches **`SIZE_MAX - 1`** I consider it a
user (or monkey) error; if the user insists on being so petulant as to try such
a ridiculous set of parameters in an attempt to make it be no more successful
than a monkey typing *then it shouldn't be any more successful than a monkey; if
it by chance reaches the target it's because a monkey could too!* Either way
unless the number reaches **`SIZE_MAX - 1`** the monkey Eric won't be blamed. It
should be noted that depending on the parameters (size of chromosome, number of
offspring, the string itself) the program could take quite a lot of system
resources; and whether the OS kills it, Eric the monkey falls asleep or the
typewriter is taken from him the result could very well be not found without
blaming him. Of course the judges were talking about fish not monkeys. But since
this program is inspired by the Weasel program *which was inspired by the
[Infinite Monkey Theorem][]* I opted instead to target the monkey Eric even if
such a monkey isn't typing or even doesn't exist (because it's not the *Infinite
Fish Theorem*). So although the user might not be a monkey the program makes the
assumption that **the user could in fact be a monkey called Eric** *although it
isn't insolent enough to say the user is a monkey for certain!*

[genetic algorithm]: http://www.doc.ic.ac.uk/~nd/surprise_96/journal/vol1/hmw/article1.html
[2018 guidelines]: http://ioccc.org/2018/guidelines.txt


## **3. <a name="hints">Hints</a>**

Skip to [Obfuscation](#obfuscation).

I noted that there are a number of additional features and here I will document
some of them. 

### <a name="keyboards">Keyboards</a>

Skip to [Options](#options).

The keyboard, as noted, has more than just the alphabet and space. To be
precise the following characters are acceptable; it equates to this in C (note
it includes a literal space **`' '`** but it doesn't include other
**`isspace()`** characters) and this is why some of the characters are escaped:

	    const char keyboard[]=" !\"#$<%:>&'()*+,-./0123456789;=?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`{|}~";

The simpler keyboard looks like:

	    const char keyboard[]=" !\"&'(),.0123456789;?ABCDEFGHIJKLMNOPQRSTUVWXYZ";

The program makes sure that the target string only has characters the keyboard
can actually produce but there is a certain type of input error that might
*appear* to be a bug; see specifically [Input Error Example](#error).


### <a name="options">Options</a>

Skip to [Spoilers](#spoiler).

There are a number of options you can pass to the program besides the target
string; some I will document here (the summary being in the man page). You can
join options but there is a caveat with spaces and **`-r`** option as well as
the target string (see below).

**Enable quiet output:**

	    -q


This means don't print the generation and offspring output; only print (some) of
the options set (this is always done but wouldn't usually be seen due to verbose
output) and the final answer.

**Change the mutation rate to `<rate>`:**

	    -r<num>

Please note that there cannot be a space between the **`-r`** and the number.
This is to simplify the parsing of options. As for combining options you can do
any of the following (amongst others):

	    -r5q
	    -qr5
	    -qr
	    -q -r5

The third invocation will set quiet output and have no valid value to parse for
the mutation rate and **`strtol()`** in this case returns 0. **`strtol()`** can
legitimately return 0 but in no instance is it valid input in this program: the
valid mutation rate is **`>= 1 && <= 100`**.

When the mutation rate is out of range it does something interesting: take a
look at the output and compare it to the output when the range is valid. Can you
figure out another way to trigger this? In fact there are two more ways (one is
an option I've mentioned and the other one is to do with the number of
offspring)! If you want something of a walk through I suggest you follow the
following:

1.  Enable quiet mode and set an invalid mutation range; for example specify:

	    -qr101

2.  Take a look at the first few lines. Kill the program and try invoking it
with the following options:


	    -qr5
    
3.  Look at the first few lines again and compare it to the output of step \#1.
With the default string most modern systems shouldn't take much time to - given
decent parameters - come to an answer here but if necessary kill the program.

4. Repeat the steps only this time don't enable quiet mode. Look at the
offspring output. If you still don't see what it is and want to know see
**[Spoilers](#spoiler)** below.

Finally any argument that doesn't start with a **`-`** passed into the program
will become the target string. The same rule applies to the number for **`-r`**:
it must be a single parameter which means you'll need to quote the string if it
has more than one word (that is it contains spaces) or anything else interpreted
specially by your shell e.g. parentheses. For instance if you just want to find
**`METHINKS`** you could do one of:


	    $ ./weasel METHINKS
	    $ ./weasel "METHINKS"
	    $ ./weasel 'METHINKS'

If you wanted **`YOU ARE A MONKEY`**:

	    $ ./weasel "YOU ARE A MONKEY"
	    $ ./weasel 'YOU ARE A MONKEY'

If you do one of:

	    $ ./weasel "METHINKS IT IS A" "MONKEY"
	    $ ./weasel METHINKS IT IS A MONKEY

It will search for **`MONKEY`** in both cases; in other words it's the last one.
If the string is too long given the value of **`S`** (see 
**[How to build](#build)**) it will be truncated. 

If you actually do want to search for a string starting with a **`-`** you must
disable further parsing of options by using the **`-`** option itself; for
example if you were to do any of:

	    $ ./weasel -q- -- -test
	    $ ./weasel -q- -test
	    $ ./weasel -q -- -test

The target string will be: **`-TEST`**. This means though that here:

	    $ ./weasel -q -- -test -r5

The string to be searched would actually be **`-r5`** and the mutation rate
will remain the default because after the **`-`** option is seen it will no
longer parse additional options: only target strings if anything left on the
command line. Because of the joining of arguments this means that the first two
examples of the last set of three above are equivalent i.e. the following two
are equivalent:

	    -q- 
	    -q --
	    
As for the caveat I referenced what does the following do?

	    $ ./weasel -qr 5

In fact it will set quiet output and set the target string to be '5'. So the
mutation rate will be out of range, thus enabling that Easter egg, but it will
likely come to an answer fairly quickly because it's just a single character. A
note on the parsing of the **`-`** option; if the program is currently parsing
**`argv[N]`**, for example, and it encounters a **`--`** then depending on where
the other options are in the command line it might still parse the options. Thus
you have:

	    $ ./weasel -qr-r5
	    quiet output
	    mutation rate out of range
	    target 'METHINKS IT IS LIKE A WEASEL'
	    mutation rate 5
	    Generation  440 Offspring 20: METHINKS IT IS LIKE A WEASEL

Similarly this would set quiet output, then an invalid mutation rate and then a
mutation rate of 5:

	    $ ./weasel --qrr5


If you were instead to do one of (for example):

	    $ ./weasel -q -- -r
	    $ ./weasel -q -q- -r

Then it *would* set quiet output then see the **`--`** (the **`-`** option
itself) and then the target string would *literally* be set to **`-r`** because
it no longer cares about the **`-`** for option parsing. In other words options
are only parsed if the first character is **`-`** and if the parser hasn't seen
the **`-`** - *in an earlier element of `argv`. This is not a bug!*


### <a name="spoiler">Spoilers</a>

Skip to [Example Invocations](#invocations).

The Easter egg: Since Dawkins references the [Infinite Monkey Theorem][] it
simulates a monkey using a typewriter! This mode has the following changes:

Selection is omitted; this means no sorting by fitness score (*each offspring
is initially set to be the first two in the list*) but do pseudo-randomly
select characters for every character in the target string; that is to say if
the string is of length 28 (the default) then all 28 characters in each
offspring of each generation will be assigned a pseudo-randomly positioned
character in the keyboard. If you want to enable this specially you can use the
**`-m`** option (*-m for monkey*).

### <a name="invocations">Example Invocations</a>

Skip to [Input Error Example](#error).

The following examples are used to demonstrate better the command line parsing.
In order to do that though I had to first document the **`-m`** option because
if the mutation rate is out of range monkey mode is activated (that's the first
Easter egg). But what happens if you later set a valid mutation rate? Should
monkey mode be disabled? If yes how do we know if monkey mode was specially
requested?  There are at least two ways to go about it: I took the monkey safe
('fool safe') method; *if you explicitly request monkey mode you cannot disable
it in the same invocation of `weasel`*!


	    $ ./weasel -qr101r5r101r1r test
	    quiet output
	    mutation rate out of range
	    mutation rate out of range
	    mutation rate out of range
	    target 'test'
	    mutation rate 0
	    monkey at typewriter
	    Generation 16844        Offspring 22: TEST

So in this case I joined the options in the following order:

1.  **`-q`**

Quiet output.

2.  **`-r101`**

Mutation rate 101 (out of range).

3.  **`-r5`**

Mutation rate of 5 but note that during parsing I only print invalid mutation
rate (only after parsing do I print the final mutation rate whatever it ends up
being); so while it appears there is a bug, showing mutation rate out of range
three times, this is expected (given the next one, **`-r101`**). This means here
the typewriter was taken from Eric the monkey.

4.  **`-r101`**

Mutation rate to 101: this too is out of range (this is the second mutation rate
out of range message). The typewriter returns to Eric.

5.  **`-r1`**

Set mutation rate to 1. Take that typewriter away!

6.  **`-r`**

Set mutation rate to 0; when there are no valid characters passed to
**`strtol()`** it should return 0: this is the third message about being out of
range. Note here that **`rand()`** returns an **`int`** and **`strtol()`**
returns a **`long`** but I compare the return value of **`rand()`** to the
mutation rate; if there are any systems where the widths differ this *shouldn't
matter* because of truncation but I do in any case specifically check for **`R <
0 || R > 100`**. Either way the invalid range returns the typewriter to Eric. 

7.  **`test`**

Finally I requested it find the string **`test`** (will search for **`TEST`**).

Given that it was a short string it did find the answer relatively quickly, even
in monkey mode.

Another example:


	    $ ./weasel -q -r101 test -r5
	    quiet output
	    mutation rate out of range
	    target 'test'
	    mutation rate 5
	    Generation  109 Offspring 13: TEST

In this case I also enabled quiet mode but I didn't join the options; the
**`-r101`** reports that it's out of range and sets monkey mode. I then specify
the target string and then set a valid mutation rate. This disabled monkey mode
which means that it'll use the genetic algorithm. 

One more example of monkey mode:


	    $ ./weasel -q -mr101 test -r5
	    quiet output
	    mutation rate out of range
	    target 'test'
	    mutation rate 5
	    monkey at typewriter
	    Generation 465298       Offspring 10: TEST

Here I also requested quiet output and then *explicitly requested that Eric the
monkey types.* After this I set the mutation rate to be 101 which would have
set monkey mode (*in this case only temporarily as I later set it to a valid
number*) but since I have also requested monkey mode that won't matter. Then I
set the string to **`test`** and then set a valid mutation rate of 5. Now note
that it is actually set to 5 but also note that monkey mode remains active: it
also took a lot longer to come to a conclusion for even four characters. This
example does demonstrate one other thing in a subtle way though.

When the program prints out each iteration (I'll give an example next) it goes a
lot slower; this makes sense because it's an expensive operation. Here are the
times for the same but without quiet output enabled:

	    real    0m17.065s
	    user    0m1.245s
	    sys     0m2.402s

Whereas with quiet output:

	    real    0m0.127s
	    user    0m0.125s
	    sys     0m0.001s

Of course it isn't only down to the printing but the point is it slows it down
significantly. Adding an option to print every X lines would go over the limit
(**`iocccsize -i`** reports 2052!).

Finally I'll show a default example in normal output (I omit many lines showing
instead **[...]**). Note that the real/user/sys times are from the **`time`**
bash shell built-in utility: that isn't output from my entry.


	    target 'METHINKS IT IS LIKE A WEASEL'
	    mutation rate 1
	    Generation    0 Offspring  1: 4V YGY.GH/}_|>Q1M.R8;KD[=(05
	    Generation    0 Offspring  2: Y_^S0_HZ399^/|9,MP%^{817"XX#
	    Generation    0 Offspring  3: F%88H1&[V1P>QOI}- U]0[V-Y%*[
	    [...]
	    Generation    1 Offspring 23: AHA#.\=ZT'0>?~-S.;1A L|1<S:^ -> AHA#.\=ZT'0>?~-S.;1A L|1<S:| (mutation)
	    Generation    1 Offspring 24: AHA#.\=ZT'0>?~-S.;1A L|1<S:^ -> AHA#.\=ZT'0>?~-S.;1A L|1<S:^ (mutation)
	    Generation    1 Offspring 25: AHA#.\=ZT'0>?~-S.;1A L|1<S:^ -> AHA#1\=ZT'0>?~-S.;1A L|1<S:^ (mutation)
	    **
	    Generation    2 Offspring  1: AHA#.\=ZT'0>?~-S.;1A L|1<S:^ -> AHA#.\=ZT'0>?~-S.;1A L|1<S:^ (mutation)
	    Generation    2 Offspring  2: AHA#.\=ZT'0>?~-S.;1A L|1<S:^ -> AHA#.\=ZT'O>?~-S.;1A L|1<S:^ (mutation)
	    [...]
	    Generation  979 Offspring  1: METHINKS ITZIS LIKE A WEASEL -> METHINKS IT IS LIKE A WEASEL (mutation)
	    [...]
	    **
	    Generation  979 Offspring  1: METHINKS IT IS LIKE A WEASEL

	    real    0m0.074s
	    user    0m0.040s
	    sys     0m0.001s


Keep in mind the way I display the generations and the fact that generation 0
has no parents; it is generation 1 that starts working towards the goal. You'll
see also **(mutation)** at the end of the line at this point (if you enable
monkey mode you'll find that it shows something else). The lines that only have
`**` are separators: you won't see this between generation 0 and 1 but you will
between future generations - as well as the final answer (if the answer is in
generation 0 you won't see the `**`).

<a name="test"></a>
One final thing to consider is that **the program doesn't directly read from a
file**. This combined with the way the shell works could possibly confuse some
people. Take the following invocations:

	    (1) $ echo test > test
	    (2) $ ./weasel test
	    (3) $ ./weasel < test
	    (4) $ cat test | ./weasel 
	    (5) $ < test-strings.txt ./weasel
	    (6) $ cat | ./weasel

Only the first invocation of **`./weasel`** will search for **`TEST`** because
the string **`test`** was explicitly passed to the program (If the file *`test`*
wasn't found by that path it would still have searched for **`TEST`**).

The second invocation will search for the default string if there is a file or
directory called *`test`*; else you will get an error about no such file or
directory (unless your shell for some reason doesn't consider it an error; bash
most certainly does consider it an error and halts).

The third invocation would if there exists a file *`test`* cat that file and
pipe the output to **`./weasel`**; *however it will search for the default
string.* If there is no such file to cat then an error will be reported but
without quiet mode you'd probably not even see the error.

The fourth invocation will also search for the default string unless the file
doesn't exist in which case you'd get an error like in the second invocation.

The fifth invocation will actually search for the default string even with the
file *`test-strings.txt`* existing. As far as I am aware it's equivalent to the
third invocation except that the file exists in this case.

The final invocation will search for the default and then read from *`stdin`*;
it won't do anything with it however.

What this amounts to is *if you want input from a file you have to read from the
file and pass each string to the program itself*. I've included a script
*`test.sh`* and a file of sample input *`test-strings.txt`* that you can play
with.


Try:

		$ make test

This will essentially make sure the program is compiled and then do:

		$ chmod +x test.sh
		$ ./test.sh


The script will first try compiling the program (if necessary) and if it fails
for any reason it will exit; else it will read each line in the file
*`test-strings.txt`* (if the file doesn't exist or can't be read the script will
exit with return status of 1) and pass it to the program. After finding the
string it'll sleep approximately 2 seconds and then read the next string
(passing it to the program, continuing until all the strings have been read and
processed).

You can pass additional options directly to the script but remember that it
stops when there are no more strings in the file - so if you try:


	    $ ./test.sh -q test


The final string **`test`** won't be searched for; it will however run the program
in all invocations with quiet output enabled. The following are some notes about
how the shell and the program interact with each other:

Because the script quotes the strings that it reads from the file if you were to
put in the file: **`-q STRING`** quiet mode would be enabled; however the
default string would be searched for. If the quotes were removed from the script
it would print the final word specified. To be specific with the quotes: if in
the file you had the line **`-q STRING -m TEST`** it would enable quiet output
and monkey typewriter mode; but it would search for the default string. Without
the quotes on the other hand it would enable quiet output, monkey typewriter and
search for **`TEST`**. In other words **if you want to pass options to the
script you will have to directly pass the options to the script** like the above
example shows (but the strings will still only be read from the
*`test-strings.txt`* file).

### <a name="error">Input Error Example</a>

Skip to [Obfuscation](#obfuscation).

There is a type of input error, as I said, that might appear to be a bug. What
actually is going on though is due to a technicality on how spaces are printed
and the fact the program does not accept spaces other than a literal space 
**` `**; when a character in the string to be found isn't in the keyboard the
program prints an error message and then exits (returning 1). But since the
keyboard doesn't have **`'\n'`** if you were to type a **`'`** and send a
**`'\n'`** before the closing **`'`** you might see something like:


		$ ./weasel '!!
		> '
		
		'
		' not in keyboard " !"#$<%:>&'()*+,-./0123456789;=?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`{|}~"

I showed that **`'`** is in the keyboard already; however the user sent a
**`\n`** (hence the secondary prompt **`>`** on line two) before literally typing the
closing **`'`** (also line two). But in order to make it clear what character is invalid I
surround the character with **`'`**s so what you actually see after typing the
closing **`'`** and hitting Enter (or however you send the **`'\n'`**) there is
the third blank line; *but then the program prints* **`'`** followed by the
invalid character (**`'\n'`** itself which means another line break) and then
finally the closing **`'`**.  Specifically **`isspace()` characters aren't
distinctly seen like a letter, digit or symbol is: `isprint('\n') == 0 &&
isspace('\n') == 1`**. You can add these characters but the output will be
rather confusing and hard to read.


## **4. <a name="obfuscation">Obfuscation</a>**

### Techniques

Skip to [Beauty](#beauty).

The following might be some of the techniques used in this entry:

1.  Helpful and descriptive names for all variables and constants (like **`S`**)
as well as some C keywords.

2.  The way **`main()`** is declared is:

	    /* Special C main() handler (encapsulation): */
	    #define r(main) main
	    r(k main(k a, E **V)) {

    It appears to be recursively defined but is it? And is it truly
encapsulation? And is it executing code of any kind? It mightn't seem like it
isn't encapsulation and also isn't executing code but assuming it's
encapsulation and executing code is it actually nothing? And if it's nothing why
is it there? If it is something what is it doing? Could it be both? Or maybe it
really isn't nothing or nothing? :)

3. A special C parser called **`H()`**. It might help to observe that there
might be recursive calls and much of the program might use it. Or so it seems.
Then again it might not help to not notice it.

4.  Digraphs. In their simplest form it's probably not a big deal but consider:
some source code formatters don't like them at all (neither, incidentally, does
**`splint`**, which completely baulks). There also is a trick; if you try
translating them then depending upon how you do it there can be functional
changes in the program!

5.  The fact the program can by default print the primorial prime of 97 (*but that
default isn't the default - except when it IS the default!*) and yet that number
isn't seen at all. See also technique #7.

6.  Another usual suspect: the source is formatted in a beautiful design that
could be described artistic; on the other hand some might suggest it's just a
blob of octets *but I disprove this when discussing beauty later on in the next
section.*

7. The string **METHINKS IT IS LIKE A WEASEL** is searched for by default
(except when it's not searched by default) but it's nowhere to be found in the
source file in that form. Why? Because anyone familiar with the Weasel program
won't recognise the string and put together what it is by looking at the source
code.

In case you wondered deciphering #5 won't decipher #7 (neither will deciphering
\#7 help you decipher #5).


### <a name="beauty">Beauty</a>

Skip to [How to build](#build).

On the subject of beauty: the judges stated in the guidelines the following:

> We want to get away from source that is simply **a compact blob of
> octets.**   Really try to be more creative than **blob coding.** *HINT!*

And if you'll notice that although it *might look like a compact blob of octets*
at first glance if you look throughout the file you'll see two statements to
set your thinking straight:


> **NO BLOB CODING**


> **THIS IS NOT A COMPACT BLOB OF OCTETS**

So you see even if your eyes are trying to deceive you they're quite wrong. Yes
some of it might look like a blob but this is clearly false; *as all good
programmers know if something is potentially confusing or misleading it should
be made clear in the comments! :)*


## **5. <a name="build">How to build</a>**

### <a name="constants">S and N Constants</a>

Skip to [Compilation](#compiling).

These two **`#define`**d constants can be redefined at compilation to modify the
behaviour of the program in a number of ways (see the
**[Compilation](#compiling)** subsection for example invocations). Both are
capped to be no greater than **`SIZE_MAX - 1`**. This is handled by the C
preprocessor.


**`S`**    

This determines the maximum size of the target string but it **must be at least
38**; this is because **`38 >= 29`** and because **`strlen("METHINKS IT IS LIKE
A WEASEL") == 28`** (which is the default target string - it would hardly be an
implementation of the Weasel program otherwise).

There is obviously a reason **`38`** is the chosen size but the only hints I
provide are those in **[How it works](#how)** and specifically an Easter egg I
referenced there (it's *not the only Easter egg* but it's the only Easter egg I
won't spoil; yes this ironically and amusingly means I've left a rotten egg
somewhere!).

**`N`**

This is the number of offspring per generation. Anything less than 4 will be set
to 3 (that's not a typo!) and this is part of an Easter egg.

Be aware that depending on the size of **`S`** and **`N`** (individually and
together) the program will use varying amounts of memory and the larger the
values the more memory it'll require.


### <a name="compiling">Compilation</a>

Skip to [Portability](#portability).

The following options **must always be passed to the compiler:**

	    -DQ='typedef' -D'g(o)'='goto o;' -D'w(x)'="x:" -D'H(main)'='r(main)'

If you want to increase the number of offspring to **`50`** and the size of the
chromosome to **`75`** you would pass to the compiler:

	    -DQ='typedef' -D'g(o)'='goto o;' -D'w(x)'="x:" -D'H(main)'='r(main)' -DN=50 -DS=75

If you wanted to change **`N`** to **`3`**:

	    -DQ='typedef' -D'g(o)'='goto o;' -D'w(x)'="x:" -D'H(main)'='r(main)' -DN=3

Remember that it cannot be less than **`3`**; *more correctly if it's less than
4 it's redefined to 3* so you could have passed in **`-DN=2`** and have the same
result. Remember too that **`S`** cannot be less than **`38`**. Both **`S`** and
**`N`** are capped at **`SIZE_MAX - 1`**.

### <a name="portability">Portability</a>

Skip to [An aside on bugs](#bugs).

The entry works for both C99 and C11 (it *requires at least C99 even if you
translate digraphs*). The program doesn't require third-party libraries and
should work on any Unix based system. It works on both 64-bit and 32-bit (but
inevitably some data type sizes will be smaller and this I believe includes
**`SIZE_MAX`**). I don't think Windows gcc ports would have many issues (if any)
either but I have no way to test this. I have tested the following systems and
configurations:

	    Fedora 26:

	    $ clang --version|head -n1
	    clang version 4.0.1 (tags/RELEASE_401/final)
	    $ gcc --version|head -n1
	    gcc (GCC) 7.3.1 20180130 (Red Hat 7.3.1-2)
	    $ /lib64/libc-2.25.so |head -n1|cut -d',' -f1-1
	    GNU C Library (GNU libc) stable release version 2.25
	    $ lscpu |grep Endian
	    Byte Order:          Little Endian


	    CentOS Linux release 7.4.1708 (Core)

	    $ clang --version|head -n1
	    clang version 3.4.2 (tags/RELEASE_34/dot2-final)
	    $ gcc --version|head -n1
	    gcc (GCC) 4.8.5 20150623 (Red Hat 4.8.5-16)
	    $ /lib64/libc-2.17.so |head -n1 |cut -d, -f1-1
	    GNU C Library (GNU libc) stable release version 2.17
	    $ lscpu |grep Endian
	    Byte Order:            Little Endian


	    Fedora 27:

	    $ clang --version|head -n1
	    clang version 5.0.1 (tags/RELEASE_501/final)
	    $ gcc --version|head -n1
	    gcc (GCC) 7.3.1 20180303 (Red Hat 7.3.1-5)
	    $ /lib64/libc-2.26.so |head -n1|cut -d, -f1-1
	    GNU C Library (GNU libc) stable release version 2.26
	    $ lscpu |grep Endian
	    Byte Order:          Little Endian

	    
	    macOS:

	    System Version: macOS 10.13.4 (17E199)
	    Kernel Version: Darwin 17.5.0
	    $ gcc -v
	    Configured with: --prefix=/Library/Developer/CommandLineTools/usr --with-gxx-include-dir=/usr/include/c++/4.2.1
	    Apple LLVM version 9.1.0 (clang-902.0.39.1)
	    Target: x86_64-apple-darwin17.5.0
	    Thread model: posix
	    InstalledDir: /Library/Developer/CommandLineTools/usr/bin
	    $ uname -srmv
	    Darwin 17.5.0 Darwin Kernel Version 17.5.0: Mon Mar  5 22:24:32 PST 2018; root:xnu-4570.51.1~1/RELEASE_X86_64 x86_64


#### <a name="bugs">An aside</a>

Skip to [Installing](#rpm).

Any undocumented bugs are the result of insolent monkeys tampering with any
number of things. That includes but is not limited to running the program on a
non-ASCII system; non little-endian; meddling with **`S`** or **`N`** too much,
changing the references to **`SIZE_MAX`** to be larger than **`SIZE_MAX`** or a
signed value (**`size_t`** is unsigned) or too small of a value; changing data
types or variables; expecting really long strings - including but not limited to
the complete works of Shakespeare (hint: **`isprint('\n') == 0`** so it won't
ever find any string with **`'\n'`**) - to be found by the program in a quick
and easy fashion if ever; or any other meddling including being petulant and/or
unreasonable monkeys. I will say though that there is at least one place I see
after having won that could be slightly more efficient (can you find it?); I am
however leaving it as it is because this is what won.


### <a name="rpm">Installing</a>

Skip to [Final thoughts](#thoughts).

I have included a RPM spec file for those with a Red Hat based Linux
distribution; see [rpm.markdown][] for details (including why I implemented
this) if for some (strange?) reason you're interested.

[rpm.markdown]: rpm.markdown


## **6. <a name="thoughts">Final thoughts</a>**

Skip to [Winning comments](#winning).

The judges suggested that making them laugh helps entries chance of winning.
Well *laughter helps everything* so in case you haven't seen - and *even if you
have seen* - Dennis Ritchie's anti-foreword to the ghastly *UNIX-HATERS
Handbook* or Ken Thompson's revelation that C and Unix are a hoax (at the end of
that book) I include it below; because I agree that looking at a lot of twisted
code must be quite difficult (though maybe not as much as if you were to have to
look at Microsoft Windows code or code for Windows in any case ? :)) and these
two things I think are rather amusing (in order of least to most):

<a name="dmr">Dennis Ritchie's</a> Anti-Foreword:

> Anti-Foreword

> By Dennis Ritchie
> From: dmr@plan9.research.att.com
> Date: Tue, 15 Mar 1994 00:38:07 EST
> Subject: anti-foreword

> To the contributers to this book:

> I have succumbed to the temptation you offered in your preface: I do write you
> off as envious malcontents and romantic keepers of memories.  The systems you
> remember so fondly (TOPS-20, ITS, Multics, Lisp Machine, Cedar/Mesa, the Dorado)
> are not just out to pasture, they are fertilizing it from below.

> Your judgments are not keen, they are intoxicated by metaphor. In the Preface
> you suffer first from heat, lice, and malnourishment, then become prisoners in
> a Gulag. In Chapter 1 you are in turn infected by a virus, racked by drug
> addiction, and addled by puffiness of the genome.

> Yet your prison without coherent design continues to imprison you. How can
> this be, if it has no strong places? The rational prisoner exploits the weak
> places, creates order from chaos: instead, collectives like the FSF vindicate
> their jailers by building cells almost compatible with the existing ones, albeit
> with more features. The journalist with three undergraduate degrees from MIT,
> the researcher at Microsoft, and the senior scientist at Apple might volunteer a
> few words about the regulations of the prisons to which they have been
> transferred.

> Your sense of the possible is in no sense pure: sometimes you want the same
> thing you have, but wish you had done it yourselves; other times you want
> something different, but can't seem to get people to use it; sometimes one
> wonders why you just don't shut up and tell people to buy a PC with Windows or a
> Mac. No Gulag or lice, just a future whose intellectual tone and interaction
> style is set by Sonic the Hedgehog. You claim to seek progress, but you succeed
> mainly in whining.

> Here is my metaphor: your book is a pudding stuffed with apposite
> observations, many well-conceived. Like excrement, it contains enough undigested
> nuggets of nutrition to sustain life for some. But it is not a tasty pie: it
> reeks too much of contempt and of envy.

> Bon appetit!

Yes he misspelt *'contributors'*! But then again we're talking about obfuscation
and since it doesn't break his message it's not broken - it's just obfuscated
albeit not very much (and it still *'compiles'!*); and isn't that what this
contest is about? :)

<a name="ken">Ken Thompson's</a> ending:

> Creators Admit C, Unix Were Hoax

> FOR IMMEDIATE RELEASE

> In an announcement that has stunned the computer industry, Ken Thompson,
Dennis Ritchie, and Brian Kernighan admitted that the Unix operating system and
C programming language created by them is an elaborate April Fools prank kept
alive for more than 20 years. Speaking at the recent UnixWorld Software
Development Forum, Thompson revealed the following:

> "In 1969, AT&T had just terminated their work with the GE/AT&T Multics
project.  Brian and I had just started working with an early release of Pascal
from Professor Nichlaus Wirth's ETH labs in Switzerland, and we were impressed
with its elegant simplicity and power. Dennis had just finished reading Bored of
the Rings, a hilarious National Lampoon parody of the great Tolkien Lord of the
Rings trilogy. As a lark, we decided to do parodies of the Multics environment
and Pascal. Dennis and I were responsible for the operating environment. We
looked at Multics and designed the new system to be as complex and cryptic as
possible to maximize casual users' frustration levels, calling it Unix as a
parody of Multics, as well as other more risque allusions.

> "Then Dennis and Brian worked on a truly warped version of Pascal, called "A."
When we found others were actually trying to programs with A, we quickly added
additional cryptic features and evolved into B, BCPL, and finally C. We stopped
when we got a clean compile on the following syntax:

	    for(;P("\n"),R=;P("|"))for(e=C;e=P("_"+(*u++/
	    8)%2))P("|"+(*u/4)%2);

> "To think that modern programmers would try to use a language that allowed
such a statement was beyond our comprehension! We actually thought of selling
this to the Soviets to set their computer science progress back 20 or more
years. Imagine our surprise when AT&T and other U.S. corporations actually began
trying to use Unix and C!  It has taken them 20 years to develop enough
expertise to generate even marginally useful applications using this 1960s
technological parody, but we are impressed with the tenacity (if not common
sense) of the general Unix and C programmer.

> "In any event, Brian, Dennis, and I have been working exclusively in Lisp on
the Apple Macintosh for the past few years and feel really guilty about the
chaos, confusion, and truly bad programming that has resulted from our silly
prank so long ago."

> Major Unix and C vendors and customers, including AT&T, Microsoft,
Hewlett-Packard, GTE, NCR, and DEC have refused comment at this time.  Borland
International, a leading vendor of Pascal and C tools, including the popular
Turbo Pascal, Turbo C, and Turbo C++, stated they had suspected this for a
number of years and would continue to enhance their Pascal products and halt
further efforts to develop C. An IBM spokesman broke into uncontrolled laughter
and had to postpone a hastily convened news conference concerning the fate of
the RS/6000, merely stating "Workplace OS will be available Real Soon Now." In a
cryptic statement, Professor Wirth of the ETH Institute and father of the
Pascal, Modula 2, and Oberon structured languages, merely stated that P. T.
Barnum was correct.

**So is it a hoax about a non-hoax, a non-hoax about a hoax, a non-hoax about a
non-hoax or is it a hoax about a hoax ? :) And if it's any of those what does it
mean about Unix and C?** And if a hoax is involved *what is the hoax?* The pedant
and Tolkienist that I am has to state that **Tolkien didn't consider The Lord of
the Rings a trilogy** *(and he made that very clear)* but that doesn't take away
from the humour by any stretch (*if anyone wants me to elaborate or debate the
matter do send me an email - I love Tolkien's legendarium and having another
person to talk about it with is more than welcome!*). Ken suggested that there
is a lack of common sense but since he was part of its creation I don't think
it's a bad thing; **on the contrary it makes all of us C programmers even more
talented! :)** I do wonder if he tested that bit of C code though:

	    for(;P("\n"),R=;P("|"))for(e=C;e=P("_"+(*u++/
	    8)%2))P("|"+(*u/4)%2);
	   
How is **`R=;`** valid? Since I don't have the context maybe there is something
I'm missing but either way it's a funny piece. It could also be for irony itself
(actually I had previously thought of somehow implementing something like that
for the contest but decided for the message by itself in the end). I would
prefer believing that whether true or not.

## **7. <a name="winning">Winning comments, thanks, dedications, links, etc.</a>**

I feel incredibly honoured, privileged and I am extremely happy and proud to
have won! I am more proud and happy about this than anything I have ever done in
my life and I don't think there can be anything else I can be more proud of in
the future (except winning again should I find or think of another interesting
thing to try and implement in an obfuscated way). Because winning is one thing;
but to be included amongst very clever and talented veterans whom I highly
respect is an incredible badge of honour that I will proudly wear (literally too
as I hope to get my entry on a shirt) for the rest of my life. This type of
badge is something I feel most only dream of but never come close to earning.
That I did is by far the best feeling I can think of.

Thank you Simon Cooper, Landon Curt Noll and Leonid A. Broukhis, and thank you
to everyone who has been an important and special part of my life. I want to
specially name some:

I dedicated this program to my beloved but recently late dog Venus; instead of
drowning in grief I channelled it to creativity. And to have won a contest
requiring creativity, cleverness and novelty is a tribute to an equally
creative, clever and unique dog that she was. I miss you terribly Venus but I'm
so happy to have had you in my life.

But I want to also dedicate it to (and thank) my dear friend Martijn Schoemaker
whom provided me with the spark a very long time ago (and whom has stood by me
and helped me in more ways than he can know - **`#including C`**); if it wasn't
for you Martijn I wouldn't have been able to win so consider this a recursive
thank you thank you! :) I would also like to give thanks and much love to my
best and closest friend Vicky Wilmore who means the absolute world to me; thank
you for being such a wonderfully beautiful person and friend - that truly is
what 'just you' means, sweetheart, and don't you forget it! <3 Finally I would
like to thank my mother for being the best mum anyone could ask for, who's
always been here for me and whom I also inherit the keen analytical mind from. I
love you all!

I want to also thank Dave Burton for acknowledging me in his hint.markdown file
for as he put it 'being relentless with pursuit of bugs'. To think that it was
circumstantial to my entry too makes it all the more unlikely but that doesn't
take away the significance of it; for I am a very symbolic person and being
acknowledged for this type of thing is great but to be acknowledged for it by
someone who has won more than once is even more special to me: thank you Dave!
It means a great deal to me and I am glad I could help! :)

I would also like to say to the judges about their commentary as well as the
category title: they're all very dear to me and that includes not just the
remarks but the example invocations. They fit my views precisely. As for the
test-strings.txt file modifications: very amusing and I certainly do not object.
Thank you again for such an honour and privilege! That this isn't a dream is the
best reality imaginable! :)

Congratulations to one and all for winning; it's an honour to win such a
wonderful contest requiring creativity, cleverness, uniqueness and
inventiveness but to win beside all the other wonderful entries is truly
special!

Shortly after the entry has been published I will have more information on the
winning entry at [https://ioccc.xexyl.net/2018/weasel][] including how to
contact me (besides what's already published on the IOCCC website). There also
is an [errata page][] so that in the case I find anything I would like to
correct in the documentation or other supplementary files I can note them there.

If you wish to contact me please do so; although I have a Twitter account I don't
really use it so please send me an email instead. I do have Facebook as of a
little under two years but I'll worry about that at such a time (I presume in
fact 'if') it becomes relevant.

[https://ioccc.xexyl.net/2018/weasel]: https://ioccc.xexyl.net/2018/weasel
[errata page]: https://ioccc.xexyl.net/2018/weasel/errata

--------------------------------------------------------------------------------
<!--
(c) Copyright 1984-2018, [Leo Broukhis, Simon Cooper, Landon Curt Noll][judges] - All rights reserved
This work is licensed under a [Creative Commons Attribution-ShareAlike 3.0 Unported License][cc].

[judges]: http://www.ioccc.org/judges.html
[cc]: http://creativecommons.org/licenses/by-sa/3.0/
-->
